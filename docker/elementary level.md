# Docker. Базовый уровнень

## Основные понятия

### Контейнер (Container)

Контейнер — это лёгковесная, изолированная, исполняемая среда, в которой запускается приложение со всеми его зависимостями (библиотеками, конфигурациями, переменными окружения и т.д.).
Он «упаковывает» приложение так, чтобы оно одинаково работало в любом окружении: на вашем компьютере, на сервере, в облаке.

Контейнеры работают поверх хостовой операционной системы и используют её ядро (kernel). Изоляция достигается с помощью механизмов ядра Linux:

* Namespaces — изолируют процессы, сеть, файловую систему и т.д.
* Cgroups (Control Groups) — ограничивают использование ресурсов (CPU, память, диски).

**Отличие от виртуальной машины:**

Виртуальная машина — это полная эмуляция компьютера, включающая:
* Виртуальный CPU, RAM, диск, сеть,
* Отдельную операционную систему (например, Ubuntu, Windows),
* Гипервизор (например, VMware, VirtualBox, Hyper-V), который управляет виртуализацией.

Каждая VM запускает собственное ядро ОС, независимо от хоста.

**Как Namespaces изолируют контейнер:**

* **Namespaces** отвечают за логическую изоляцию процессов внутри контейнера от хост-системы и других контейнеров. Они создают «иллюзию», что контейнер — это отдельная система, хотя на самом деле он использует ядро хоста.

Каждый **namespace** изолирует определённый аспект системы:

|Namespace|Что изолирует|Пример поведения в контейнере|
|---|---|---|
|PID|Процессы (Process IDs)|Внутри контейнера `ps` показывает только свои процессы; `init` имеет PID 1|
|Network|Сетевые интерфейсы, IP-адреса, порты, таблицы маршрутизации|Контейнер имеет свой `lo`, `eth0`, может слушать порт 80, даже если на хосте он занят|
|Mount|Файловую систему|Контейнер видит только свой корень `/`; хост-файлы скрыты (если не примонтированы явно)|
|UTS|Имя хоста и домен|`hostname` внутри контейнера отличается от хоста|
|IPC|Межпроцессное взаимодействие (очереди, семафоры и т.д.)|Контейнер не может использовать IPC-объекты других контейнеров|
|User|Пользователей и группы|Пользователь `root` внутри контейнера ≠ `root` на хосте (если включена user namespace remapping)|
|Cgroup|Иерархию cgroups (начиная с Linux 4.6)|Позволяет изолировать представление о cgroup-иерархии внутри контейнера|

* **Cgroups (Control Groups)** — ограничение ресурсов. **Cgroups** отвечают за ограничение, учёт и приоритезацию использования системных ресурсов. **Cgroups** позволяют задать жёсткие или мягкие лимиты на то, сколько ресурсов может использовать группа процессов (в нашем случае — контейнер).

|Ресурс|Как ограничивается|Пример в Docker|
|---|---|---|
|CPU|Ограничение по времени CPU или количеству ядер|`--cpus=1.5`, `--cpu-quota`|
|Память (RAM)|Максимальный объём памяти|`--memory=512m`|
|Swap|Использование свопа (дополнительной памяти на диске)|`--memory-swap`|
|Блок I/O|Ограничение скорости чтения/записи на диск|`--blkio-weight`|
|Сеть|Ограничение пропускной способности (требует доп. инструментов, например, `tc`)|Не напрямую через cgroups v1, но возможно через другие механизмы|

* **Как это работает технически**
1. При запуске контейнера **Docker** создаёт новую **cgroup** для его процессов.
2. В специальных файлах виртуальной файловой системы (обычно `/sys/fs/cgroup/`) записываются лимиты.
3. Ядро Linux следит, чтобы процессы в этой **cgroup** не превышали лимиты. Если контейнер исчерпает лимит памяти — ядро убьёт один из его процессов (обычно через OOM killer).

**Пример:**

```bash
docker run -d --memory=256m --cpus=1 nginx
```

Docker делает следующее:
* Создаёт новые namespaces → контейнер получает изолированное окружение.
* Создаёт cgroup с лимитами → контейнер не сможет использовать больше 256 МБ RAM и 100% одного CPU-ядра.
* Запускает процесс (nginx) внутри этой изолированной и ограниченной среды.


Несмотря на изоляцию, контейнер ≠ виртуальная машина:
* Все контейнеры используют одно ядро ОС.
* Уязвимости в ядре могут повлиять на все контейнеры и хост.
* По умолчанию root в контейнере = root на хосте (если не включены user namespaces).

### Образ (Docker Image)

Образ — это неизменяемый (immutable) шаблон, содержащий:

* Файловую систему,
* Код приложения,
* Библиотеки, зависимости,
* Инструкции для запуска (`CMD`, `ENTRYPOINT` и др.).

Образ состоит из слоёв (**layers**). Каждая инструкция в **Dockerfile** создаёт новый слой. Слои кэшируются и переиспользуются — это делает сборку быстрой.

Пример:

```docker
FROM alpine:latest          # слой 1
RUN apk add --no-cache curl # слой 2
COPY app.sh /app/           # слой 3
CMD ["/app/app.sh"]         # слой метаданных
```

* Контейнер — это запущенный образ.
* При запуске контейнера Docker добавляет сверху образа writable-слой (так называемый container layer), куда попадают все изменения (запись файлов, установка пакетов и т.д.).
* Когда контейнер останавливается, этот слой теряется, если не сохранён явно (например, через volume).
* Один и тот же образ можно запускать многократно — получится множество независимых контейнеров.

### Docker Engine

Это сердце **Docker** — фоновая служба (daemon), которая управляет:

* Сборкой образов,
* Запуском и остановкой контейнеров,
* Сетями, томами, плагинами и т.д.

Работает как сервер, принимающий команды через API.

Состоит из трёх частей:
1. **Docker Daemon** (`dockerd`) — служба, управляющая Docker-объектами.
2. **REST API** — интерфейс для взаимодействия с daemon'ом.
3. **CLI** (`docker`) — клиентская утилита, которая по умолчанию общается с daemon’ом через API.

**Docker CLI (Command-Line Interface)** - Это командная утилита docker, для взаимодействия в терминале:

```bash
docker build -t my-app .
docker run -p 8080:80 my-app
docker ps
```

CLI — это клиент, который отправляет запросы Docker Engine’у (обычно на том же хосте, но может быть и удалённо).

**Docker Hub** - Это публичный реестр (registry) образов, управляемый компанией Docker.
Есть и другие registry: GitLab Container Registry, Amazon ECR, Google Container Registry, Harbor и т.д. Docker Hub — просто самый известный публичный.

Итог:
* **Контейнер** — это изолированный, лёгкий процесс, запущенный из образа.
* **Образ** — неизменяемый шаблон с приложением и зависимостями.
* **Docker Engine** — движок, управляющий всем.
* **Docker CLI** — ваш инструмент для управления через терминал.
* **Docker Hub** — онлайн-хранилище образов.

## Работа с образами

* Запуск готового образа из Docker Hub:
```bash
docker run hello-world
```

* Поиск и скачивание образов:
```bash
docker pull nginx
```

* Просмотр локальных образов:
```bash
docker images
```

## Запуск и управление контейнерами

* Запуск контейнера с параметрами (порт, имя, фон):
```bash
docker run -d -p 8080:80 --name my-nginx nginx
```

* Просмотр запущенных и остановленных контейнеров:
```bash
docker ps
docker ps -a
```

* Остановка и удаление контейнера:
```bash
docker stop my-nginx
docker rm my-nginx
```

## Простой Dockerfile

* Пример базового Dockerfile для GO-приложения:
```docker
# Используем официальный образ Go как базовый
FROM golang:1.23-alpine

# Устанавливаем рабочую директорию внутри контейнера
WORKDIR /app

# Копируем go.mod и go.sum (если есть зависимости)
COPY go.mod go.sum ./

# Скачиваем зависимости
RUN go mod download

# Копируем исходный код
COPY . .

# Собираем бинарник
RUN go build -o main .

# Указываем порт, который будет использовать приложение
EXPOSE 8080

# Запускаем приложение
CMD ["./main"]
```

Этот Dockerfile использует одноэтапную сборку, но образ получается довольно большим (т.к. в нём остаётся весь Go SDK).
Обычно используют многоэтапную сборку (multi-stage build):
```docker
# ─── Этап 1: Сборка бинарника ───
FROM golang:1.23-alpine AS builder

# Устанавливаем рабочую директорию
WORKDIR /app

# Копируем зависимости (для эффективного кэширования)
COPY go.mod go.sum ./
RUN go mod download

# Копируем исходный код
COPY . .

# Собираем статически линкованный бинарник (без внешних зависимостей)
RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o main .

# ─── Этап 2: Финальный образ ───
FROM alpine:latest

# Обновляем систему и устанавливаем ca-certificates (для HTTPS)
RUN apk --no-cache add ca-certificates

# Устанавливаем рабочую директорию
WORKDIR /root/

# Копируем бинарник из этапа builder
COPY --from=builder /app/main .

# Указываем порт (не обязательный для запуска)
EXPOSE 8080

# Запускаем приложение
CMD ["./main"]
```

1. `FROM golang:1.23-alpine AS builder` - Первый этап: сборка. Мы даём ему имя `builder`, чтобы потом сослаться на него.
2. `CGO_ENABLED=0 GOOS=linux` - Говорим Go создать статически линкованный бинарник, который не зависит от системных библиотек — это критично, чтобы он работал в `alpine`.
3. `FROM alpine:latest` - Второй этап: минималистичный образ только с необходимым для запуска.
4. `COPY --from=builder ...` - Берём только бинарник из предыдущего этапа — всё остальное (исходники, Go, зависимости) остаётся за бортом.
5. `ca-certificates` - Нужен, если ваше приложение делает HTTPS-запросы (иначе SSL-сертификаты не проверятся).

* Сборка и запуск образа:
```bash
# Сборка образа
docker build -t my-go-app .

# Запуск контейнера
docker run -p 8080:8080 my-go-app.
```

## Работа с томами и переменными окружения

* Проброс файлов/папок в контейнер (Связать папку или файл с хоста с путём внутри контейнера, чтобы данные сохранялись вне контейнера и были доступны между перезапусками):
```bash
docker run -v $(pwd):/app my-app
```
Без проброса томов контейнер остаётся «закрытой коробкой» — удобной для запуска, но бесполезной для реальных приложений, которые что-то хранят, конфигурируются или разрабатываются.

Разработка без пересборки - ` -v $(pwd):/app`
Хранение данных между запусками - ` -v /data:/app/uploads`
Гибкая конфигурация - ` -v ./config.yaml:/app/config.yaml`
Сбор логов на хост - ` -v /logs:/app/logs`
Доступ к системным ресурсам - ` -v /var/run/docker.sock:/var/run/docker.sock`

* Передача переменных окружения:
```bash
docker run -e DB_HOST=localhost my-app
```

## Логирование и отладка

* Просмотр логов контейнера:
```bash
docker logs my-nginx
```

* Запуск интерактивной сессии (для отладки)
```bash
docker exec -it my-nginx sh
```
