# Redis

Redis (Remote Dictionary Server) — это высокопроизводительная in-memory NoSQL СУБД, поддерживающая различные структуры данных.

## Структуры данных, принципы хранения, основные команды

### Основные структуры данных в Redis

Redis поддерживает несколько типов данных, каждый со своим набором команд:

| Структура данных | Описание | Примеры команд |
|--|--|--|
| String | Простые строки, числа или бинарные данные (до 512 МБ) | `SET`, `GET`, `INCR`, `APPEND` |
| List | Представляют собой упорядоченные коллекции строк, связные списки строк. Они могут использоваться для реализации очередей, стеков и других структур данных. | `LPUSH`, `RPUSH`, `LPOP`, `LRANGE` |
| Hash | Представляют собой набор пар "ключ-значение" | `HSET`, `HGET`, `HGETALL`, `HDEL` |
| Set | Неупорядоченная коллекция уникальных строк | `SADD`, `SMEMBERS`, `SINTER` (пересечение) |
| Sorted Set (ZSet) | Это расширение множеств, где каждый элемент имеет связанный с ним балл (score). Элементы в упорядоченном множестве сортируются по их баллам, что позволяет эффективно выполнять операции, такие как получение элементов в определенном диапазоне | `ZADD`, `ZRANGE`, `ZREVRANGE` |
| HyperLogLog | Вероятностная структура для подсчета уникальных значений с использованием фиксированного объема памяти | `PFADD`, `PFCOUNT`, `PFMERGE` |
| Stream | Это структура данных, предназначенная для работы с последовательностями записей. Потоки позволяют реализовать системы обмена сообщениями и обработки событий (похоже на Kafka) | `XADD`, `XREAD`, `XGROUP` |
| Geospatial | Хранение географических координат | `GEOADD`, `GEODIST`, `GEORADIUS` |
| Bitmaps | Это специальный тип строк, который позволяет работать с битами. Битовые карты могут использоваться для хранения и обработки больших объемов данных | `SETBIT`, `GETBIT`, `BITCOUNT` |

### Принципы хранения данных

* In-Memory (в оперативной памяти) — данные хранятся в RAM, что обеспечивает высокую скорость (микросекундные отклики).
* Persistence (сохранение на диск):
    * RDB (Redis Database) — Создает снимок базы данных через заданные интервалы времени.
    * AOF (Append Only File) — Записывает каждую операцию, изменяющую данные в файл, что позволяет восстановить состояние базы данных.
* Кэширование: автоматическое удаление данных при истечении TTL (Time To Live).
* Кластеризация: шардирование данных между узлами (Redis Cluster).
* Репликация: позволяет создавать копии данных на других серверах. Это обеспечивает отказоустойчивость и балансировку нагрузки.
* Транзакции: поддерживает транзакции, которые позволяют выполнять несколько операций атомарно. Это достигается с помощью команд MULTI, EXEC, WATCH и других.
* Публикация/Подписка (Pub/Sub): Redis поддерживает механизм публикации и подписки, который позволяет приложениям обмениваться сообщениями в реальном времени.

### Основные команды Redis

| Команда | Описание | Пример |
|--|--|--|
| SET | Установка значения ключа | SET user:1 "Alice" |
| GET | Получение значения ключа | GET user:1 -> "Alice" |
| DEL | Удаление ключа | DEL user:1 |
| EXISTS | Проверка существования ключа | EXISTS user:1 -> 1 (есть) |
| EXPIRE | Установка времени жизни (TTL) в секундах | EXPIRE user:1 60 |
| TTL | Получение оставшегося TTL ключа | TTL user:1 -> 55 |
| KEYS | Поиск ключей по шаблону | KEYS user:* |
| FLUSHDB | Удаление всех ключей в текущей БД | FLUSHDB |
| TYPE | Получение типа значения ключа | TYPE user:1 -> string |

**Примеры:**

String:
```bash
SET counter 10
INCR counter  # -> 11
GET counter   # -> "11"
```

Hash:
```bash
HSET user:1000 name "Bob" age 30
HGET user:1000 name  # -> "Bob"
```

List:
```bash
LPUSH tasks "task1"
RPUSH tasks "task2"
LRANGE tasks 0 -1  # -> ["task1", "task2"]
```

Set:
```bash
SADD tags "redis" "database" "redis"
SMEMBERS tags  # → ["redis", "database"]
```

## redis-cli

`redis-cli` — это консольный клиент для взаимодействия с Redis. С его помощью можно выполнять команды, тестировать производительность и мониторить состояние сервера.

Основные команды `redis-cli`:
* `redis-cli` - Подключение к локальному Redis (порт 6379)
* `redis-cli -h <host> -p <port> -a <password>` - Подключение к удалённому серверу 
* `AUTH <password>` - Аутентификация после подключения 
* `PING` - Проверка доступности сервера (должен ответить PONG)
* `QUIT` - Выход из redis-cli

Информация о сервере:

* `INFO` - Полная информация о сервере (CPU, память, клиенты и т. д.)
* `INFO <section>` - Информация по конкретной секции (`memory`, `clients`, `stats` и др.)
* `CONFIG GET *` - Получение всех настроек Redis 
* `CONFIG GET <parameter>` - Получение конкретного параметра 
* `DBSIZE` - Количество ключей в текущей БД 
* `TIME` - Текущее время сервера (Unix timestamp + микросекунды)

Управление базами данных:

* `SELECT <index>` - Переключение на другую БД (0-15 по умолчанию)
* `FLUSHDB` - Удаление всех ключей в текущей БД 
* `FLUSHALL` - Удаление всех ключей во всех БД

Мониторинг:

* `MONITOR` - Просмотр всех команд, выполняемых на сервере (может быть ресурсоёмким)
* `SLOWLOG GET` - Просмотр медленных запросов (настраивается `slowlog-log-slower-than`)
* `CLIENT LIST` - Список всех подключённых клиентов
* `CLIENT KILL <id>` - Отключение клиента по ID

Команды для отладки:

* `redis-benchmark` - Тест производительности Redis (запускается отдельно, не в `redis-cli`)
* `MEMORY USAGE <key>` - Показывает, сколько памяти занимает ключ

Анализ ключей:

* `SCAN <cursor> [MATCH pattern]` - Итерация по ключам (без блокировки сервера)
* `TYPE <key>` - Тип значения ключа (`string`, `hash`, `list` и т. д.)
* `TTL <key>` - Оставшееся время жизни ключа (в секундах, `-1` — нет TTL)

Примеры:

```bash
redis-cli -h 127.0.0.1 -p 6379 -a mypassword

INFO memory     # Статистика использования памяти
INFO clients    # Активные подключения
CLIENT LIST     # Список клиентов
SLOWLOG GET 5   # 5 самых медленных запросов
SCAN 0 MATCH "user:*"  # Поиск всех ключей, начинающихся с "user:"
```

Для более глубокого мониторинга можно использовать RedisInsight, Grafana + Prometheus или команду `redis-cli --stat`.

## Как избежать протухания кэша

Протухание кэша происходит, когда данные в кэше становятся устаревшими или недействительными. Чтобы избежать этого, можно использовать следующие подходы:

* **TTL (Time To Live)**: Устанавливайте время жизни для кэшированных данных, чтобы они автоматически удалялись после истечения срока. Это позволяет гарантировать, что данные будут обновляться через определенные интервалы времени.

* **Инвалидация кэша**: Механизм, в котором обновляться или удаляться кэшированные данные при изменении исходных данных. Например, при обновлении базы данных можно отправлять уведомления о необходимости обновления кэша.
    * **Write-Through** - данные сначала записываются в кэш, а затем сразу же записываются в основное хранилище. Это гарантирует, что данные в кэше и в базе данных всегда синхронизированы.
    *Недостатки*:
        * **Производительность**: Запись в основное хранилище может замедлить операции, особенно если база данных имеет высокую нагрузку.
    * **Write-Behind** - данные сначала записываются в кэш, а запись в основное хранилище происходит асинхронно, позже, в фоновом режиме.
    *Недостатки*:
        * **Риск несоответствия данных**: Если система сбойнет до того, как данные будут записаны в основное хранилище, это может привести к потере данных или несоответствию между кэшем и базой данных.
        * **Сложность реализации**: Требует дополнительных механизмов для управления асинхронной записью и обработки ошибок.

* **Cache-Aside (Lazy Loading)**: Кэш обновляется только при запросе данных.
    * *Недостатки*:
        * **Первоначальная задержка**: При первом запросе к данным, которые отсутствуют в кэше, может возникнуть задержка, так как данные должны быть загружены из основного хранилища.
        * **Проблемы с протуханием**: Если данные в основном хранилище изменяются, необходимо реализовать механизмы для инвалидации или обновления кэша, чтобы избежать устаревания данных.


## Как избежать Cache Stampede (лавинообразного обновления кэша)

**Cash-stampede** возникает, когда множество запросов одновременно пытается обновить кэш, что может привести к перегрузке системы. Чтобы избежать этого, можно использовать следующие методы:

* **Блокировки (Locking)**: Используйте механизмы блокировок, чтобы предотвратить одновременное обновление кэша. Например, при запросе кэшированных данных, если данные отсутствуют, блокируйте доступ к кэшу, пока данные обновляются.

* **Кэширование "на лету"** ("Просроченный" кэш + фоновое обновление): Вместо того чтобы обновлять кэш сразу, можно возвращать пустой результат или устаревшие данные, и инициировать обновление кэша в фоновом режиме. Это позволяет избежать одновременных запросов на обновление.

* **Случайная задержка**: Внедрите случайные задержки перед обновлением кэша, чтобы распределить нагрузку и избежать одновременных запросов.

* **Использование "первого запроса"**: Реализуйте механизм, который будет обрабатывать только первый запрос на получение данных, а остальные запросы будут ожидать завершения этого запроса, прежде чем продолжить.


## Грамотное определение области применения кэша

Не все данные подходят для кэширования. Чтобы эффективно использовать кэш, необходимо определить, какие данные следует кэшировать:

* **Часто запрашиваемые данные**: Кэшируйте данные, которые часто запрашиваются, чтобы снизить нагрузку на базу данных и ускорить доступ.
* **Данные с низкой изменяемостью**: Кэшируйте данные, которые редко изменяются, чтобы минимизировать проблемы с устареванием.
* **Данные, требующие высокой производительности**: Кэширование полезно для данных, доступ к которым критически важен для производительности приложения.
* **Анализ и мониторинг**: Регулярно анализируйте эффективность кэширования и корректируйте стратегию в зависимости от изменяющихся требований и поведения пользователей.


## Команды SCAN и HSCAN

Эти команды используются для безопасного (неблокирующего) перебора ключей и полей хэша, особенно в production-среде, где нельзя применять `KEYS` или `HGETALL` из-за блокировки сервера.

### `SCAN` — Итерация по ключам

Используется для итерации по всем ключам в базе данных Redis. Она возвращает курсор, который можно использовать для продолжения итерации.

```
SCAN cursor [MATCH pattern] [COUNT number] [TYPE type]
```

* `cursor` — начальное значение (0 для первого вызова).
* `MATCH` — (необязательный) фильтрует ключи по заданному шаблону. Поддерживает glob-стиль шаблоны (например, user:* для всех ключей, начинающихся с user:).
* `COUNT` — (необязательный) примерное количество ключей за итерацию (по умолчанию 10).
* `TYPE` — (необязательный) фильтрует ключи по типу данных (`string`, `hash`, `list` `set`, `zset`, `stream`).

Пример, поиск всех ключей, начинающихся с user:

```bash
SCAN 0 MATCH user:*
```

### `HSCAN` — Итерация по полям хэша

Команда `HSCAN` используется для итерации по полям и значениям хэша. Аналог `SCAN`, но для полей внутри хэша. Она также возвращает курсор для продолжения итерации. 

```
HSCAN key cursor [MATCH pattern] [COUNT number]
```

Где: `key` — имя хэша. `MATCH` — шаблон для полей (например, name*)

Пример, поиск полей по шаблону:

```bash
HSCAN user:1000 0 MATCH *name*
```

### Glob-style шаблоны в `MATCH`

Поддерживаются стандартные wildcards:

* `*`— любое количество символов.
* `?` — один любой символ.
* `[abc]` — один из символов в скобках.

Примеры шаблонов

| Шаблон | Описание | Пример совпадения |
|--|--|--|
| `user:*` | Ключи, начинающиеся с `user:` | 	`user:1000`, `user:data` |
| `*:active` | Ключи, оканчивающиеся на `:active` | `order:active` |
| `product:?` | Ключи из 1 символа после `product:` | `product:1`, `product:A` |
| temp_[123] | Символы 1, 2 или 3 | `temp_1`, `temp_2` |


### Нюансы

* **Нет гарантии полноты** - `SCAN/HSCAN` могут пропускать или дублировать ключи/поля при изменении данных во время итерации.
* `COUNT` — лишь примерный ориентир, Redis может вернуть меньше или больше ключей.
* Всегда используйте `SCAN` вместо `KEYS` * в **production**


## Redis Cluster

Redis Cluster — это горизонтально масштабируемое решение для Redis, обеспечивающее автоматическую шардировку данных и отказоустойчивость.

### Основные концепции Redis Cluster

* **Узлы (Nodes)**
    * **Мастера (Master Nodes)**: Узлы, которые хранят данные и обрабатывают запросы на запись и чтение. В Redis Cluster может быть несколько мастер-узлов, которые распределяют данные между собой.
    * **Реплики (Replica Nodes)**: Узлы, которые являются копиями мастер-узлов. Они обеспечивают отказоустойчивость и высокую доступность. Если мастер-узел выходит из строя, его реплика может быть повышена до мастера.

Минимальная конфигурация для Redis Cluster, обеспечивающая высокую доступность и отказоустойчивость, состоит из 3 мастер-узлов и 3 реплик, можно использовать и другие конфигурации, но они могут не обеспечивать такой же уровень надежности.

* **Шардинг (Sharding)**

Redis Cluster использует механизм шардинга для распределения данных между мастер-узлами. Данные разбиваются на "шарды", и каждый шард хранится на отдельном мастер-узле. Это позволяет эффективно использовать ресурсы и масштабировать систему.

* **Хэш-слоты (Hash Slots)**

Redis Cluster использует 16384 хэш-слотов для распределения ключей. Каждый ключ в Redis маппируется на один из этих слотов с помощью функции хэширования. Каждый мастер-узел отвечает за определенный диапазон хэш-слотов, что позволяет легко определить, на каком узле хранится конкретный ключ.

* **Автоматическое распределение данных**

Когда вы добавляете новый мастер-узел в кластер, Redis автоматически перераспределяет хэш-слоты между узлами, чтобы сбалансировать нагрузку. Это позволяет легко масштабировать кластер, добавляя или удаляя узлы.

Redis Cluster использует специальные команды и протоколы для управления кластером. Например:
* `CLUSTER INFO`: Получает информацию о состоянии кластера.
* `CLUSTER NODES`: Получает список всех узлов в кластере и их состояние.
* `CLUSTER MEET`: Добавляет новый узел в кластер.
* `CLUSTER FORGET`: Удаляет узел из кластера.

**Ограничения**:

* **Ограничения по типам данных**: Не все типы данных полностью поддерживаются в кластере. Например, операции с несколькими ключами, которые находятся на разных слотах, не могут выполняться атомарно.
* **Ограниченная поддержка транзакций**: Не поддерживает транзакции, охватывающие несколько ключей, если они находятся на разных узлах. Это означает, что команды, такие как `MULTI` и `EXEC`, будут работать только для ключей, находящихся на одном и том же мастер-узле.
* **Ограничения по операциям с несколькими ключами**: Команды, затрагивающие несколько ключей (например, `MGET`, `MSET`, `DEL`), могут работать только с ключами, расположенными в одном слоте. Если ключи разбросаны по разным слотам, эти команды не будут работать или потребуют использования специальных механизмов (например, хеш-слотов).
* **Ограниченная поддержка Lua-скриптов**: Lua-скрипты могут выполняться только на одном узле, что ограничивает их использование в распределенных сценариях.
* **Ограничение на количество хэш-слотов, 16384 хэш-слота**: Redis Cluster использует 16384 хэш-слота для распределения ключей. Это ограничение может стать проблемой, если у вас очень большое количество узлов и вы хотите равномерно распределить данные.
