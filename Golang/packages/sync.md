# sync

## Mutex

Мьютекс — это взаимоисключающая блокировка. Нулевое значение для мьютекса соответствует разблокированному мьютексу.
Мьютекс не должен копироваться после первого использования.
В терминологии модели памяти Go, n-й вызов Mutex.Unlock «синхронизируется до» m-го вызова Mutex.Lock для любого n < m. Успешный вызов Mutex.TryLock эквивалентен вызову Lock. Неудачный вызов TryLock вообще не устанавливает никакого отношения «синхронизируется до».

Основные методы:

* **`Lock()`**: Этот метод блокирует мьютекс. Если мьютекс уже заблокирован другой горутиной, текущая горутина будет заблокирована до тех пор, пока мьютекс не будет разблокирован.

* **`Unlock()`**: Этот метод разблокирует мьютекс. Важно вызывать `Unlock()` только в том случае, если мьютекс был успешно заблокирован, иначе программа может завершиться с паникой.

* **`TryLock() bool`**: Этот метод используется для попытки захвата блокировки без блокировки текущей горутины, если мьютекс уже занят. Это позволяет избежать блокировки, если ресурс уже используется другой горутиной, и дает возможность выполнить альтернативные действия, если захватить блокировку не удалось. Использование TryLock часто является признаком более глубокой проблемы в конкретном использовании мьютексов.

Пример:

```go
package main

import (
    "fmt"
    "sync"
    "time"
)

type SafeCounter struct {
    mu    sync.Mutex // Мьютекс для синхронизации доступа
    count int
}

// Метод для увеличения счетчика
func (c *SafeCounter) Increment() {
    c.mu.Lock()         // Захватываем блокировку
    c.count++           // Увеличиваем счетчик
    c.mu.Unlock()       // Освобождаем блокировку
}

// Метод для получения значения счетчика
func (c *SafeCounter) Value() int {
    c.mu.Lock()         // Захватываем блокировку
    defer c.mu.Unlock() // Освобождаем блокировку
    return c.count
}

func main() {
    counter := SafeCounter{}

    var wg sync.WaitGroup

    // Запускаем 10 горутин для увеличения счетчика
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Increment()
        }()
    }

    // Ждем завершения всех горутин
    wg.Wait()

    // Выводим финальное значение счетчика
    fmt.Println("Final counter value:", counter.Value())
}
```

Вывод может быть:

```bash
Counter value: 0
Counter value: 10
Counter value: 1
Counter value: 1
Counter value: 1
Final counter value: 10
```

* Старайтесь минимизировать время, в течение которого мьютекс заблокирован, чтобы избежать блокировок и повышения времени ожидания.
* Рекомендуется использовать `defer` для вызова `Unlock()`, чтобы гарантировать, что мьютекс будет разблокирован даже в случае паники.
* Мьютекс не рекурсивен: То есть, если одна и та же горутина попытается захватить уже захваченный мьютекс, произойдет дедлок.

`sync.Mutex` реализован на низком уровне с помощью системных примитивов блокировки (например, системных вызовов futex в Linux).

Go предоставляет встроенные инструменты для обнаружения состояний гонки. Используйте флаг `-race` при запуске тестов, чтобы проверить наличие состояний гонки в коде:

```go
go test -race
```

## RWMutex

RWMutex — это взаимная блокировка исключения чтения/записи. Блокировка может удерживаться произвольным количеством читателей или одним писателем. Нулевое значение RWMutex соответствует разблокированному мьютексу.

* Читатели (readers) могут захватывать мьютекс одновременно, если нет активных писателей.
* Писатели (writers) захватывают мьютекс эксклюзивно, блокируя всех читателей и других писателей.

RWMutex не должен копироваться после первого использования.

Если какая-либо горутина вызывает RWMutex.Lock, когда блокировка уже удерживается одним или несколькими читателями, одновременные вызовы RWMutex.RLock будут блокироваться до тех пор, пока пишущий не получит (и не освободит) блокировку, чтобы гарантировать, что блокировка в конечном итоге станет доступной писателю. Обратите внимание, что это запрещает рекурсивную блокировку чтения. RWMutex.RLock не может быть повышен до RWMutex.Lock, а RWMutex.Lock не может быть понижен до RWMutex.RLock.

В терминологии модели памяти Go, n-й вызов RWMutex.Unlock «синхронизируется до» m-го вызова Lock для любого n < m, как и для Mutex. Для любого вызова RLock существует n такое, что n-й вызов Unlock «синхронизируется до» этого вызова RLock, а соответствующий вызов RWMutex.RUnlock «синхронизируется до» n+1-го вызова Lock.

Основные методы:

* **`Lock()`**: Lock блокирует rw для записи. Если блокировка уже заблокирована для чтения или записи, Lock блокируется до тех пор, пока блокировка не будет снята.

* **`RLock()`**: RLock блокирует rw для чтения. Не следует использовать RLock для рекурсивной блокировки чтения; заблокированный вызов Lock исключает возможность получения блокировки новыми читателями.

* **`Unlock()`**: Unlock разблокирует rw для записи. Если при входе в разблокировку запись в rw не заблокирована, возникает ошибка времени выполнения (run-time error).
Как и в случае с мьютексами, заблокированный RWMutex не связан с конкретной горутиной. Одна горутина может выполнить RWMutex.RLock (RWMutex.Lock) для RWMutex, а затем передать его другой горутине для выполнения RWMutex.RUnlock (RWMutex.Unlock).

* **`RUnlock()`**: RUnlock отменяет один вызов RWMutex.RLock; это не влияет на другие одновременные операции чтения. Если rw не заблокирован для чтения при входе в RUnlock, возникает ошибка времени выполнения.

Остальные методы:

* **`RLocker() Locker`**: RLocker возвращает интерфейс Locker, который реализует методы [Locker.Lock] и [Locker.Unlock] путем вызова rw.RLock и rw.RUnlock.

* **`TryLock() bool`**: tryLock пытается заблокировать rw для записи и сообщает, удалось ли это сделать. Обратите внимание, что, хотя правильное использование tryLock действительно существует, оно встречается редко, и использование tryLock часто является признаком более глубокой проблемы при конкретном использовании мьютексов.

* **`TryRLock() bool`**: TryRLock пытается заблокировать rw для чтения и сообщает, удалось ли это сделать. Обратите внимание, что, хотя правильное использование TryRLock действительно существует, оно встречается редко, и использование TryRLock часто является признаком более глубокой проблемы при конкретном использовании мьютексов.

Пример:

```go
package main

import (
    "fmt"
    "sync"
)

type SafeCounter struct {
    mu    sync.RWMutex
    count int
}

func (c *SafeCounter) Increment() {
    c.mu.Lock()         // Захватываем эксклюзивную блокировку
    c.count++
    c.mu.Unlock()       // Освобождаем блокировку
}

func (c *SafeCounter) Value() int {
    c.mu.RLock()        // Захватываем блокировку для чтения
    defer c.mu.RUnlock() // Освобождаем блокировку
    return c.count
}

func main() {
    counter := SafeCounter{}

    var wg sync.WaitGroup

    // Запускаем 10 горутин для увеличения счетчика
    for i := 0; i < 10; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            counter.Increment()
        }()
    }

    // Запускаем 5 горутин для чтения значения счетчика
    for i := 0; i < 5; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            fmt.Println("Counter value:", counter.Value())
        }()
    }

    wg.Wait() // Ожидаем завершения всех горутин
    fmt.Println("Final counter value:", counter.Value())
}

```

Вывод может быть:

```bash
Counter value: 1
Counter value: 7
Counter value: 10
Counter value: 10
Counter value: 10
Final counter value: 10
```

## WaitGroup

WaitingGroup ожидает завершения набора горутин.
Основная горутина вызывает `WaitGroup.Add`, чтобы задать количество горутин, которых нужно дождаться. Затем каждая из горутин запускается и по завершении вызывает `WaitGroup.Done`. При этом метод `WaitGroup.Wait` можно использовать для блокировки до завершения всех горутин.
WaitingGroup нельзя копировать после первого использования.

Основные методы:

* **`Add(delta int)`** : Увеличивает счетчик ожидания на значение `delta`. Обычно используется для добавления количества горутин, которые вы собираетесь запустить. Если счётчик становится отрицательным, Add переходит в режим паники.
* **`Done()`**: Уменьшает счетчик ожидания на 1. Этот метод вызывается в горутине, когда она завершает свою работу.
* **`Wait()`**: Блокирует выполнение текущей горутины до тех пор, пока счетчик ожидания не станет равным нулю. Это означает, что все горутины, добавленные с помощью метода Add, завершили свою работу.

Пример:

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var wg sync.WaitGroup

	for i := 0; i < 5; i++ {
		wg.Add(1) // увеличиваем счетчик перед запуском каждой горутины
		go func(id int) {
			defer wg.Done() // уменьшаем счетчик по завершении работы горутины
			// выполняем задачу
			fmt.Printf("Goroutine %d завершена\n", id)
		}(i)
	}

	wg.Wait() // ожидаем завершения всех горутин

	fmt.Println("Все горутины завершены")
}
```

Вывод может быть:

```bash
Goroutine 4 завершена
Goroutine 1 завершена
Goroutine 0 завершена
Goroutine 2 завершена
Goroutine 3 завершена
Все горутины завершены
```

## Map

`sync.Map` — это потокобезопасная карта, которая позволяет нескольким горутинам одновременно читать и писать данные без дополнительных блокировок. Она оптимизирована для сценариев, где происходит много чтений и сравнительно мало записей.

Основные методы:

* **`Clear()`** - Очистка, удаляет все записи, в результате чего карта становится пустой
* **`Delete(key any)`** - удаляет элемент по ключу
* **`CompareAndDelete(key, old any) (deleted bool)`** - удаляет запись по key, если ее значение равно old. Старое значение должно быть сопоставимого типа. Если в карте нет текущего значения для key, CompareAndDelete возвращает значение false (даже если старое значение является нулевым значением интерфейса)
* **`CompareAndSwap(key, old, new any) (swapped bool)`** - меняет местами старое и новое значения для key, если значение, сохраненное на карте, равно old. Старое значение должно быть сопоставимого типа.
* **`Load(key any) (value any, ok bool)`** - возвращает значение, сохранённое в карте для ключа, или `nil`, если значение отсутствует. Результат `ok` указывает, найдено ли значение в карте.
* **`LoadAndDelete(key any) (value any, loaded bool)`** - удаляет значение ключа, возвращая предыдущее значение, если таковое имеется. В загруженном результате отображается информация о наличии ключа.
* **`LoadOrStore(key, value any) (actual any, loaded bool)`** - возвращает существующее значение для ключа, если оно присутствует. В противном случае сохраняет и возвращает заданное значение. Результат загрузки равен true, если значение было загружено, и false, если сохранено.
* **`Range(f func(key, value any) bool)`** - вызывает f последовательно для каждого ключа и значения, присутствующих в карте. Если f возвращает значение `false`, `range` останавливает итерацию. 
Диапазон не обязательно соответствует какому-либо согласованному снимку содержимого карты: ни один ключ не будет посещен более одного раза, но если значение для любого ключа сохраняется или удаляется одновременно (в том числе с помощью f), диапазон может отражать любое отображение для этого ключа из любой точки во время вызова диапазона. Range не блокирует другие методы; даже сам f может вызывать любой метод в map.
Диапазон может быть равен O(N) с учетом количества элементов в карте, даже если f возвращает значение `false` после постоянного количества вызовов.
* **`Store(key, value any)`** - используется для добавления или обновления элемента в карте. Он сохраняет значение по указанному ключу, создавая новую пару ключ-значение или заменяя существующее значение для этого ключа.
* **`Swap(key, value any) (previous any, loaded bool)`** - выполняет атомарную операцию — он заменяет значение по указанному ключу на новое и возвращает предыдущее значение, а также флаг, указывающий, существовал ли ранее такой ключ.


## Once

Cтруктура, предназначенная для обеспечения однократного выполнения определённой операции в многопоточной среде.

Основной метод:

* **`Do(f func())`** - используется для выполнения функции f только один раз за время жизни программы или пока объект Once не будет сброшен (если есть такая возможность). Он обеспечивает потокобезопасное выполнение функции, гарантируя, что она будет вызвана не более одного раза, даже если несколько горутин вызовут Do одновременно.

Пример:

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	var once sync.Once
	onceBody := func() {
		fmt.Println("Only once")
	}
	done := make(chan bool)
	for i := 0; i < 10; i++ {
		go func() {
			once.Do(onceBody)
			done <- true
		}()
	}
	for i := 0; i < 10; i++ {
		<-done
	}
}

---
Output:

Only once
```


## Pool

Структура которая предназначена для эффективного управления временными объектами и их повторного использования. Она помогает снизить нагрузку на сборщик мусора и повысить производительность за счет повторного использования объектов вместо их постоянного создания и уничтожения.

Основные методы:

* **`Get() any`** - предназначен для получения объекта из пула. Он возвращает один из ранее сохранённых объектов, если таковые есть, или создает новый объект, если пул пуст.
* **`Put(x any)`** - предназначен для возвращения объекта x в пул для последующего повторного использования. Он позволяет сохранять объекты, чтобы их можно было извлечь и использовать повторно, что помогает снизить нагрузку на систему выделения памяти и повысить эффективность работы программы.

Пример:

```go
var bufPool = sync.Pool{
    New: func() interface{} {
        return make([]byte, 1024)
    },
}

func process() {
    buf := bufPool.Get().([]byte) // получаем буфер из пула
    // используем буфер
    // ...
    bufPool.Put(buf) // возвращаем буфер в пул после использования
}
```

## Cond

Структура, предназначенная для реализации механизмов условной синхронизации между горутинами. Она позволяет горутинам ожидать определённого условия и уведомлять другие горутины о его выполнении.

Основные методы:

* **`NewCond(l Locker) *Cond`** - создает и возвращает новый указатель на структуру `Cond`, которая реализует механизм условной синхронизации.
* **`Broadcast()`** - используется для уведомления всех горутин, ожидающих на условной переменной `Cond`, о том, что условие выполнено или изменилось. После вызова `Broadcast()`, все горутины, ожидающие на `cond.Wait()`, просыпаются и продолжают выполнение.
* **`Signal()`** - используется для уведомления одной горутины, ожидающей на условной переменной `Cond`, о том, что условие выполнено или изменилось.
* **`Wait()`** - используется для приостановки выполнения текущей горутины до тех пор, пока не будет вызвано `Signal()` или `Broadcast()` на той же условной переменной Cond.

Пример:

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	var mu sync.Mutex
	cond := sync.NewCond(&mu) // создаем условную переменную, связанную с мьютексом
	ready := false

	// Горутина, которая ждет сигнала
	go func() {
		mu.Lock()
		for !ready {
			fmt.Println("Горутина ожидает сигнала...")
			cond.Wait() // ожидает, пока не получит сигнал
		}
		fmt.Println("Горутина пробуждена! Условие выполнено.")
		mu.Unlock()
	}()

	// Основная горутина "готовит" условие и посылает сигнал
	time.Sleep(2 * time.Second) // имитируем работу
	mu.Lock()
	ready = true
	fmt.Println("Основная горутина устанавливает условие и вызывает Signal()")
	cond.Signal() // разбудить одну ожидающую горутину
	mu.Unlock()

	// Еще одна горутина, которая тоже может ждать
	go func() {
		mu.Lock()
		for !ready {
			fmt.Println("Вторая горутина ожидает сигнала...")
			cond.Wait()
		}
		fmt.Println("Вторая горутина пробуждена!")
		mu.Unlock()
	}()

	// Ждем немного, чтобы все завершились
	time.Sleep(1 * time.Second)
}

```


## func OnceFunc(f func()) func()

Это функция, которая создает и возвращает функцию, гарантированно выполняющую переданную функцию f только один раз, независимо от того, сколько раз будет вызвана возвращаемая функция из разных горутин. Это удобный способ инициализировать что-то, что должно быть сделано только один раз, даже в параллельном окружении.

Пример:

```go
package main

import (
	"fmt"
	"sync"
)

var (
	initialized bool
	initFunc    func()
)

func initializeResource() {
	fmt.Println("Initializing resource...")
	// Здесь выполняется код инициализации.
	initialized = true
	fmt.Println("Resource initialized!")
}

func main() {
	// Создаем sync.OnceFunc
	initFunc = sync.OnceFunc(initializeResource)

	var wg sync.WaitGroup

	// Запускаем несколько горутин, которые пытаются инициализировать ресурс
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(id int) {
			defer wg.Done()
			fmt.Printf("Goroutine %d calling initFunc...\n", id)
			initFunc() // Вызываем onceFunc
			fmt.Printf("Goroutine %d finished calling initFunc\n", id)

			// Проверяем, что инициализация была выполнена (только один раз!)
			if initialized {
				fmt.Printf("Goroutine %d Resource is initialized!\n", id)
			} else {
				fmt.Printf("Goroutine %d Resource is NOT initialized!\n", id) // Этого не должно случиться
			}
		}(i)
	}

	wg.Wait()
	fmt.Println("Program finished.")
}
```

## func OnceValue[T any](f func() T) func() T

Это дженерик-функция, появившаяся в версии 1.18. Она очень похожа на `sync.OnceFunc`, но вместо выполнения func(), она выполняет func() T и возвращает результат этого выполнения, причём результат кэшируется и возвращается при последующих вызовах. Другими словами, она гарантирует, что функция f будет вызвана только один раз, и возвращает результат этого вызова при всех последующих вызовах.

Пример:

```go
package main

import (
	"fmt"
	"sync"
)

func main() {
	once := sync.OnceValue(func() int {
		sum := 0
		for i := 0; i < 1000; i++ {
			sum += i
		}
		fmt.Println("Computed once:", sum)
		return sum
	})
	done := make(chan bool)
	for i := 0; i < 10; i++ {
		go func() {
			const want = 499500
			got := once()
			if got != want {
				fmt.Println("want", want, "got", got)
			}
			done <- true
		}()
	}
	for i := 0; i < 10; i++ {
		<-done
	}
}

---
Output:

Computed once: 499500
```

## func OnceValues[T1, T2 any](f func() (T1, T2)) func() (T1, T2)

Это дженерик-функция, также представленная в версии 1.18. Она расширяет функциональность `sync.OnceValue` для случая, когда нужно возвращать два значения разных типов из однократно выполняемой функции.

Пример:

```go
package main

import (
	"fmt"
	"os"
	"sync"
)

func main() {
	once := sync.OnceValues(func() ([]byte, error) {
		fmt.Println("Reading file once")
		return os.ReadFile("example_test.go")
	})
	done := make(chan bool)
	for i := 0; i < 10; i++ {
		go func() {
			data, err := once()
			if err != nil {
				fmt.Println("error:", err)
			}
			_ = data // Ignore the data for this example
			done <- true
		}()
	}
	for i := 0; i < 10; i++ {
		<-done
	}
}

---
Output:

Reading file once
```
