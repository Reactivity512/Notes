# Go

## Основные типы (Basic types)

### Boolean

`bool` — принимает значения true или false.

### Numeric Types (числовые типы)

**Целочисленные (Integer types):**

*Signed (со знаком):*
* `int` (зависит от архитектуры: 32 или 64 бита)
* `int8` (8 бит, от -128 до 127)
* `int16` (16 бит, от -32 768 до 32 767)
* `int32` (32 бит, от -2 147 483 648 до 2 147 483 647)
* `int64` (64 бит, от -9 223 372 036 854 775 808 до 9 223 372 036 854 775 807)

*Unsigned (без знака):*
* `uint` (зависит от архитектуры)
* `uint8` (8 бит, от 0 до 255)
* `uint16` (16 бит, от 0 до 65 535)
* `uint32` (32 бит, от 0 до 4 294 967 295)
* `uint64` (64 бит, от 0 до 18 446 744 073 709 551 615)
* `uintptr` (используется для хранения указателей)

**Числа с плавающей точкой (Floating-point types)**

* `float32` (32 бит, ~6-7 знаков после запятой)
* `float64` (64 бит, ~15 знаков после запятой)

*Почему именно ~6-7 знаков у `float32`?*
`float32` — является стандартом IEEE 754. Он использует 23 бита для мантиссы, что определяет точность. В десятичной системе это примерно 6-7 цифр значащих.

Если число — не очень большое и не очень маленькое, то при выводе получим 7 знаков после запятой иначе меньше.
Пример:

```go
var small_value float32 = 2.1234567
fmt.Println(small_value) // 2.1234567

var value float32 = 22.7654321
fmt.Println(value) // 22.7654321

var large_value float32 = 3322.7654321
fmt.Println(value) // 3322.7654
```

**Комплексные числа (Complex types)**

* `complex64` (действительная и мнимая части — float32)
* `complex128` (действительная и мнимая части — float64)

### String (строковый тип)

`string` — строка в кодировке UTF-8.

### Byte и Rune (псевдонимы для работы с символами)

* `byte` — псевдоним для `uint8` (используется для бинарных данных).
* `rune` — псевдоним для `int32` (используется для Unicode-символов).

### Zero values

Переменным, объявленным без явного начального значения, присваивается "нулевое значение".

* int: 0
* float32: 0.0
* float64: 0.0
* bool: false
* string: "" (пустая строка)
* указатели: nil
* срезы: nil
* карты: nil
* структуры: все поля инициализируются нулевыми значениями для их типов

## Ключевые слова в Go 

В Go всего 25 ключевых слов.

### 1.Управление программой:

* **`break`** - используется для немедленного выхода из текущего цикла или оператора `switch`
* **`continue`** - используется внутри циклов (`for`) для пропуска текущей итерации и перехода к следующей итерации цикла.
* **`goto`** - используется для безусловного перехода к метке внутри функции. Оно позволяет перепрыгнуть к определённой точке в коде, помеченной меткой. (**в большинстве случаев использование `goto` не рекомендуется**)
* **`fallthrough`** - используется внутри конструкции `switch`. Оно позволяет "провалиться" (перейти) к следующему случаю (`case`) без необходимости явно писать его. `fallthrough` не проверяет условие следующего `case`, он просто продолжает выполнение.

```go
switch n := 2; n {
    case 1:
        fmt.Println("Один")
    case 2:
        fmt.Println("Два")
        fallthrough
    case 3:
        fmt.Println("Три")
    default:
        fmt.Println("Другое")
    }

// Вывод: Два Три
```

### 2.Условные конструкции и циклы:

* **`if`** - используется для условного выполнения кода
* **`else`** - используется вместе с оператором `if` для определения блока кода, который должен выполниться, если условие в `if` ложно (false). 
* **`switch`** - используется для реализации множественного ветвления — то есть, для выбора одного из нескольких вариантов выполнения кода в зависимости от значения выражения. По сравнению с другими языками имеет особенности. Особенности switch в Go: 
    * Автоматический "провал" (`fallthrough`): В Go по умолчанию выполнение не продолжается в следующий `case`, если явно не указать ключевое слово `fallthrough`.
    * Можно писать цепочки условий без выражения:
    ```go
    switch {
    case x > y:
        // код
    case x == y:
        // код
    default:
        // код
    }
    ```
    * В каждом `case` можно использовать несколько значений через запятые:
    ```go
    switch day {
    case "Пн", "Понедельник":
        // код
    }
    ```

* **`case`** - используется внутри конструкции `switch` для определения конкретных вариантов, при которых выполняется определённый блок кода. После выполнения блока, выполнение конструкции `switch` завершается (если не использовано `fallthrough`).
* **`default`** - используется внутри конструкции `switch` для определения блока кода, который выполняется, если ни один из перечисленных `case` не совпал с значением выражения.
* **`for`** - используется для организации циклов. Go `for` — единственная конструкция цикла, которая может выполнять разные типы повторений. Может работать как цикл с условием в начале, как цикл с пост-условием или как бесконечный цикл.
* **`range`** - используется внутри цикла `for` для итерации по различным коллекциям, таким как массивы, слайсы, карты, строки и каналы. Возвращает индекс и значение элемента при итерации.
*Внимание:*
    * при переборе строки `range` возвращает руны (`rune`), а не байты.
    * в случае с картами порядок перебора не гарантирован — он произвольный.

### 3.Объявление типов и структур:

* **`type`** - используется для определения новых типов данных или для создания псевдонимов существующих типов. Оно позволяет расширять возможности типизации.
* **`struct`** - используется для определения новых структурных типов данных — так называемых структур (структов). Структуры позволяют объединять несколько полей разного типа в один логический блок.
* **`interface`** - используется для определения интерфейсов — абстрактных типов, которые задают набор методов, реализуемых другими типами. Интерфейсы позволяют реализовать полиморфизм и обеспечивают гибкую архитектуру программ. Реализация не требует явного указания (`implements`), как в некоторых языках, это происходит автоматически.
* **`map`** - используется для объявления и работы с отображениями (ассоциативными массивами, словарями). map позволяет хранить пары ключ-значение и обеспечивает быстрый доступ к данным по ключу.
*Важные моменты:*
    * Если обратиться к несуществующему ключу, возвращается нулевое значение типа значения (например, 0 для int, "" для строк) и ok — false.
    * Карты в Go — ссылочные типы, при присваивании или передаче копируется ссылка.
    **Важно**: Перед тем, как добавлять элементы, нужно явно инициализировать карту с помощью `make()`, иначе попытка записать в `nil` карту вызовет ошибку времени выполнения.
      ```go
      var m map[string]int // m == nil
      m["ключ"] = 1       // ошибка: запись в nil карту
      ```

### 4.Управление памятью и указатели:

* **`new`** - используется для выделения памяти под переменную определенного типа и возвращения указателя на нее. Оно создает нулевое значение этого типа и возвращает его указатель.
**Отличие от `make`**
    * `new` выделяет память и возвращает указатель, но не инициализирует внутренние структуры (например, срезы, карты, каналы). Для таких типов используют `make`.
    * `make` создает и инициализирует внутренние структуры (например, срезы, карты), а `new` — только выделяет память под саму структуру.
* **`make`** - используется для выделения и инициализации встроенных типов данных, таких как срезы (`slice`), карты (`map`) и каналы (`chan`). В отличие от `new`, который выделяет память и возвращает указатель на нулевое значение, `make` создает и подготавливает внутренние структуры данных для использования. Обычно возвращает готовый к использованию экземпляр этого типа (значение, а не указатель).
```go
m := make(тип, размер, емкость)
```
Не используйте `make` для простых типов или структур — для них подходит `new`.

* **`chan`** - используется для объявления и работы с каналами — специальными типами данных, которые позволяют организовать безопасную передачу данных между горутинами (параллельными потоками выполнения).
Он обеспечивает синхронную или буферизированную передачу значений.
Каналы позволяют реализовать коммуникацию и синхронизацию без использования явных блокировок или мьютексов.
```go
ch := make(chan тип)
```
где `тип` — тип данных, которые будут передаваться через канал (например, `int`, `string`, структура и т.д.).

Основные операции с каналами:
| Операция | Описание | Пример |
|--|--|--|
| Создание | Создает канал с помощью `make` | `ch := make(chan int)` |
| Отправка значения | Передает значение в канал | `ch <- значение` |
| Получение значения | Извлекает значение из канала | `value := <-ch` |
| Закрытие канала | Указывает, что больше данных не будет передаваться | `close(ch)` |

### 5.Обработка ошибок:

* **`defer`** - используется для отложенного выполнения функции или вызова, который будет выполнен после завершения текущей функции, независимо от того, как она завершится (успешно или с ошибкой). Это особенно полезно для освобождения ресурсов, закрытия файлов, разблокировки мьютексов и других операций очистки.

Что делает `defer`:
1. Отложенный вызов функции откладывается до момента выхода из текущей функции.
2. Все вызовы defer в функции выполняются в обратном порядке (LIFO — last-in, first-out).
3. Обеспечивает выполнение необходимых операций очистки даже при возникновении ошибок или паник.

Пример:
```go
func example() {
    defer fmt.Println("Это выполнится в конце функции")
    fmt.Println("Это выполнится первым")
}
```


* **`panic`** - используется для немедленного завершения работы программы или текущей горутины в случае критической ошибки. Когда вызывается `panic`, выполнение текущей функции прерывается, и происходит распространение паники вверх по стеку вызовов, вызывая автоматическую распаковку стека и выполнение отложенных функций (`defer`). В конце программа завершает работу с выводом сообщения об ошибке.
*Когда использовать `panic`?*
    * В случаях, когда обнаружена критическая ошибка, исправить которую невозможно или нецелесообразно.
    * Для сигнализации о непредвиденных ситуациях, которые требуют немедленного завершения работы.
    * **Важно**: Обычно рекомендуется использовать `error` для обработки ошибок и избегать чрезмерного использования `panic`, так как это нарушает обычный поток выполнения программы.
* **`recover`** - используется для восстановления из паники (`panic`) внутри функции, которая была вызвана с помощью `defer`. Оно позволяет "поймать" паническую ситуацию и предотвратить завершение программы или горутины, а также выполнить необходимую обработку ошибок.

Пример:

```go
package main

import "fmt"

func main() {
    defer func() {
        if r := recover(); r != nil {
            fmt.Println("Поймали панику:", r)
        }
    }()

    panic("Критическая ошибка")
    fmt.Println("Это не будет выполнено")
}
```

*Что делает recover:*
    * `recover()` возвращает значение, переданное в `panic()`, если в текущей горутине произошла паника.
    * Если в текущем стеке вызовов не было паники, `recover()` возвращает nil.


### 6.Импорт и видимость:

* **`package`** - используется для объявления имени пакета, к которому принадлежит исходный файл. Оно указывается в начале каждого файла и определяет, к какому логическому модулю или группе функций, типов и переменных принадлежит данный файл.
Значение `package` для видимости:
     * Экспортируемые элементы (функции, переменные, типы) начинаются с заглавной буквы и доступны за пределами пакета.
     * Неэкспортируемые — начинаются с маленькой буквы и доступны только внутри этого пакета.

* **`import`** - используется для включения внешних пакетов или модулей в текущий файл, чтобы иметь возможность использовать их функции, типы, переменные и константы.

Пакеты (`packages`):
* Пакет — это набор связанных исходных файлов, объединённых в одну логическую единицу, которые находятся в одной директории.
* Пакеты позволяют организовать код по функциональным модулам, чтобы его было легче использовать и поддерживать.
* Каждый файл внутри пакета начинается с объявления `package` имя_пакета.
* Имя пакета — это название директории или явно указанное в файле.
* Экспортируемые элементы (функции, переменные, типы) начинаются с заглавной буквы.
* Для использования элементов другого пакета нужно импортировать его через `import`.

Модули (`modules`):
* Модуль — это более крупная единица организации кода, которая включает в себя один или несколько пакетов.
* Модуль управляется системой модулей Go (`go.mod`), которая определяет зависимости, версии и конфигурацию проекта.
* Модули позволяют управлять версиями внешних библиотек и обеспечивают воспроизводимость сборки.

Пакеты — это способ структурировать код внутри проекта.
Модули — это единицы управления проектом и его зависимостями, включающие один или несколько пакетов.

### 7.Прочие:

* **`func`** - используется для объявления функции.
* **`var`** - используется для объявления переменной.
* **`const`** - используется для объявления константы.
* **`return`** - используется для завершения выполнения функции и возврата значения(ий) из неё.

## Collection (коллекции)

### Slice

Slice (срез) — это гибкая, динамическая структура данных, которая представляет собой обертку над массивом и позволяет работать с последовательностью элементов без необходимости заранее задавать её длину.

Тип среза: Ссылочный тип (reference type)

**Особенности:**
* Это обёртка над массивом с изменяемой длиной.
* Имеет указатель на массив, длину (`len`) и ёмкость (`cap`).
* Создаётся через `make([]T, len, cap)` или литерал `[]T{...}`.
* Изменение элементов внутри среза влияет на исходный массив (если он есть).
* Если два слайса ссылаются на один массив, изменение одного повлияет на другой.
* `append` может изменить базовый массив:
    * Если `cap` позволяет, `append` просто добавляет элемент.
    * Если `cap` недостаточен, создаётся новый массив (обычно с удвоенной ёмкостью).
```go
a := []int{1, 2, 3, 4}
b := a[:2]       // b = [1, 2], cap = 4 (ещё есть место)
b = append(b, 5) // перезаписывает a[2]!

fmt.Println(a) // [1, 2, 5, 4] – `a` изменился!
fmt.Println(b) // [1, 2, 5]
```
Если нужно гарантированно избежать перезаписи, используйте `copy` или `append` с новым слайсом:

```go
b := append([]int{}, a[:2]...) // полная копия
b = append(b, 5)               // `a` не изменится
```
* Слайсы и nil:
    * Нулевой слайс (`var s []int`) — nil, но его можно использовать с append.
    * Пустой слайс (`s := []int{}`) — не nil, но длина 0.

Лучшая практика: Возвращайте `nil` вместо пустого слайса в функциях (экономит память).

* Утечки памяти из-за слайсов.
Если слайс ссылается на большой массив, но используется только маленькая часть, GC не очистит неиспользуемую память.

```go
func getLastElement() []byte {
    data := readData() // 1 ГБ данных
    return data[len(data)-10:] // возвращаем 10 байт, но весь массив остаётся в памяти
}

// Необходимо явно копировать нужные данные:
func getLastElement() []byte {
    data := readData() // 1 ГБ данных
    result := make([]byte, 10)
    copy(result, data[len(data)-10:])
    return result
}
```

* Слайсы нельзя сравнивать через == (кроме `nil`). Для сравнения нужно использовать `reflect.DeepEqual` или ручной перебор.

* Предварительное выделение памяти (`make` с `cap`):
```go
slice := make([]int, 0, 100) // сразу резервируем место под 100 элементов
```

* Избегание лишних копий (s[low:high:max] — "полный срез"):
```go
a := []int{1, 2, 3, 4, 5}
b := a[1:3:3] // b = [2, 3], cap = 2 (теперь append создаст новый массив)
```

**Ключевые моменты:**

1. Слайс — это указатель на массив + длина + ёмкость.
2. Несколько слайсов могут делиться одним массивом → изменения в одном влияют на другие.
3. `append` может изменить базовый массив, если есть место (`cap`).
4. Используйте `copy`, если нужно избежать перезаписи.
5. `nil`-слайс и пустой слайс — разные вещи.
6. Большие слайсы могут приводить к утечкам памяти.
7. Слайсы нельзя сравнивать напрямую.

### Map

Map (`map[K]V`) — ассоциативный массив (хэш-таблица)

Тип: Ссылочный тип (reference type)

* Хранит пары ключ-значение.
* Ключи должны быть сравниваемыми (например, `int`, `string`, `array`, `struct`, но не `slice`, `func` или `map`).
* Создаётся через `make(map[K]V)` или литерал `map[K]V{...}`
* При присваивании копируется только ссылка, а данные остаются общими.
* nil-map (`var m map[K]V`) — нельзя использовать для записи (вызовет `panic`).
* Пустая map (`m := make(map[K]V`)) — готова к работе.

```go
// Объявление нулевой карты (не инициализирована, nil-map)
var m map[string]int
m["key"] = 1  // panic: assignment to nil map

// Создание карты с помощью make
m := make(map[string]int)
m["key"] = 1  // работает

// Создание карты с литералом
m := map[string]int{"foo": 1, "bar": 2}
m["key"] = 1  // работает
```

**Лучшая практика: Всегда инициализировать через make() или литерал {}.**

* При обращении по ключу возвращается нулевое значение типа, если ключа нет. Чтобы отличить отсутствие ключа от нулевого значения, используйте второе возвращаемое значение:

```go 
value, ok := m["unknown_key"]
if !ok {
    fmt.Println("Ключ не найден")
}
```

* `Map` не гарантирует порядок итерации. При обходе `range` порядок ключей случаен (из-за хэширования).

Если нужно получить ключи в отсортированном порядке, нужно использовать отдельный слайс для сортировки:

```go
keys := make([]string, 0, len(m))
for k := range m {
    keys = append(keys, k)
}
sort.Strings(keys)
for _, k := range keys {
    fmt.Println(k, m[k])
}
```

* `Map` не потокобезопасна. При конкурентном доступе из нескольких горутин возможны гонки данных (data races). Что приводит к панике или повреждению данных. Для конкурентного доступа нужно использовать `sync.Mutex` или `sync.RWMutex`.
* При удалении элементов (`delete`) память не всегда освобождается сразу. `Map` может сохранять внутренние структуры для оптимизации. Если `map` больше не нужна — присвоить `nil` или создать новую.
* При `delete(m, "key")` если ключа нет — ничего не произойдет.
* Если значение `map` — другая `map`, её тоже нужно инициализировать
* `Map` динамически расширяется при добавлении элементов.

**Главные правила работы с `map`:**
1. Всегда инициализируйте `map` (избегайте `nil`).
2. Проверяйте наличие ключа через `value, ok := m[key]`.
3. Порядок итерации не фиксирован.
4. Для конкурентного доступа используйте `Mutex` или `sync.Map`.
5. Ключи должны быть сравниваемыми (`slice` и `map` — нельзя).
6. Удаляйте данные правильно (при больших объемах лучше пересоздать `map`).
7. Заранее выделяйте размер (`make(map[K]V, cap)`), если известно количество элементов.

#### Как динамически расширяется map в Go

Внутри `map` в Go реализована как хэш-таблица, которая автоматически увеличивается при добавлении элементов, чтобы поддерживать эффективность операций (O(1) в среднем).

1. Начальное состояние
При создании `map` через make(`map[K]V`) выделяется небольшой начальный объем памяти (по умолчанию создается 8 "корзин" — buckets).
Каждая корзина содержит несколько пар ключ-значение.

2. Механизм расширения (Grow)
Когда `map` заполняется, происходит рехеширование (`rehashing`):
    * Проверка коэффициента загрузки (`load factor`):
    * Если число элементов превышает `6.5 * число корзин` (значение может меняться), map увеличивается в 2 раза.
    * Создание новых корзин (`buckets`):
    * Перераспределение элементов (эвакуация):
    * Все существующие элементы пересчитываются через хэш-функцию и распределяются по новым корзинам.

3. Эвакуация — это процесс переноса элементов из старых корзин в новые при расширении `map`.
Как это работает?
    * Постепенная эвакуация (incremental resizing):
        * Go не переносит все элементы сразу, а делает это постепенно при последующих операциях вставки/удаления.
        * Это уменьшает задержки при больших `map`.
    * Две группы корзин:
        * Во время эвакуации `map` хранит старые и новые корзины.
        * При обращении к элементу сначала проверяется новая `map`, если не найдено — ищется в старой.
    * Завершение эвакуации:
        * Когда все элементы перенесены, старые корзины удаляются сборщиком мусора (GC).  


### chan

Каналы (`chan`) — это мощный механизм для обмена данными между горутинами и синхронизации.
Тип: Ссылочный тип (reference type)

1. Может быть буферизированным (`make(chan T, size)`) или небуферизированным (`make(chan T)`).
    * Небуферизированные каналы (unbuffered)
    Создаются без указания ёмкости: `ch := make(chan int)`. Блокируют отправку (`ch <-`) и получение (`<-ch`) до тех пор, пока другая сторона не будет готова

    * Буферизированные каналы (buffered)
    Создаются с указанием ёмкости: `ch := make(chan int, 3)`. Отправка блокируется только при заполнении буфера, а получение — при пустом канале.

* Закрытие каналов (`close`)
    Закрытый канал (`close(ch)`) больше не принимает данные (при отправке — `panic`).
    Приём данных из закрытого канала:
    * Если есть данные — они читаются.    
    * Если данных нет — возвращается нулевое значение типа (0, nil, false и т. д.).
    * Проверка на закрытие:
    ```go
    v, ok := <-ch  // ok == false, если канал закрыт
    ```

* `range` по каналу
    * Цикл `for v := range ch` автоматически завершается при закрытии канала.
    * Если канал не закрыть — deadlock (горутина зависнет).

* `select` — мультиплексирование каналов
    * Позволяет ожидать операции на нескольких каналах.
    * Порядок выполнения `case` случайный (если несколько каналов готовы).
    * `default` — неблокирующая проверка (если ни один канал не готов).
    Пример:
    ```go
    ch1 := make(chan int)
    ch2 := make(chan int)

    go func() { ch1 <- 1 }()
    go func() { ch2 <- 2 }()

    select {
    case v := <-ch1:
        fmt.Println("ch1:", v)
    case v := <-ch2:
        fmt.Println("ch2:", v)
    default:
        fmt.Println("Ничего не готово")
    }
    ```
* Особенности работы с `nil`-каналами
    * Отправка/получение в `nil`-канал блокирует горутину навсегда (`deadlock`).
    * Закрытие `nil`-канала вызывает `panic`.
    ```go
    var ch chan int // nil-канал

    go func() {
        ch <- 1     // Блокировка навсегда!
    }()

    <-ch           // Тоже блокировка
    close(ch)      // panic: close of nil channel
    ```
* Если горутина ожидает данные из канала, но он никогда не закрывается — это утечка ресурсов.
```go
ch := make(chan int)
go func() {
    for {
        v := <-ch  // Вечное ожидание
        fmt.Println(v)
    }
}()
// ch никогда не закрывается → горутина "висит" в памяти
```
Решение: Использовать `context` или сигнальный канал для завершения:

```go
package main

import (
    "context"
    "fmt"
    "time"
)

func worker(ctx context.Context) {
    for {
        select {
        case <-ctx.Done():
            fmt.Println("Завершение работы по контексту:", ctx.Err())
            return
        default:
            // Выполняем работу
            fmt.Println("Работаю...")
            time.Sleep(500 * time.Millisecond)
        }
    }
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 2*time.Second)
    defer cancel()

    go worker(ctx)

    // Ждем завершения
    time.Sleep(3 * time.Second)
    fmt.Println("Главная программа завершена")
}

// Создаем context с таймаутом.
// В горутине вызываем select, чтобы слушать ctx.Done().
// Когда таймаут истекает или вызывается cancel(), горутина завершится.
```

```go
package main

import (
    "fmt"
    "time"
)

func worker(stop chan struct{}) {
    for {
        select {
        case <-stop:
            fmt.Println("Получен сигнал завершения")
            return
        default:
            // Выполняем работу
            fmt.Println("Работаю...")
            time.Sleep(500 * time.Millisecond)
        }
    }
}

func main() {
    stop := make(chan struct{})

    go worker(stop)

    // Через некоторое время посылаем сигнал завершения
    time.Sleep(2 * time.Second)
    close(stop) // закрываем канал, чтобы сигнализировать о завершении

    // Ждем немного, чтобы горутина завершилась
    time.Sleep(1 * time.Second)
    fmt.Println("Главная программа завершена")
}

// Создаем канал stop.
// В горутине слушаем его через <-stop.
// В основном потоке через некоторое время закрываем канал (close(stop)), что вызывает завершение.
```

* Сигнальный канал (`chan struct{}`)
    * Используется для уведомлений (минимизирует память, так как `struct{}` весит 0 байт):

* Ограничение скорости (`rate-limiting`)
```go
ticker := time.NewTicker(100 * time.Millisecond)
for {
    <-ticker.C // Не чаще 10 раз в секунду
    fmt.Println("Tick")
}
```

* Каналы и сборщик мусора (GC)
    * Закрытые каналы могут быть собраны GC, даже если в них остались данные (если на них нет ссылок).
    * Небуферизированные каналы не хранят данные — они лишь синхронизируют горутины.


### Interface

Интерфейс — это набор методов, который определяет поведение типа. Если тип реализует все методы интерфейса, он автоматически удовлетворяет этому интерфейсу (утиная типизация).

```go
type Speaker interface {
    Speak() string
}

type Dog struct{}
func (d Dog) Speak() string { return "Woof!" }

var s Speaker = Dog{}
fmt.Println(s.Speak()) // "Woof!"
```

В Go есть два вида интерфейсов:

* Интерфейсы без методов (например, `interface{}`) — "пустой" интерфейс, который может хранить любое значение.
* Интерфейсы с методами — для полиморфизма.

Интерфейс в Go — это структура из двух частей:
* Тип (type info) — метаданные о реальном типе хранимого значения.
* Значение (data pointer) — указатель на фактическое значение.

Это реализовано через внутреннюю структуру так:

```go
type iface struct {
    tab  *itab          // Таблица методов и информации о типе
    data unsafe.Pointer  // Указатель на конкретное значение
}
```

`itab` (interface table) - содержит:
* Указатель на `_type` (информация о конкретном типе)
* Массив функций (fun), указывающих на методы конкретного типа
* Другие метаданные (флаги, хэш типа и т.д.)

Для пустого интерфейса (interface{}/any) используется немного другая структура:

```go
type eface struct {
    _type *_type         // Информация о типе
    data  unsafe.Pointer // Указатель на значение
}
```

`_type` - описывает базовые характеристики типа:
* Размер
* Выравнивание
* Хэш
* Флаги
* Методы (но не для интерфейсов)

`data` - указатель на фактическое значение в памяти

Пример:

```go
var s Stringer = &Book{Title: "Golang"}
```

Будет представлено как:

```go
iface {
    tab: &itab{
        _type: *Book_type,
        fun:   [Book.String, ...],
    },
    data: 0x12345678,  // Адрес Book{Title: "Golang"}
}
```

Когда вы присваиваете значение переменной интерфейса, внутри происходит:
* Определение реального типа значения.
* Хранение этого типа и указателя на значение.

*Динамическое значение* — фактическое значение, которое хранится внутри интерфейса. Может быть любого типа.
*Динамический тип* — информация о конкретном типе этого значения (например, `int`, `string`, структура).

Пример:

```go
var i interface{} = 42 // Тип: int, Значение: 42

i = "hello" // Тип: string, Значение: "hello"
```

Чтобы получить информацию о динамическом типе и значении во время выполнения, используют пакет `reflect`:

```go
import "reflect"

var i interface{} = 123

t := reflect.TypeOf(i)     // возвращает тип: int
v := reflect.ValueOf(i)    // возвращает значение: 123

fmt.Println("Type:", t)
fmt.Println("Value:", v)
```

**Type Assertion и Type Switch**

Type Assertion - Проверяет, содержит ли интерфейс конкретный тип:

```go
var s Speaker = Dog{}
dog, ok := s.(Dog)  // ok = true
cat, ok := s.(Cat)   // ok = false
```

```go
dog := s.(Dog)  // OK
cat := s.(Cat)  // panic!
```

Type Switch - Позволяет проверить несколько типов:

```go
switch v := s.(type) {
case Dog:
    fmt.Println("Это собака:", v.Speak())
case Cat:
    fmt.Println("Это кот:", v.Speak())
default:
    fmt.Println("Неизвестный тип")
}
```

Если метод определён для указателя на тип, то интерфейсу удовлетворяет только указатель:

```go
type Counter struct{ count int }
func (c *Counter) Increment() { c.count++ }

var c Counter
var i interface{} = c  // Ошибка! Counter не реализует интерфейс.
var i interface{} = &c // OK
```

Интерфейсы можно сравнивать (==), но:
* Если динамический тип несравним (например, `slice`), будет `panic`.
* Два интерфейса равны, если:
    * Оба `nil`, или
    * Их динамические типы идентичны, и значения равны.

Интерфейсы можно встраивать в другие интерфейсы:

```go
type Reader interface { Read() }
type Writer interface { Write() }
type ReadWriter interface {
    Reader
    Writer
}
```

Интерфейсы и производительность:
* Интерфейсы добавляют небольшой оверхед (динамическая диспетчеризация методов).
* Если критична скорость, иногда лучше использовать конкретные типы.

**Полезные паттерны:**

Dependency Injection:

```go
type Logger interface { Log(msg string) }
func NewService(logger Logger) *Service {
    return &Service{logger}
}
```

Mocking в тестах:

```go
type DB interface { Get(id int) string }
type MockDB struct{}
func (m MockDB) Get(id int) string { return "test" }

func TestUser(t *testing.T) {
    user := User{db: MockDB{}}
    // Тестируем...
}
```

Декораторы:

```go
type Client interface { Do() }
type LoggingClient struct { client Client }
func (l LoggingClient) Do() {
    fmt.Println("Запрос начат")
    l.client.Do()
}
```

## Pointers

Указатели — это переменные, хранящие адрес памяти другой переменной.

### 1.Объявление и инициализация
```go
var x int = 10
var p *int = &x  // p хранит адрес x

fmt.Println(p)   // 0x1400001c210 (адрес)
fmt.Println(*p)  // 10 (разыменование)
```

```
& — оператор взятия адреса.
* — оператор разыменования (получения значения по адресу).
```

### 2.Нулевое значение указателя

* Указатель без присвоенного адреса равен `nil`.
* Попытка разыменовать `nil`-указатель вызывает `panic`:

```go
var p *int
fmt.Println(*p) // panic: runtime error
```

### 3.Передача по значению vs по указателю

По значению (копирование):

```go
func modify(val int) {
    val = 20
}
x := 10
modify(x)
fmt.Println(x) // 10 (не изменилось)
```

По указателю (изменение оригинала):

```go
func modify(ptr *int) {
    *ptr = 20
}
x := 10
modify(&x)
fmt.Println(x) // 20
```

### 4.Возврат указателя из функции

Можно возвращать указатель на локальную переменную — Go переместит её в кучу (escape analysis):

```go
func create() *int {
    x := 42
    return &x // Безопасно (компилятор оптимизирует)
}
```

> Escape analysis — это процесс, который выполняется компилятором или инструментами во время компиляции или выполнения программы, чтобы определить, какие переменные или объекты "эскейпят" за пределы своей области видимости (например, функции) и где их нужно размещать — на стеке или в куче.

### 5.Изменение полей структуры

```go
type User struct {
    Name string
    Age  int
}

func (u *User) UpdateAge(age int) {
    u.Age = age // Работает с оригиналом
}

user := User{"Alice", 25}
user.UpdateAge(30)
fmt.Println(user.Age) // 30
```

Рекомендуется передавать структуры по указателю, если:
* Структура большая (избегаем копирования).
* Нужно изменить её поля.

### 6.Указатели и слайсы/мапы

Слайсы и мапы уже содержат указатели на данные, поэтому их часто передают по значению:

```go
func updateSlice(s []int) {
    s[0] = 100 // Изменяет оригинальный слайс
}
```

Но если нужно изменить сам слайс (например, сделать append), требуется указатель:

```go
func appendSlice(s *[]int, val int) {
    *s = append(*s, val)
}
```

### 7.Указатели и интерфейсы

Если метод определён для `*T`, то интерфейс реализует только `*T`, а не `T`:

```go
type Speaker interface { Speak() }

type Dog struct{}
func (d *Dog) Speak() {} // Метод для *Dog

var s Speaker = Dog{}    // Ошибка!
var s Speaker = &Dog{}   // OK
```


## Cборщик мусора (GC)

### Основные принципы
* *Трассировка достижимости (Mark & Sweep)*
GC помечает все объекты, которые можно достичь из "корней" (глобальные переменные, стек вызовов, регистры CPU), а затем удаляет недостижимые.
* *Параллельный и неблокирующий*
Современные версии Go (с 1.8+) выполняют GC параллельно с основной программой, минимизируя "остановки мира" (STW — Stop-The-World).

### Фазы работы
* Mark (Пометка)
GC сканирует активные объекты, начиная с корневых указателей (корни — это глобальные переменные, локальные переменные в стеке горутин и т. д.).
Использует триколорную маркировку (black/grey/white) для оптимизации.
* Sweep (Очистка)
Память, занятая непомеченными (белыми) объектами, освобождается.
Возвращается в пул для повторного использования.
* Сжатие (не всегда)
В некоторых случаях GC может перемещать объекты, чтобы уменьшить фрагментацию.

### Маркировка

* **Черный (Black)** — объект обработан, все его дочерние элементы проверены.
* **Серый (Grey)** — объект помечен, но его дочерние элементы ещё не проверены.
* **Белый (White)** — объект не помечен (кандидат на удаление).

### Write Barrier (Барьер записи)

Если программа изменяет указатель во время фазы Mark, GC использует барьер записи, чтобы сохранить целостность графа объектов.

```go
a.field = b // Если a уже "чёрный", а b — "белый", барьер помечает b как "серый".
```

### Поколения (Generational GC — нет в Go)

В отличие от Java/.NET, Go не использует Generational GC (разделение на молодые/старые объекты). Причина:
Go оптимизирован под низкие задержки (low-latency), а Generational GC добавляет overhead.
В Go большинство объектов живут недолго (как в стеке), поэтому нет смысла делить их на поколения.


### Настройка и производительность

Переменные окружения для настройки GC

| Переменная | Описание |
|--|--|
| `GOGC` | Процент роста кучи перед запуском GC (по умолчанию 100 = 100%) |
| `GODEBUG=gctrace=1` | Вывод логов GC в консоль (полезно для отладки) |
| `GOMEMLIMIT` (с Go 1.19) | Ограничение памяти, после которого GC работает агрессивнее |

Пример:

```bash
GOGC=50 ./myapp  # GC запустится при росте кучи на 50% от текущего размера
```

### Как уменьшить влияние GC на производительность?

1. Уменьшение количества аллокаций в куче
    * Используйте `sync.Pool` для переиспользуемых объектов.
    * Предпочитайте стек (локальные переменные) куче (указатели, `new`, `make`).
2. Контроль за `GOGC`
    * Уменьшение `GOGC` делает GC более агрессивным (меньше лаг, но ниже производительность).
    * Увеличение `GOGC` уменьшает частоту GC (но может привести к высокому потреблению памяти).
3. Избегание утечек памяти
    * Глобальные переменные, незакрытые каналы, "зависшие" горутины могут удерживать память.

### Отслеживание работы GC

Логирование (`GODEBUG=gctrace=1`)

```bash
GODEBUG=gctrace=1 ./myapp
```

Вывод:

```bash
gc 1 @0.012s 2%: 0.026+0.38+0.044 ms clock, 0.21+0.22/0.36/0.060+0.35 ms cpu, 4->4->0 MB, 5 MB goal, 8 P
```

Где:
* gc 1 — номер сборки.
* @0.012s — время с начала работы программы.
* 2% — процент времени CPU, потраченного на GC.
* 4->4->0 MB — размер кучи до/после/живых объектов.

Можно "заморозить" GC, установив `GOGC=off` (не рекомендуется).

### Профилирование (`pprof`)

```go
import _ "net/http/pprof"
go func() { log.Println(http.ListenAndServe(":6060", nil)) }()
```

```bash
go tool pprof -http=:8080 http://localhost:6060/debug/pprof/heap
```


### Сравнение GC в Go и других языках

| Характеристика | Go | Java (JVM) | C# (.NET) |
|--|--|--|--|
|Алгоритм | Concurrent Mark & Sweep | Generational + G1/ZGC | Generational + Mark-Compact |
|STW (остановки) | Краткие (~миллисекунды) | Зависит от сборщика | Обычно короткие |
|Настройка | `GOGC`, `GOMEMLIMIT` | `-Xmx`, `-XX:UseZGC` | `GCHeapCount`, `GCServer` |
|Оптимизация | Для low-latency | Для throughput | Баланс latency/throughput |
