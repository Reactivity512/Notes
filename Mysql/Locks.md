# Блокировки в MySQL (Locks in MySQL)

Блокировки в MySQL — это механизмы контроля доступа к данным, которые предотвращают конфликты при одновременной работе нескольких транзакций.
**Blocking** (Блокирование)  — ситуация, когда одна транзакция удерживает блокировку, а другая ждет ее освобождения, это может замедлять работу СУБД.

Движок базы данных (Storage Engine) — это компонент СУБД, который отвечает за:
* Хранение данных на диске/в памяти
* Чтение и запись информации
* Поддержку транзакций (если есть)
* Реализацию блокировок
* Индексацию и оптимизацию запросов

По движкам:
* **InnoDB** — лучший выбор для большинства случаев (поддержка транзакций, row-level locking).
* **MyISAM** — устарел, подходит только для read-only нагрузок (не поддерживает блокировки уровня строки (Row-Level Locking)).
* **MEMORY** — для временных данных в RAM (не поддерживает блокировки уровня строки (Row-Level Locking)).
* **NDB** — для распределенных кластерных систем.


## Типы блокировок:

### 1. Database-Level Locking (Блокировка на уровне базы данных)

Блокируется вся база данных (все таблицы). Используется в основном для операций администрирования, создании бэкапов или миграции.

```
-- Глобальная блокировка БД на чтение
FLUSH TABLES WITH READ LOCK;

-- Разблокировка
UNLOCK TABLES;
```

### 2. Table-Level Locking (Блокировка на уровне таблицы)

Блокирует всю таблицу. Хорошо подходят для операций над всей таблицей. Реализация проще и работает быстрее, чем **row-level** (на небольших нагрузках).
**Недостатки**: Плохая масштабируемость - Если много пользователей, они будут ждать освобождения блокировки.

**Table-Level Locking (Блокировка на уровне таблицы)** в основном используется для:
Резервного копирование. Когда нужен "снимок" таблицы.
Импорт/экспорт больших данных. Для обеспечения целостности во время записи/чтения.
Очистка или агрегирование. Когда нужно чтобы таблица обрабатывалась целиком.
Когда нужны редкие изменения для всей таблицы
```
-- Явная блокировка таблицы на чтение (другие могут читать, но не писать)
LOCK TABLES users READ;
-- Явная блокировка таблицы на запись (полная эксклюзивная блокировка)
LOCK TABLES users WRITE;

-- Разблокировка
UNLOCK TABLES;
```

### 3. Row-Level Locking (Блокировка уровня строки)

Блокируются только те строки, которые участвуют в операции, а не вся таблица. Это ключевая особенность движка **InnoDB** и **NDB**, которая позволяет эффективно работать с многопользовательским доступом и параллелизмом.

**Преимущества:**
* Высокий параллелизм (много пользователей могут работать с разными строками).
* Минимальные конфликты

**Недостатки:**
* Большие накладные расходы (память для хранения информации о блокировках)
* Риск взаимоблокировок (deadlocks)

**Типы блокировок:** 
* Эксклюзивные или **Exclusive Lock (X) FOR UPDATE, DELETE, INSERT** — запрещают любое чтение/запись другими транзакциями.
* Разделяемые или **Shared Lock (S) FOR SHARE** — разрешают чтение, но запрещают изменение.

Примеры **Exclusive Lock (X)**:
```
    UPDATE accounts SET balance = balance - 100 WHERE id = 1;
```
СУБД накладывает **Exclusive Lock** на строку *id = 1*, чтобы предотвратить другие изменения до окончания транзакции.

```
    DELETE FROM users WHERE id = 10;
```
Строка блокируется эксклюзивно — нельзя ни прочитать её через **FOR UPDATE**, ни изменить.

```
    INSERT INTO orders (id, amount) VALUES (1, 500);
```
Здесь блокировка X применяется к новой строке, а также, возможно, к **уникальным индексам**, чтобы не допустить конфликтов.
```
    SELECT * FROM users WHERE id = 5 FOR UPDATE;
```
Блокировка X применяется к строке, хотя данные ещё не изменяются. Это делается в преддверии **UPDATE** или **DELETE** в той же транзакции.

При **X-lock** никакие другие блокировки не разрешаются.
```
-- Транзакция 1
BEGIN;
UPDATE accounts SET balance = balance - 50 WHERE id = 100;

-- Транзакция 2 (параллельно)
BEGIN;
DELETE FROM accounts WHERE id = 100;  -- Блокировка! Ждёт окончания T1
```

Основное поведение **Shared Lock (S):**
* Позволяет многим транзакциям читать одну и ту же строку.
* Запрещает изменения этой строки (через **UPDATE**, **DELETE**) другим транзакциям.
* Используется для защиты от грязного чтения (dirty read).

Примеры **Shared Lock (S):**
```
SELECT * FROM products WHERE id = 10 FOR SHARE;
```
Пока идет чтение строки *id = 10* никто не может её изменить.

```
-- Транзакция 1
BEGIN;
SELECT * FROM orders WHERE id = 101 FOR SHARE;

-- Транзакция 2 (параллельно)
UPDATE orders SET status = 'shipped' WHERE id = 101;
-- Ждёт завершения T1, т.к. строка заблокирована Shared Lock
```

**Shared Lock** не предотвращает других чтений.

---
Посмотреть текущие блокировки:
```
    SHOW ENGINE INNODB STATUS;
```
Или использовать информацию из системных таблиц:
```
    SELECT * FROM information_schema.innodb_locks;
```

### Deadlock (Взаимоблокировка) 
**Deadlock** возникает, когда две или более транзакции блокируют ресурсы в разном порядке, создавая цикл ожидания. MySQL автоматически обнаруживает deadlocks и отменяет одну из транзакций (с ошибкой 1213 - Deadlock found).
* InnoDB отслеживает блокировки всех транзакций.
* Если обнаруживается цикл (взаимная блокировка) — запускается алгоритм обнаружения дедлоков.
* InnoDB автоматически завершает одну из транзакций (обычно наименьшую по "стоимости").
* Завершившаяся транзакция получает ошибку:
`ERROR 1213 (40001): Deadlock found when trying to get lock; try restarting transaction`

**Пример дедлока:**

```
-- Транзакция 1
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
-- Далее, в этой же транзакции:
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

-- Транзакция 2 (одновременно)
BEGIN;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
-- Далее:
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
```

Обе транзакции ждут друг друга. InnoDB обнаружит дедлок и завершит одну из них.

**Deadlock** — опасная ситуация, которую MySQL обнаруживает и разрешает сам.
**Blocking** — нормальное явление, но его нужно минимизировать.

**Как избежать Deadlock:**
1. **Строго соблюдать порядок доступа к ресурсам.** Всегда обращайся к таблицам/строкам в одном и том же порядке во всех транзакциях. Если одна транзакция сначала обновляет account_1, а потом account_2, то все другие транзакции должны делать то же самое. (например, сначала id=1, потом id=2). Непоследовательный порядок — самая частая причина дедлоков.
2. **Минимизируйте продолжительность транзакций.** Чем короче транзакция, тем меньше вероятность, что другая успеет вступить в конфликт. Не держите транзакцию "открытой" без необходимости.
3. **Блокируй как можно меньше строк.** Используй индексы, чтобы `UPDATE/DELETE/SELECT FOR UPDATE` не сканировали много строк. Избегай широких условий типа `WHERE status = 'active'`
4. **Обновляй данные по ключам.**
```
-- Плохо
UPDATE orders SET status = 'done' WHERE created_at < NOW() - INTERVAL 1 DAY;

-- Хорошо
UPDATE orders SET status = 'done' WHERE id IN (SELECT id FROM orders WHERE created_at < NOW() - INTERVAL 1 DAY L);
```
