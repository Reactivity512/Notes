# 100 ошибок Go и как их избежать

В книге представлены семь основных категорий ошибок, которые можно классифицировать как:
* баги;
* излишнюю сложность;
* плохую читаемость;
* неоптимальную или неидиоматическую организацию;
* отсутствие удобства в API;
* неоптимизированный код;
* недостаточную производительность.

# Организация кода и проекта

## ОШИБКА #1: НЕПРЕДНАМЕРЕННО ЗАТЕНЯТЬ ПЕРЕМЕННЫЕ

Область видимости переменной — это те места кода, в которых можно ссылаться на эту переменную, другими словами, та часть приложения, где действует привязка имени. В Go имя переменной, уже объявленное во внешней области видимости, может быть повторно объявлено во внутренней области видимости.
Такая ситуация называется затенением переменной и может приводить к распространенным ошибкам.

```go
var client *http.Client // Объявляется переменная client
if tracing {
    client, err := createClientWithTracing() // Создается HTTP-клиент со включенной трассировкой. (Переменная client затенена в этом блоке)
    if err != nil {
        return err
    }
    log.Println(client)
} else {
    client, err := createDefaultClient() // Создается HTTP-клиент по умолчанию. (Переменная client также затенена в этом блоке)
    if err != nil {
        return err
    }
    log.Println(client)
}
// Использование переменной client
```

В результате оказывается, что внешняя переменная всегда равна нулю.

Есть два варианта исправления:

```go
var client *http.Client
if tracing {
    c, err := createClientWithTracing() if err != nil  // Создается временная переменная c
    if err != nil {
        return err
    }
    client = c // Переменной client присваивается значение этой временной переменной
} else {
    // Та же логика
}
```

```go
var client *http.Client
var err error // Объявляется переменная err
if tracing {
    client, err = createClientWithTracing() // Используется оператор присваивания, чтобы напрямую присвоить переменной client значение, возвращаемое *http.Client
    if err != nil {
        return err
    }
} else {
    // Та же логика
}
```

Основное различие между ними заключается в том, что во втором варианте мы выполняем только одно присваивание, что можно считать более легким для чтения. Кроме того, со вторым вариантом можно объединить и реализовать обработку ошибок вне блоков операторов `if/else`, как показано в следующем примере:

```go
if tracing {
    client, err = createClientWithTracing()
} else {
    client, err = createDefaultClient()
}
if err != nil {
    // Типичная обработка ошибок
}
```

Затенение переменной происходит, когда ее имя повторно объявляется во внутренней области видимости, но мы видели, что эта практика чревата ошибками. Установка правила, запрещающего затененные переменные, зависит от личного вкуса. Иногда бывает удобно повторно использовать существующее имя, например `err`, для обозначения тех переменных, которые так или иначе связаны с ошибками. Но следует быть начеку, потому что теперь мы знаем, что можем столкнуться со сценарием, когда код компилируется, но переменная на самом деле получает значение, отличающееся от ожидаемого.


## ОШИБКА #2: ЛИШНИЙ ВЛОЖЕННЫЙ КОД

Важнейший аспект удобочитаемости — это фактор количества вложенных
уровней.
Предположим, что мы работаем над новым проектом и нужно понять, что делает следующая функция `join`:

```go
func join(s1, s2 string, max int) (string, error) {
    if s1 == "" {
        return "", errors.New("s1 is empty")
    } else {
        if s2 == "" {
            return "", errors.New("s2 is empty")
        } else {
            concat, err := concatenate(s1, s2) // Вызывает функцию concatenate для выполнения определенной конкатенации, но может возвращать ошибки
            if err != nil {
                return "", err
            } else {
                if len(concat) > max {
                    return concat[:max], nil
                } else {
                    return concat, nil
                }
            }
        }
    }
}

func concatenate(s1 string, s2 string) (string, error) {
    // ...
}
```

Эта функция `join` объединяет две строки и возвращает подстроку, если длина больше максимальной. Кроме того, она обрабатывает проверки `s1` и `s2` и проверяет, возвращает ли вызов `concatenate` ошибку.
С точки зрения реализации функциональности все сделано правильно. Но выстраивание ментальной модели, охватывающей все различные случаи, скорее всего, будет непростой задачей. Почему? Из-за количества вложенных уровней.

Посмотрим на код, выполняющий ту же функцию, но реализованный по другому:

```go
func join(s1, s2 string, max int) (string, error) {
    if s1 == "" {
        return "", errors.New("s1 is empty")
    }
    if s2 == "" {
        return "", errors.New("s2 is empty")
	}
    concat, err := concatenate(s1, s2)
    if err != nil {
        return "", err
    }
    if len(concat) > max {
        return concat[:max], nil
    }
    return concat, nil
}

func concatenate(s1 string, s2 string) (string, error) {
    // ...
}
```

В этой новой версии кода требует меньше когнитивного напряжения, хотя код выполняет тоже самое, что и раньше. Здесь есть только два вложенных уровня.

Как правило, чем больше вложенных уровней требует функция, тем сложнее ее читать и понимать.

* Когда происходит возврат из блока `if`, следует во всех случаях опускать блок `else`. Например, мы не должны писать:

```go
if foo() {
    // ...
    return true
} else {
    // ...
}
```

Вместо этого следует опустить блок `else`, как показано здесь:

```go
if foo() {
    // ...
    return true
}
// ...
```

Во второй версии этого фрагмента код, находившийся в блоке `else`, перемещается на верхний уровень, что упрощает его чтение.

* Можно следовать этой логике в случае с путем, не являющимся «счастливым»:

```go 
if s != "" {
    // ...
} else {
    return errors.New("empty string")
}
```

Нужно изменить это условие так:

```go
if s == "" { // Изменение условия в if
    return errors.New("empty string")
}
// ...
```

Эту версию кода читать легче, потому что она показывает «счастливый» путь на левом краю и уменьшает количество блоков.

## ОШИБКА #3: НЕПРАВИЛЬНО ИСПОЛЬЗОВАТЬ ФУНКЦИЮ ИНИЦИАЛИЗАЦИИ

Иногда в приложениях Go неправильно используются функции инициализации.
Потенциальные последствия — трудности в отслеживании и обработке ошибок или сложный в понимании код.
Функция инициализации (`init`) — это функция, используемая для инициализации состояния приложения. Она не имеет аргументов и не возвращает результата. 

Функция `init()` — это специальная функция в Go, которая:
* Выполняется автоматически перед входом в main(),
* Может быть определена несколько раз в одном пакете (все будут вызваны),
* Выполняется после инициализации переменных уровня пакета, но до main(),
* Используется для настройки состояния пакета.

```go
package main

import "fmt"

var a = func() int {
    fmt.Println("var") // Исполняется в первую очередь
    return 0
}()

func init() {
    fmt.Println("init") // Исполняется во вторую очередь
}

func main() {
    fmt.Println("main") // Исполняется в последнюю очередь
}
```

Мы можем определить несколько функций инициализации `init` для каждого пакета. В таком случае последовательность выполнения функции инициализации внутри пакета задается алфавитным порядком исходных файлов. Например, если пакет содержит файл `a.go` и файл `b.go` и в обоих содержится функция инициализации, то первой выполняется та из них, что находится в `a.go`.

Не следует слишком сильно полагаться на такой порядок выполнения функций инициализации внутри пакета — это может быть опасно, ведь исходные файлы могут быть переименованы и это может повлиять на порядок выполнения функций `init`.

Мы также можем определить несколько функций `init` в одном исходном файле.
Такой код вполне допустим:

```go 
func init() {
	fmt.Println("init 1") // Первая функция init
}
func init() {
	fmt.Println("init 2") //Вторая функция init
}
func main() {
}
```

Функцию `init` нельзя вызвать напрямую, как в следующем примере:

```go
package main

func init() {}

func main() {
    init()
}

// go build .
// ./main.go:6:2: undefined: init
```

### Почему `init()` часто используется неправильно

Пример:
```go
var db *sql.DB

func init() {
    db = connectToDB() // ← инициализация
}
```

На первый взгляд — удобно. Но именно здесь и начинаются проблемы.

1. Скрытые побочные эффекты
Код внутри `init()` выполняется неявно. Читая `main()`, вы не видите, что где-то в импортированном пакете уже произошло подключение к БД, запись в лог, изменение глобального состояния и т.д. → Это нарушает принцип **явности**

2. Невозможность обработки ошибок
Функция `init()` не может возвращать ошибки. Если подключение к БД провалится — у вас только два варианта:
* Паниковать (`panic`) — аварийное завершение,
* Игнорировать ошибку — и получить `nil`-указатель позже.

Оба варианта **плохи**.

Пример плохого кода:
```go
func init() {
    db, err := sql.Open("postgres", "...")
    if err != nil {
        panic(err) // плохо: нельзя корректно завершить программу
    }
}
```

3. Затруднённое тестирование

При запуске тестов `init()` вызывается один раз при загрузке пакета. Это означает:
* Вы не можете переинициализировать состояние между тестами,
* Тесты становятся зависимыми от глобального состояния,
* Невозможно подменить реализацию (например, использовать in-memory DB вместо настоящей).

4. Порядок выполнения непредсказуем

Если у вас несколько `init()` в разных файлах одного пакета — порядок их выполнения определяется лексикографически по имени файла, а не логикой. Это легко приводит к багам.

5. Инициализация при импорте (side-effectful import)

Go позволяет импортировать пакет только ради его `init()`:
```go
import _ "myapp/db" // вызывает init(), чтобы зарегистрировать драйвер
```

Это иногда оправдано (например, `import _ "github.com/go-sql-driver/mysql"`), но часто становится источником магии.

### Когда `init()` допустим

1. Регистрация драйверов или форматов
```go
import "database/sql"
import _ "github.com/lib/pq" // регистрирует PostgreSQL драйвер через init()
```
Здесь `init()` используется только для регистрации, без побочных эффектов.

2. Инициализация чистых значений (без ошибок)
```go
var version string

func init() {
    version = buildVersion() // детерминированная функция без ошибок
}
```

Допустимо, если `buildVersion()` не может упасть и не зависит от внешнего мира.

3. Тестовые фикстуры (в `_test.go`)

Иногда в тестах используют `init()` для подготовки данных, но даже здесь лучше предпочесть `TestMain` или setup-функции.

### Как правильно инициализировать ресурсы

Вместо `init()` — используйте явные конструкторы или фабрики.

Плохо (с `init`):
```go
// storage/db.go
var DB *sql.DB

func init() {
    DB = mustConnect() // panic при ошибке
}
```

Хорошо (явная инициализация):
```go
// storage/db.go
type DB struct {
    conn *sql.DB
}

func NewDB(dsn string) (*DB, error) {
    conn, err := sql.Open("postgres", dsn)
    if err != nil {
        return nil, fmt.Errorf("failed to open DB: %w", err)
    }
    return &DB{conn: conn}, nil
}

// main.go
db, err := storage.NewDB(os.Getenv("DB_DSN"))
if err != nil {
    log.Fatal(err)
}
```

* Избегайте `init()` для инициализации ресурсов, зависящих от внешнего мира (БД, файлы, сеть).
* Не используйте `init()` для логики, которая может завершиться ошибкой.
* Предпочитайте явные конструкторы с возвратом ошибки.
* Если вы всё же используете `init()` — документируйте это и ограничьте его использование регистрацией или вычислением констант.
* Никогда не пишите бизнес-логику в `init()`.

`Если тебе нужно обработать ошибку — не клади код в init().`

В 95% случаев, где разработчики используют `init()`, достаточно обычной функции с возвратом ошибки.

## ОШИБКА #4: ЗЛОУПОТРЕБЛЯТЬ ГЕТТЕРАМИ И СЕТТЕРАМИ

В Go нет автоматической поддержки геттеров и сеттеров, как в других языках. Не считается обязательным или идиоматичным использование геттеров и сеттеров для доступа к полям структуры (struct).

Если мы их используем, например с полем `Balance`, мы должны следовать вот этим соглашениям о наименованиях:

* Метод геттера должен называться `Balance` (а не `GetBalance`).
* Метод сеттера должен называться `SetBalance`.

```go
currentBalance := customer.Balance() // Геттер
if currentBalance < 0 {
    customer.SetBalance(0) // Сеттер
}
```

Не следует перегружать код геттерами и сеттерами в структурах, если они не приносят никакой пользы. Будьте прагматиками и ищите баланс между эффективностью и соблюдением идиом, которые в других парадигмах программирования иногда считаются непререкаемыми.

Go — уникальный язык, созданный исходя из целей достижения многих характеристик, включая простоту. Но если возникнет потребность в геттерах и сеттерах или эта потребность предвидится в будущем, гарантируя при этом «совместимость вперед», в их использовании нет ничего плохого.

## ОШИБКА #5: ЗАГРЯЗНЯТЬ ИНТЕРФЕЙСЫ

Загрязнение интерфейса (interface pollution) — это перегруз кода ненужными абстракциями, затрудняющими понимание. Это распространенная ошибка разработчиков, переходящих на Go с других языков и имеющих другие привычки. Она тесно связана с принципами проектирования, особенно с Принципом разделения интерфейсов (ISP — Interface Segregation Principle) из SOLID.

*Чем больше интерфейс, тем слабее абстракция.*
*Роб Пайк (Rob Pike)*

Разработчики часто создают "жирные" интерфейсы — то есть интерфейсы с множеством методов, многие из которых не нужны конкретному потребителю. Это приводит к ненужным зависимостям, усложнению тестирования и нарушению гибкости.

Пример "загрязнённого" интерфейса:
```go
type OrderService interface {
    CreateOrder(order Order) error
    GetOrder(id string) (Order, error)
    CancelOrder(id string) error
    RefundOrder(id string) error
    ExportOrdersToCSV() (string, error)
    SendOrderConfirmationEmail(id string) error
    CalculateTax(order Order) float64
}
```

Теперь представь, что у тебя есть хендлер для создания заказа:
```go
type CreateOrderHandler struct {
    service OrderService // зависит от всего интерфейса
}

func (h *CreateOrderHandler) Handle(order Order) error {
    return h.service.CreateOrder(order) // использует ТОЛЬКО один метод!
}
```

Хендлер зависит от всех 7 методов, хотя ему нужен только один. Это:
* Нарушает **ISP**,
* Усложняет моки в тестах (приходится реализовывать все методы),
* Создаёт ложную связанность: если изменится `ExportOrdersToCSV`, это может повлиять на сборку `CreateOrderHandler`, даже если он его не использует.


Как избежать загрязнения интерфейсов:

1. Создавай минимальные интерфейсы — по одному или нескольким методам

Go поощряет маленькие интерфейсы. Самый известный пример — `io.Reader` и `io.Writer`:
```go
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p [] byte) (n int, err error)
}
```

Они делают ровно одну вещь.

2. Определяй интерфейсы на стороне потребителя (Ошибка #6)

Потребитель сам решает, какие методы ему нужны:
```go
// Внутри пакета handler
type orderCreator interface {
    CreateOrder(Order) error
}

type CreateOrderHandler struct {
    service orderCreator // ← только то, что нужно
}
```

* Тестирование проще: мок должен реализовать только `CreateOrder`,
* Изменения в других методах (`RefundOrder`, `ExportOrdersToCSV`) не влияют на этот хендлер,
* Код стал более устойчивым к изменениям.

3. Комбинируй интерфейсы при необходимости

Если компоненту действительно нужны два метода — создай интерфейс из двух:
```go
type orderManager interface {
    CreateOrder(Order) error
    CancelOrder(string) error
}
```

Или даже комбинируй через встраивание (embedding):
```go
type OrderCreator interface {
    CreateOrder(Order) error
}

type OrderCanceller interface {
    CancelOrder(string) error
}

type OrderManager interface {
    OrderCreator
    OrderCanceller
}
```

Но встраивай только тогда, когда это действительно нужно — не ради "удобства".

### Gризнаки загрязнённого интерфейса

|Признак|Почему это плохо|
|--|--|
|Интерфейс называется `XService` и содержит 10+ методов|Он делает слишком много|
|В тестах приходится реализовывать методы, которые не используются|Нарушение **ISP**|
|Изменение одного метода ломает несвязанные компоненты|Слабая модульность|
|Интерфейс определён в том же пакете, что и реализация|Часто ведёт к "жирным" контрактам|

Многие разработчики делают так:
`«У меня есть структура OrderService с 8 методами → значит, интерфейс должен содержать все 8».`
Это ошибка.

Правильно:
`«У меня есть потребитель, которому нужны методы A и B → значит, я создаю интерфейс с A и B».`

Реализация (`*OrderService`) может иметь 20 методов — но потребитель видит только то, что ему нужно.

**Итог:**
* Делай интерфейсы маленькими — идеально 1–3 метода.
* Определяй их там, где они используются (consumer-side).
* Не копируй методы реализации в интерфейс "на всякий случай".
* Следуй принципу: "клиент не должен зависеть от того, чем он не пользуется".
* Если интерфейс большой — разбей его на несколько узкоспециализированных.

Рассмотрим три конкретных сценария, когда считается, что интерфейсы могут быть полезны.

* **Общее поведение**
Первый вариант — это использование интерфейсов, когда несколько типов реализуют общее поведение. Тогда можно заключить это поведение внутрь какого-то интерфейса. Например в пакете `sort` добавляется следующий интерфейс:
    ```go
    type Interface interface {
        Len() int // Число элементов
        Less(i, j int) bool // Сравнение двух элементов
        Swap(i, j int) // Перестановка двух элементов
    }
    ```


* **Снижение связанности (decoupling)**
Еще один важный сценарий — отделение кода от его реализации. Если мы полагаемся на абстракцию вместо конкретной реализации, сама реализация может быть заменена на другую без необходимости менять код. Это и есть принцип подстановки Лисков (буква L в принципах SOLID Роберта Мартина).
Одно из преимуществ снижения связанности может относиться к юнит-тестам.
    ```go
    type CustomerService struct {
        store mysql.Store // Зависит от конкретного способа реализации
    }
    func (cs CustomerService) CreateNewCustomer(id string) error {
        customer := Customer{id: id}
        return cs.store.StoreCustomer(customer)
    }
    ```
    Поскольку `customerService` использует реальную реализацию для хранения `Customer`, нужно протестировать его с помощью интеграционных тестов, что требует запуска экземпляра MySQ.
    Для большей гибкости нужно отвязать `CustomerService` от фактической реализации. Сделать это можно через интерфейс:
    ```go
    type customerStorer interface { // Создается абстракция хранилища
        StoreCustomer(Customer) error
    }

    type CustomerService struct { // Отвязывает CustomerService от фактической реализации
        storer customerStorer
    }

    
    func (cs CustomerService) CreateNewCustomer(id string) error {
        customer := Customer{id: id}
        return cs.storer.StoreCustomer(customer)
    }
    ```

* **Ограничение поведения**
Представим, что мы реализуем пользовательский конфигурационный пакет для работы с динамической конфигурацией. Мы создаем специальный контейнер для конфигураций `int` с помощью структуры `IntConfig`, в которой определены два метода: `Get` и `Set`.
    ```go
    type IntConfig struct {
        // ...
    }
    func (c *IntConfig) Get() int {
        // Получить конфигурацию
    }
    func (c *IntConfig) Set(value int) {
        // Обновить конфигурацию
    }
    ```
    Теперь предположим, что мы получили `IntConfig`, который содержит в себе определенную конфигурацию, например какое-то пороговое значение. Но в нашем коде нас интересует только получение значения этой конфигурации, и мы хотим предотвратить его обновление. Как мы можем обеспечить, чтобы семантически эта конфигурация была доступна только для чтения, если мы не хотим изменять пакет конфигурации? Ответ: создав абстракцию, которая ограничивает поведение только получением значения конфигурации:
    ```go
    type intConfigGetter interface {
        Get() int
    }
    ```

Интерфейсы полезны для создания абстракций. И главное предостережение при знакомстве программиста с абстракциями — это помнить, что абстракции нужно открывать, а не создавать. Это означает, что мы не должны начинать создавать абстракции в коде, если для этого нет веской причины. Нужно не конструировать интерфейсы, а ждать возникновения конкретной потребности в них.
Следует быть очень осторожными при создании абстракций в коде: их следует обнаруживать, а не создавать. Для разработчиков характерно чрезмерно усложнять код в попытках угадать идеальный уровень абстракции. Этого следует избегать, поскольку в большинстве случаев в результате код «загрязняется» ненужными абстракциями и становится сложным для чтения.

## ОШИБКА #6: ИНТЕРФЕЙСЫ НА СТОРОНЕ ПРОИЗВОДИТЕЛЯ

Go-разработчики часто неправильно понимают другой вопрос: где должен жить интерфейс?
Часто можно увидеть, как разработчики создают интерфейсы на стороне производителя наряду с конкретной реализацией. Этот программный дизайн привычен для разработчиков, имеющих опыт работы с C # или с Java. Но в Go в большинстве случаев так делать не следует.

* *Сторона производителя (Producer)* — интерфейс, определенный в том же пакете, что и конкретная реализация.
* *Сторона потребителя (Consumer)* — интерфейс, определенный во внешнем пакете, где он используется.

Интерфейсы в Go реализованы неявно, что обычно меняет правила игры по сравнению с языками с явной реализацией. В большинстве случаев подход, которому стоит следовать, аналогичен тому, что мы описали в предыдущем разделе: абстракции следует открывать, а не создавать. Это означает, что производитель не должен навязывать определенную абстракцию всем потребителям. Вместо этого потребитель должен решить, нужна ли ему какая-либо форма абстракции, а затем определить наилучший уровень абстракции для своих нужд.

Пример: создадим специальный пакет для хранения и извлечения данных о потребителях. Мы решаем, что все вызовы в том же пакете должны проходить через следующий интерфейс:

```go
package store

type CustomerStorage interface {
    StoreCustomer(customer Customer) error
    GetCustomer(id string) (Customer, error)
    UpdateCustomer(customer Customer) error
    GetAllCustomers() ([]Customer, error)
    GetCustomersWithoutContract() ([]Customer, error)
    GetCustomersWithNegativeBalance() ([]Customer, error)
}
```

Можно подумать, что есть веские причины для создания этого интерфейса и предоставления доступа к нему на стороне производителя. Возможно, это
хороший способ отвязать код потребителя от фактической реализации, но в Go это не лучшая практика. Интерфейсы в Go реализованы неявно, что обычно меняет правила игры по сравнению с языками с явной реализацией.

*Абстракции следует открывать, а не создавать* - Это означает, что производитель не должен навязывать определенную абстракцию всем потребителям. Вместо этого потребитель должен решить, нужна ли ему какая-либо форма абстракции, а затем определить наилучший уровень абстракции для своих нужд.
Возможно, другой потребитель захочет отвязать свой код, но его интересует только метод `GetAllCustomers`. Тогда он может создать интерфейс только одним методом, ссылаясь на структуру `Customer` из внешнего пакета:

```go
package client

type customersGetter interface {
    GetAllCustomers() ([]store.Customer, error)
}
```

Суть состоит в том, что пакет `client` теперь может определить для своих нужд наиболее точную абстракцию (в этом примере есть только один метод). Это связано с концепцией принципа разделения интерфейса (I — ISP — в SOLID), которая гласит, что ни один потребитель не должен зависеть от методов, которые он не использует. И в этом случае лучший подход — разместить конкретную реализацию на стороне производителя, дать к ней доступ и позволить потребителю решить, как ее использовать и нужна ли вообще здесь абстракция.

Для полноты изложения отметим, что подход интерфейсов на стороне про- изводителя иногда используется в стандартной библиотеке. Например, пакет `encoding` определяет интерфейсы, реализованные другими субпакетами, такими как `encoding/json` или `encoding/binary`. Является ли пакет encoding неверным с этой точки зрения? Точно нет. В этом случае абстракции, определенные в пакете `encoding`, используются во всей стандартной библиотеке, и разработчики языка знали, что предварительное создание этих абстракций полезно.
В большинстве случаев интерфейс должен жить на стороне потребителя. Но в определенных контекстах можно сделать его на стороне производителя.

## ОШИБКА #7: ВОЗВРАТ ИНТЕРФЕЙСОВ

При разработке сигнатуры функции может потребоваться вернуть либо интерфейс, либо конкретную реализацию. Возврат интерфейса во многих случаях в Go считается плохой практикой.

В пакете `store` мы определяем структуру `InMemoryStore`, реализующую интерфейс `Store`. Мы также создаем функцию `NewInMemoryStore` для возврата интерфейса `Store`. При таком дизайне есть зависимость пакета реализации от пакета потребителя, и это может показаться странным. Например, пакет `client` больше не может вызывать функцию `NewInMemoryStore`, в противном случае возникла бы циклическая зависимость. Возможным решением может быть вызов этой функции из другого пакета и внедрение реализации `Store` в `client`.
Что произойдет, если структуру `InMemoryStore` будет использовать другой потребитель? Тогда, возможно, захотелось бы переместить интерфейс `Store` в другой пакет или обратно в пакет реализации, но мы уже обсуждали, почему во многих случаях это плохая идея.
Возврат интерфейса, как правило, ограничивает гибкость, поскольку мы за-
ставляем всех потребителей использовать один конкретный тип абстракции.

В Go лучше использовать:

* возврат структур вместо интерфейсов;
* допущение использования интерфейсов, если это возможно.

Конечно, есть и исключения. Разработчики знают, что правила никогда не выполняются на 100 %. Самое важное из них касается типа `error` — интерфейса, возвращаемого многими функциями.

Если мы четко знаем (а не просто предполагаем), что абстракция будет полезна для потребителей, то можем подумать о возврате интерфейса. В противном случае мы не должны навязывать использование абстракций; необходимость их использования должна быть «обнаружена» клиентами. Если клиенту по какой-либо причине нужно абстрагировать реализацию, он все равно сможет сделать это на клиентской стороне.

## ОШИБКА #8: ANY НЕ ГОВОРИТ НИ О ЧЕМ

В Go тип интерфейса, который определяет нулевые методы, известен как пустой интерфейс, `interface{}`. В Go 1.18 предварительно объявленный тип `any` стал чем-то вроде псевдонима для пустого интерфейса, поэтому во всех случаях `interface{}` может быть заменен на `any`. Во многих случаях `any` можно считать чрезмерным обобщением.

```go
var i any

i = 42 // Тип int
i = "foo" // Тип string
i = struct { // Структура
    s string
}{
   s: "bar",
}
i = f // Функция
```

При присвоении значению типа `any` мы теряем всю информацию о типе, что требует подтверждения типа (type assertion), чтобы получить что-либо полезное из переменной i.

Посмотрим пример, где использование `any` не совсем точно:

```go
package store

type Customer struct{
    // какой-то код
}
type Contract struct{
    // какой-то код
}

type Store struct{}

func (s *Store) Get(id string) (any, error) { // Возвращает any
    // ...
}
func (s *Store) Set(id string, v any) error { // Принимает any
    // ...
}
```

Хотя в коде `Store` нет ничего ошибочного с точки зрения компиляции, следует остановиться и подумать о сигнатурах методов. Поскольку мы принимаем и возвращаем аргументы `any`, методам не хватает выразительности. Если другим разработчикам потребуется использовать структуру `Store`, им придется покопаться в документации или в коде, чтобы понять, как использовать эти методы. Следовательно, принятие или возврат типа `any` не передает значимой информации.
Следует избегать типа `any` и делать сигнатуры максимально явными. Что касается нашего примера, это может означать дублирование методов *Get*
и *Set* для каждого типа:

```go
func (s *Store) GetContract(id string) (Contract, error) {
    // ...
}
func (s *Store) SetContract(id string, contract Contract) error {
    // ...
}
func (s *Store) GetCustomer(id string) (Customer, error) {
    // ...
}
func (s *Store) SetCustomer(id string, customer Customer) error {
    // ...
}
```

Здесь методы достаточно выразительны, что снижает риск непонимания. Наличие большего количества методов не всегда проблема, поскольку клиенты также могут создавать свои собственные абстракции с помощью какого-либо интерфейса.

В каких случаи `any` полезен? Посмотрим на стандартную библиотеку и два примера, где функции или методы принимают аргументы `any`. Первый пример
находится в пакете `encoding/json`. Поскольку мы можем маршалировать любой
тип, функция `Marshal` принимает аргумент `any`

```go
func Marshal(v any) ([]byte, error) {
    // ...
}
```

Другой пример можно найти в пакете database/sql:

```go
func (c *Conn) QueryContext(ctx context.Context, query string, args ...any) (*Rows, error) {
    // ...
}
```

`any` может быть полезен, если есть реальная необходимость принять или вернуть любой возможный тип, в общем, мы должны любой ценой избегать чрезмерного обобщения своего кода. Возможно, иногда небольшое дублирование кода будет приветствоваться, если это улучшает другие аспекты, например выразительность.

## ОШИБКА #9: ПУТАНИЦА В ИСПОЛЬЗОВАНИИ ДЖЕНЕРИКОВ

В Go 1.18 в язык добавлены дженерики. Это позволяет писать код с типами, которые можно указать позже и создавать при необходимости. При этом может возникнуть путаница, когда использовать дженерики.

Разработчики начинают использовать дженерики везде, где "можно", даже когда это не нужно — например, для простых функций, где `interface{}` или конкретные типы работают лучше. Это создаёт ложное ощущение "более продвинутого" кода, но на деле вредит простоте и ясности, которые Go так ценит.

Типичные проявления путаницы:

1. Использование дженериков вместо `interface{}` или конкретных типов без пользы

```go
func Print[T any](v T) {
    fmt.Println(v)
}
```

Зачем? Ведь можно просто:
```go
func Print(v interface{}) {
    fmt.Println(v)
}
```

Здесь дженерики ничего не дают: нет ограничений (constraints), нет обработки типа, нет возврата значения. Это просто синтаксический шум.

2. Создание дженерик-структур без реальной необходимости

Плохо:
```go
type Repository[T any] struct {
    db *sql.DB
}

func (r *Repository[T]) Save(entity T) error { ... }
```

Но если у тебя есть только `UserRepository` и `OrderRepository`, и они работают с разной логикой — дженерики здесь не помогут. Более того, ты потеряешь:
* Читаемость (`Repository[User]` vs `UserRepository`),
* Возможность специализировать поведение под тип,
* Простоту тестирования.

Лучше используй конкретные структуры или интерфейсы, если нужна абстракция.

3. Игнорирование ограничений (constraints)

Дженерики без ограничений (`any`) часто бесполезны:
```go
func Add[T any](a, b T) T {
    return a + b // ОШИБКА: оператор + не определён для любого типа!
}
```

Это не скомпилируется. Нужно указать, что `T` должен поддерживать сложение:
```go
import "golang.org/x/exp/constraints"

func Add[T constraints.Ordered](a, b T) T {
    return a + b
}
```

Но даже тогда — задайся вопросом: часто ли тебе нужно складывать значения разных числовых типов в одном месте?
Часто ответ — нет, и проще написать отдельные функции:
```go
func AddInt(a, b int) int
func AddFloat(a, b float64) float64
```

4. Попытка сделать "универсальный" код, который на деле не переиспользуется

Многие пишут дженерик-функции вроде:
```go
func Map[T, R any](slice []T, fn func(T) R) []R {
    result := make([]R, len(slice))
    for i, v := range slice {
        result[i] = fn(v)
    }
    return result
}
```

Это выглядит круто… но:
* Такая функция уже есть в популярных библиотеках (`slices.Map` в Go 1.21+),
* Если ты используешь её только один раз — зачем усложнять?
* В Go часто проще написать цикл напрямую, чем абстрагироваться.

Пример: вместо
```go
names := Map(users, func(u User) string { return u.Name })
```

проще и понятнее:
```go
names := make([]string, len(users))
for i, u := range users {
    names[i] = u.Name
}
```

Это быстрее, читабельнее и не требует дженериков

**Когда полезно использовать дженерики:**

1. Ты реализуешь общую структуру данных

Стек, очередь, дерево, кэш:
```go
type Stack[T any] struct {
    items []T
}

func (s *Stack[T]) Push(v T) { s.items = append(s.items, v) }
func (s *Stack[T]) Pop() (T, bool) { ... }
```

Здесь дженерики оправданы: логика одинакова для любого типа.

2. Ты пишешь утилиты, которые реально переиспользуются во многих местах

Например, безопасное получение значения из map:
```go
func GetOrDefault[K comparable, V any](m map[K]V, key K, def V) V {
    if v, ok := m[key]; ok {
        return v
    }
    return def
}
```

Но даже здесь: начни с конкретного случая, и обобщай только при повторении.

3. Ты хочешь сохранить типобезопасность без дублирования кода

Например, валидатор, который работает с разными типами, но возвращает тот же тип:
```go
func ValidateAndReturn[T Validatable](v T) (T, error) {
    if err := v.Validate(); err != nil {
        return v, err
    }
    return v, nil
}
```

при условии, что `Validatable` — интерфейс с методом `Validate()`


Дженерики вводят некоторую форму абстракции, а нам нужно помнить, что ненужные абстракции только усложняют работу.
Не будем загрязнять код ненужными абстракциями и сосредоточимся на решении конкретных задач. Это означает, что использовать параметры типа не нужно, если на то нет оснований. Когда надо будет писать шаблонный код, и только тогда рассмотрите возможность использования дженериков.

|Ситуация|Что делать|
|--|--|
|Функция принимает/возвращает один тип|Используй конкретный тип|
|Нужно работать с `int`, `float64`, `string` одинаково|Подумай дважды — часто лучше отдельные функции|
|Хочешь "сделать как в других языках"|Остановись — Go не Java и не TypeScript|
|Пишешь алгоритм над коллекцией|Сначала попробуй обычный цикл|
|Создаёшь контейнер (список, кэш и т.д.)|Дженерики уместны|

Используй дженерики редко, осознанно и только там, где они действительно устраняют дублирование или добавляют типобезопасность без ущерба для ясности.

Ошибка #9 — это ловушка "синдрома новой игрушки": дженерики появились — и многие начали применять их повсюду, даже там, где они вредят философии Go.

## ОШИБКА #10: НЕ ЗНАТЬ О ВОЗМОЖНЫХ ПРОБЛЕМАХ СО ВСТРАИВАНИЕМ ТИПОВ

При создании структуры Go позволяет встраивать типы. Но иногда это может привести к неожиданному поведению, если мы не понимаем всех последствий такого встраивания.
В Go поле структуры называется встроенным, если оно объявлено без имени.
Например:

```go
type Foo struct {
    Bar // Встроенное поле
}

type Bar struct {
    Baz int
}
```

В структуре `Foo` тип `Bar` объявлен без связанного имени, следовательно, это встроенное поле. Мы используем встраивание для продвижения (*promote*) полей и методов встроенного типа. Поскольку `Bar` содержит поле `Baz`, это поле продвигается в `Foo`. Таким образом, `Baz` становится доступным из `Foo`. Доступ к `Baz` возможен по двум разным путям:

```go
foo := Foo{}

foo.Baz = 42
// или
foo.Bar.Baz = 42
```

Давайте рассмотрим пример неправильного их использования. Ниже мы реализуем `struct`, который хранит некоторые данные в памяти, и хотим защитить его от конкурентного доступа с помощью мьютекса:

```go
type InMem struct {
    sync.Mutex // Встроенное поле
    m map[string]int
}
func New() *InMem {
    return &InMem{m: make(map[string]int)}
}
```

Мы решили сделать карту неэкспортируемой, чтобы клиенты не могли взаимодействовать с ней напрямую, а только через экспортированные методы. Между тем поле мьютекс встроено. Поэтому мы можем реализовать метод `Get` так:

```go
func (i *InMem) Get(key string) (int, bool) {
    i.Lock() // Прямой доступ к методу Lock
    v, contains := i.m[key]
    i.Unlock() // То же самое относительно метода Unlock
    return v, contains
}
```

Этот мьютекс встроен, мы можем напрямую обращаться к методам `Lock` и `Unlock` из получателя i. 

Поскольку `sync.Mutex` — это встроенный тип, методы `Lock` и `Unlock` будут продвигаться и мы можем напрямую обращаться к этим методам из получателя i. Поэтому оба метода станут видимыми и для внешних потребителей, использующих `InMem`:

```go
m := inmem.New()
m.Lock() // ??
```

Такое продвижение, вероятно, — нежелательный эффект. В большинстве случаев мьютекс — это то, что мы хотим инкапсулировать в структуру и сделать невидимым для внешних клиентов. Поэтому здесь не следует делать его встроенным полем:

```go
type InMem struct {
    mu sync.Mutex // Указывает, что поле sync.Mutex не является встроенным
    m map[string]int 
}
```

Поскольку мьютекс не встроен и не экспортируется, доступ к нему внешних
потребителей закрыт.

Рассмотрим другой пример, где встраивание можно считать правильным подходом. Нужно написать собственный логгер, содержащий `io.WriteCloser` и делающий доступными два метода: `Write` и `Close`. Если бы `io.WriteCloser` не был встроенным, код был бы таким:

```go
type Logger struct {
    writeCloser io.WriteCloser
}
func (l Logger) Write(p []byte) (int, error) {
    return l.writeCloser.Write(p) // Перенаправляет вызов на writeCloser
}
func (l Logger) Close() error {
    return l.writeCloser.Close() // Перенаправляет вызов на writeCloser
}
func main() {
    l := Logger{writeCloser: os.Stdout}
    _, _ = l.Write([]byte("foo"))
    _ = l.Close()
}
```

`Logger` должен был предоставить доступ как к методу `Write`, так и к методу `Close`, которые бы только перенаправляли вызов на `io.WriteCloser`. Но если теперь сделать поле встроенным, то можно удалить эти методы перенаправления:

```go
type Logger struct {
    io.WriteCloser // io.Writer делается встроенным
}
```

Логгер остается для клиентов тем же самым, с двумя экспортированными методами `Write` и `Close`. Но при этом становится возможным не расписывать эти дополнительные методы для простой переадресации вызова.

Какой следует сделать вывод о встраивании типов? Прежде всего оно редко бывает по-настоящему нужно, а это значит, что независимо от сути конкретной задачи мы, скорее всего, сможем решить ее и без применения встраивания типов. В основном оно используется для удобства: для продвижения поведения.

Если же мы все-таки решаем использовать встраивание типов, то нужно помнить о двух основных ограничениях:

* Не следует его использовать исключительно как синтаксический сахар — для упрощения доступа к полю (например, `Foo.Baz()` вместо `Foo.Bar.Baz()`). Если это единственная причина, то вместо встраивания внутреннего типа лучше использовать поле.

* Оно не должно продвигать данные (поля) или поведение (методы), которые мы хотим скрыть от посторонних глаз: например, если оно позволяет клиентам получить доступ к поведению блокировки, которое должно оставаться приватным для структуры.

## ОШИБКА #11: НЕ ИСПОЛЬЗОВАТЬ ПАТТЕРН ФУНКЦИОНАЛЬНЫХ ОПЦИЙ

Ошибка посвящена неправильному или избыточному использованию паттерна **Functional Options**, особенно в тех случаях, когда он не нужен или усложняет API без пользы.

**Не используй паттерн Functional Options автоматически — применяй его только тогда, когда у тебя действительно есть опциональные параметры конфигурации, и их количество/гибкость оправдывает сложность.**

Многие разработчики начинают применять этот паттерн "по привычке", даже когда:
* У конструктора всего 1–2 параметра,
* Все параметры обязательны,
* Или альтернативы (например, структура конфигурации) проще и понятнее.

Это приводит к избыточной сложности, ухудшению читаемости и трудностям при тестировании.

**Functional Options** - это идиома Go для гибкой настройки объектов с опциональными параметрами:
```go
type Server struct {
    addr    string
    timeout time.Duration
    retries int
}

// Тип опции — функция, которая модифицирует Server
type Option func(*Server)

func WithTimeout(t time.Duration) Option {
    return func(s *Server) {
        s.timeout = t
    }
}

func WithRetries(r int) Option {
    return func(s *Server) {
        s.retries = r
    }
}

// Конструктор принимает вариадические опции
func NewServer(addr string, opts ...Option) *Server {
    s := &Server{
        addr:    addr,
        timeout: 30 * time.Second, // значение по умолчанию
        retries: 3,
    }
    for _, opt := range opts {
        opt(s)
    }
    return s
}
```

Использование:
```go
server := NewServer("localhost:8080", WithTimeout(10*time.Second), WithRetries(5))
```

Это удобно, когда:
* Есть много опциональных параметров,
* Некоторые параметры редко меняются,
* Хочется сохранить чистый и расширяемый API.

**Это ошибка когда:**

Представь, что у тебя простой клиент:
```go
type Client struct {
    url string
}

func NewClient(url string) *Client {
    return &Client{url: url}
}
```

Всё просто, понятно, работает.

Но ты думаешь: «А вдруг завтра понадобится таймаут? Надо сразу сделать Functional Options» — и переписываешь:
```go
type Client struct {
    url     string
    timeout time.Duration
}

type Option func(*Client)

func WithTimeout(t time.Duration) Option {
    return func(c *Client) { c.timeout = t }
}

func NewClient(url string, opts ...Option) *Client {
    c := &Client{url: url, timeout: 5 * time.Second}
    for _, opt := range opts {
        opt(c)
    }
    return c
}
```

А пока используешь так:
```go
client := NewClient("https://api.example.com")
```

**Проблемы:**

Ты добавил сложность без реальной потребности. Пока нет второго параметра — паттерн не оправдан.

Более того:
* Код стал длиннее,
* Появились дополнительные типы (Option),
* Интерфейс NewClient теперь менее очевиден (что можно передать? какие опции существуют?),
* Тестировать сложнее (нужно проверять комбинации опций).

**Когда Functional Options оправдан:**
* Есть несколько опциональных параметров (≥2–3),
* Некоторые параметры редко используются,
* Ты хочешь сохранить обратную совместимость при расширении API,
* Альтернатива (например, передача структуры Config) менее удобна.

Пример оправданного использования — из стандартной библиотеки:
```go
http.NewRequestWithContext(ctx, method, url, body)
// или
sql.OpenDB(connector) + driver-specific options
```

Или пример — `grpc.Dial`:
```go
conn, err := grpc.Dial(addr,
    grpc.WithTransportCredentials(credentials),
    grpc.WithTimeout(5*time.Second),
    grpc.WithBlock(),
)
```

Здесь десятки возможных настроек — без Functional Options было бы невозможно.

### Альтернативы

1. Структура конфигурации

Если параметров много, но они обычно задаются вместе, лучше использовать `Config`:
```go
type Config struct {
    URL     string
    Timeout time.Duration
    Retries int
}

func NewClient(cfg Config) *Client { ... }
```

Плюсы:
* Явно видно все поля,
* Легко сериализовать (например, из YAML),
* Проще документировать.

2. Простой конструктор с фиксированными параметрами

Если параметров мало и все обязательны — просто передавай их напрямую.

|Ситуация|Что делать|
|--|--|
|1–2 обязательных параметра|Простой конструктор: `NewX(a, b)`|
|Много опциональных параметров, часто расширяется|Functional Options|
|Много параметров, но обычно задаются вместе|Структура `Config`|
|Не знаешь, будут ли опции нужны|Не добавляй их заранее! Добавь позже, когда будет реальная потребность|

**YAGNI (You Aren’t Gonna Need It) — не усложняй код "на будущее".**

Ошибка #11 — это преждевременная абстракция.

## ОШИБКА #12: НЕОРГАНИЗОВАННОСТЬ ПРОЕКТА

Ошибка посвящена одной из самых частых, но при этом критически важных проблем в Go-проектах — отсутствию четкой и продуманной структуры кода.

**Разработчики часто начинают проекты без чёткого плана структуры, кладут всё в main.go или создают произвольные папки вроде utils, helpers, common — что приводит к спагетти-коду, циклическим зависимостям и сложности тестирования.**

Принципы хорошей организации Go-проекта:

Следуй стандартной макет-структуре
Официальный документ Standard Go Project Layout (https://github.com/golang-standards/project-layout?tab=readme-ov-file)
* Не от команды Go, но де-факто принят сообществом
* В 2021 году Расс Кокс (Russ Cox), один из основных мейнтейнеров Go, раскритиковал этот макет. В основном проект существует в рамках организации GitHub golang-standards, хоть и не является официальным стандартом. Имейте в виду, что в отношении структуры проекта нет
обязательных соглашений. 

Предлагает следующее:
```
myapp/
├── cmd/
│   └── myapp/
│       └── main.go          ← точка входа
├── internal/
│   ├── api/                 ← HTTP-хендлеры
│   ├── service/             ← бизнес-логика
│   ├── storage/             ← работа с БД
│   └── domain/              ← модели и интерфейсы (чистая логика)
├── pkg/                     ← публичные библиотеки (если проект — библиотека)
├── scripts/
├── configs/
├── deployments/
├── go.mod
└── README.md
```

`internal/` — всё, что не должно быть доступно извне.

Запрещённые слова в путях:

* `utils`
* `helpers`
* `common`
* `misc`

Почему? Потому что они становятся свалками для всего подряд, нарушая принцип единственной ответственности. Вместо этого — называй папки по их роли:

* `auth` — аутентификация,
* `payment` — платежи,
* `email` — отправка писем,
* `validator` — валидация.

Если ты пишешь утилиту для работы со строками — возможно, она вообще не нужна, или её место в конкретном модуле (`user/format.go`, а не `utils/string.go`).

### Разделяй по слоям (архитектурные границы)

Часто применяют:
* Domain-Driven Design (DDD): `domain` → `application` → `infrastructure`
* Clean Architecture / Hexagonal: core logic не зависит от внешних деталей (БД, HTTP)
* Modular Monolith: каждый модуль (`user`, `order`) содержит всё, что ему нужно (handler, service, repo)

Пример:
```
internal/
├── user/
│   ├── domain/
│   │   └── user.go
│   ├── service/
│   │   └── service.go
│   ├── storage/
│   │   └── postgres.go
│   └── handler/
│       └── http.go
└── order/
    └── ...
```

Не смешивай уровни абстракции:
* `main.go` должен только собирать зависимости и запускать приложение.
* Бизнес-логика никогда не должна быть в `cmd/`.
* Конфигурация, логирование, подключение к БД — выносится в отдельные компоненты.

Плохо:
```go
// cmd/myapp/main.go
func main() {
    db := sql.Open(...) // ← логика подключения к БД в main!
    if user.Balance < 0 { ... } // ← бизнес-логика в main!
}
```

Хорошо:
```go
// cmd/myapp/main.go
func main() {
    cfg := loadConfig()
    app := application.New(cfg)
    app.Run()
}
```

Управляй зависимостями через go.mod и внутренние границы:
* Используй `internal/`, чтобы запретить импорт извне.
* Избегай циклических импортов — они невозможны в Go, но попытки их создать указывают на плохую архитектуру.
* Если модуль A зависит от B, а B — от A → нужно выделить общую часть в третий модуль (часто — `domain`).

|Признак|Проблема|
|--|--|
|Всё в одном файле `main.go`|Невозможно тестировать, расширять|
|Папка `utils` с 20 файлами|Нет чёткой ответственности|
|Импорты из `cmd/` в другие пакеты|Нарушение слоёв|
|Бизнес-логика в HTTP-хендлерах|Слишком тесная связь с транспортом|
|Модели БД (`gorm.Model`) используются напрямую в API|Нет разделения между слоями|

Как избежать:
* Начни с `internal/` и `cmd/` — даже для маленького проекта.
* Выдели `domain` — чистые структуры и интерфейсы без зависимостей.
* Пиши интерфейсы на стороне потребителя (см. Ошибка #6).
* Группируй по функциональности, а не по типу файла:
    - Плохо: `handlers/`, `services/`, `repos/` (анемичная архитектура)
    - Хорошо: `user/`, `payment/`, `notification/` (модульная)
* Проводи регулярный ревью структуры — особенно при росте проекта.

`«Хорошая организация проекта — это инвестиция в будущее. Она не замедляет разработку, а ускоряет поддержку, тестирование и масштабирование».`

Если ты не можешь объяснить, зачем существует папка — её, скорее всего, не должно быть.

Ошибка #12 — не про синтаксис, а про дисциплину.

## ОШИБКА #13: СОЗДАВАТЬ ПАКЕТЫ УТИЛИТ

Разработчики создают пакеты с названиями вроде `utils`, `helpers`, `common`, `misc` и складывают туда "всё подряд", что кажется переиспользуемым. Это приводит к неструктурированному коду, слабой связанности и трудностям в поддержке.


**«В Go не должно быть пакета `utils`. Если вы чувствуете, что он вам нужен — вы делаете что-то не так».**

Почему это плохо?
* Нарушает принцип единственной ответственности. Пакет должен отвечать за одну конкретную область (например, `auth`, `email`, `payment`). Пакет `utils` — это мусорка.
* Создаёт скрытые зависимости. Когда любой модуль может импортировать `utils`, возникает неявная связность.
* Мешает повторному использованию. Если вы когда-нибудь захотите вынести модуль (например, `user`) в отдельную библиотеку — вы обнаружите, что он зависит от `utils`, который содержит код из десятка других модулей → Вынуждены либо тащить весь `utils`, либо рефакторить.
* Затрудняет навигацию и понимание. Например новый разработчик видит:
```go
if utils.IsValidEmail(user.Email) { ... }
```
— но не понимает контекста. Это общая валидация? Или специфичная для пользователей? Где ещё используется?

Например:
```go
package util

func NewStringSet(...string) map[string]struct{} {
    // ...
}
func SortStringSet(map[string]struct{}) []string {
    // ...
}
```

Клиент будет использовать этот пакет вот так:
```go
set := util.NewStringSet("c", "a", "b")
fmt.Println(util.SortStringSet(set))
```

Проблема в том, что название пакета `util` бессмысленно. Мы могли бы назвать его `common`, `shared` или `base`, но эти названия тоже бессмысленны и не дают никакого представления о том, что делает этот пакет.

Вместо «пакет утилит» (utility package) лучше придумать более выразительное имя, например stringset («набор строк»):

```go
package stringset

func New(...string) map[string]struct{} { ... }
func Sort(map[string]struct{}) []string { ... }
```

В этом примере мы удалили суффиксы для `NewStringSet` и `SortStringSet`, которые соответственно стали `New` и `Sort`. На стороне клиента это теперь выглядит так:
```go
set := stringset.New("c", "a", "b")
fmt.Println(stringset.Sort(set))
```

Можно пойти еще дальше. Вместо создания служебных функций можно создать специфический тип и предоставить `Sort` как метод так:

```go
package stringset

type Set map[string]struct{}
func New(...string) Set { ... }
func (s Set) Sort() []string { ... }
```

Это изменение делает клиент еще более простым. На пакет `stringset` будет только одна ссылка:
```go
set := stringset.New("c", "a", "b")
fmt.Println(set.Sort())
```

Ошибка #13 — это симптом более глубокой проблемы: отсутствия чётких границ ответственности.
Go поощряет маленькие, сфокусированные пакеты, а не монолитные свалки.

## ОШИБКА #14: ИГНОРИРОВАТЬ КОЛЛИЗИИ ИМЕН ПАКЕТОВ

Коллизии имен пакетов возникают, когда переменная имеет такое же имя, как и у существующего пакета, что мешает его переиспользованию. Рассмотрим пример с библиотекой, открывающей клиент Redis:

```go
package redis

type Client struct { ... }
func NewClient() *Client { ... }
func (c *Client) Get(key string) (string, error) { ... }
```

Перейдем на сторону клиента. Несмотря на существование имени пакета redis, в Go вполне допустимо создать и переменную с именем redis:

```go
redis := redis.NewClient()  // Вызывается NewClient из пакета redis
v, err := redis.Get("foo")  // Используется переменная с именем redis
```

Здесь происходит коллизия имени переменной redis с именем пакета redis. Хотя такое использование наименований и разрешено, его следует избегать. Во всей области действия переменной redis пакет redis будет недоступен.

Предположим, что какой-то квалификатор ссылается как на переменную, так и на имя пакета внутри всей функции. В этом случае тот, кто читает код, может и не понять, на что он ссылается. Как избежать такой коллизии? 

1. Использовать другое имя переменной. Например:
```go
redisClient := redis.NewClient()
v, err := redisClient.Get("foo")
```

2. Но если по какой-то причине нужно оставить redis в качестве имени нашей переменной, можно поиграть с импортом пакетов. Применяя импорт пакетов, можно использовать псевдоним, чтобы изменить квалификатор для ссылки на пакет redis. Например:
```go
import redisapi "mylib/redis" // Для пакета redis создается псевдоним

// ...
redis := redisapi.NewClient() // Указывается на доступ к пакету redis через псевдоним redisapi
v, err := redis.Get("foo")
```

Для импорта использовался псевдоним redisapi, ссылающийся на пакет redis, чтобы сохранить имя переменной redis.

## ОШИБКА #15: НЕ ПИСАТЬ ДОКУМЕНТАЦИЮ ПО КОДУ

Создание соответствующей документации — важная часть написания кода. Она упрощает клиентам использование API, а также помогает в поддержке и сопровождении проекта.

Прежде всего, каждый экспортируемый элемент должен быть задокументирован. Будь то структура, интерфейс, функция или что-то еще, если элемент экспортируется, он должен быть задокументирован. Принято добавлять комментарии, начиная с имени экспортируемого элемента. Например:
```go
// Customer — это представление потребителя.
type Customer struct{}
// ID возвращает идентификатор потребителя.
func (c Customer) ID() string { return "" }
```

По правилам, каждый комментарий должен быть полным предложением, заканчивающимся точкой. Также имейте в виду, что когда мы описываем функцию (или метод), мы должны указывать то, что функция должна делать, а не то, как она это делает. В идеале документация должна содержать достаточно информации, чтобы клиенту не нужно было каждый раз изучать код, чтобы понять, как использовать экспортируемый элемент.

Экспортированный элемент можно объявить устаревшим с помощью комментария `// Deprecated`

Когда дело доходит до документирования переменной или константы, нас может заинтересовать передача связанных с ними двух аспектов: назначения и содержания. Первый должен быть отражен в документации, что будет полезно для внешних клиентов. Последний не обязательно делать публичным. Например:
```go
// DefaultPermission разрешение по умолчанию, используемое движком магазина.
const DefaultPermission = 0o644 // Необходим доступ на чтение и запись.
```

По соглашению комментарий начинается с `// Package`, за которым следует имя пакета:
```go
// Пакет math предоставляет основные константы и математические функции.
//
// Этот пакет не гарантирует битовую идентичность результатов
// в разных архитектурах.
package math
```

Каждый экспортируемый элемент должен быть задокументирован. Документирование кода не должно быть чем-то ограничено. Пользуйтесь всеми возможностями, чтобы убедиться, что оно поможет клиентам и мейнтейнерам понять назначение кода.

## ОШИБКА #16: НЕ ИСПОЛЬЗОВАТЬ ЛИНТЕРЫ

Линтер — это автоматический инструмент для анализа кода и отлова ошибок в нем.

Рассмотрим пример. В разделе, посвященном ошибке #1, мы обсуждали затенение переменных. Используя линтер `vet`, встроенный в набор инструментов Go, а также `shadow`, можно обнаружить затененные переменные:

```go
package main

import "fmt"

func main() {
    i := 0
    if true {
        i := 1 // Затененная переменная
        fmt.Println(i)
    }
    fmt.Println(i)
}
```

Как мы видим, `vet` сообщает, что переменная `i` в этом примере затенена. Использование соответствующих линтеров поможет сделать код более надежным и обнаружить потенциальные ошибки.

Взгляните на `golangci-lint` (https://github.com/golangci/golangci-lint). Это инструмент для анализа кода, который обеспечивает видимость поверх многих полезных линтеров и форматировщиков. Он позволяет запускать линтеры параллельно для повышения скорости анализа, что весьма удобно.

Линтеры и форматировщики — это мощные способы улучшить качество и согласованность кода. Уделите время тому, чтобы понять, какие из них следует использовать, и убедитесь, что автоматизировали их выполнение (например, с помощью CI или с Git pre-commit hook).

## ИТОГ:

* Избегайте затенения переменных во избежание ссылок на неправильную переменную или запутывания читателей кода.
* Избегайте использования вложенных уровней и выравнивайте «счастливый путь» по левому краю — это упрощает построение ментальной модели кода
* При инициализации переменных помните, что функции инициализации содержат в себе ограниченные возможности по обработке ошибок, что усложняет обработку состояний и тестирование. В большинстве случаев инициализации следует обрабатывать как специальные функции.
* Принудительное использование геттеров и сеттеров не является в Go идиоматическим. Правильный подход заключается в том, чтобы быть прагматичным и находить должный баланс между эффективностью и следованием определенным идиомам.
* Абстракции следует «открывать», а не создавать. Для предотвращения излишней сложности создавайте интерфейс только тогда, когда он действительно нужен, а не тогда, когда вы лишь предполагаете, что он может понадобиться в будущем, либо если можете доказать, что абстракция допустима.
* Размещение интерфейсов на стороне потребителя позволяет избежать излишних абстракций.
* Чтобы избавиться от ограничений с точки зрения гибкости, в большинстве случаев функции должны возвращать не интерфейсы, а конкретные реализации. И наоборот, функции должны принимать интерфейсы всегда, когда это возможно.
* Используйте `any` только в том случае, если нужно принять или вернуть любой возможный тип, например `json.Marshal`. В противном случае `any` не несет значимой информации и может привести к проблемам при компиляции, позволяя вызывающей функции обращаться к методам с любым типом данных.
* Полагаясь на дженерики и параметры типа, можно избежать написания шаблонного кода для разделения элементов или поведения. Используйте параметры типа лишь тогда, когда видите конкретную необходимость в них. В противном случае они вводят ненужные абстракции и усложняют код.
* Использование встраивания типов также поможет избежать шаблонного кода. Но убедитесь, что это не приведет к проблемам с видимостью в тех случаях, когда некоторые поля должны оставаться скрытыми.
* Для подходящей обработки параметров в удобной для API манере используйте паттерн функциональных опций.
* Следование макету проекта может стать хорошим способом структурировать проект, особенно если в новом проекте вы стремитесь к соблюдению имеющихся соглашений для стандартизации.
* Именование — важнейшая часть проектирования приложений. Создание пакетов с именами `common`, `util` или `shared` не имеет ценности для читателя кода. Преобразуйте имена таких пакетов во что-то более осмысленное и конкретное.
* Чтобы избежать коллизий имен переменных и пакетов, приводящих к путанице или ошибкам, используйте уникальные имена для каждого из них. Если это невозможно, применяйте псевдоним импорта, изменяя квалификатор так, чтобы отличать имя пакета от имени переменной, или придумайте лучшие имена.
* Чтобы клиенты и мейнтейнеры проекта лучше понимали назначение кода, документируйте экспортированные элементы.
* Чтобы улучшить качество и внутреннюю согласованность кода, используйте линтеры и средства форматирования.
