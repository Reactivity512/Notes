# 100 ошибок Go и как их избежать

В книге представлены семь основных категорий ошибок, которые можно классифицировать как:
* баги;
* излишнюю сложность;
* плохую читаемость;
* неоптимальную или неидиоматическую организацию;
* отсутствие удобства в API;
* неоптимизированный код;
* недостаточную производительность.

## ОШИБКА #1: непреднамеренно затенять переменные

Область видимости переменной — это те места кода, в которых можно ссылаться на эту переменную, другими словами, та часть приложения, где действует привязка имени. В Go имя переменной, уже объявленное во внешней области видимости, может быть повторно объявлено во внутренней области видимости.
Такая ситуация называется затенением переменной и может приводить к распространенным ошибкам.

```go
var client *http.Client // Объявляется переменная client
if tracing {
    client, err := createClientWithTracing() // Создается HTTP-клиент со включенной трассировкой. (Переменная client затенена в этом блоке)
    if err != nil {
        return err
    }
    log.Println(client)
} else {
    client, err := createDefaultClient() // Создается HTTP-клиент по умолчанию. (Переменная client также затенена в этом блоке)
    if err != nil {
        return err
    }
    log.Println(client)
}
// Использование переменной client
```

В результате оказывается, что внешняя переменная всегда равна нулю.

Есть два варианта исправления:

```go
var client *http.Client
if tracing {
    c, err := createClientWithTracing() if err != nil  // Создается временная переменная c
    if err != nil {
        return err
    }
    client = c // Переменной client присваивается значение этой временной переменной
} else {
    // Та же логика
}
```

```go
var client *http.Client
var err error // Объявляется переменная err
if tracing {
    client, err = createClientWithTracing() // Используется оператор присваивания, чтобы напрямую присвоить переменной client значение, возвращаемое *http.Client
    if err != nil {
        return err
    }
} else {
    // Та же логика
}
```

Основное различие между ними заключается в том, что во втором варианте мы выполняем только одно присваивание, что можно считать более легким для чтения. Кроме того, со вторым вариантом можно объединить и реализовать обработку ошибок вне блоков операторов `if/else`, как показано в следующем примере:

```go
if tracing {
    client, err = createClientWithTracing()
} else {
    client, err = createDefaultClient()
}
if err != nil {
    // Типичная обработка ошибок
}
```

Затенение переменной происходит, когда ее имя повторно объявляется во внутренней области видимости, но мы видели, что эта практика чревата ошибками. Установка правила, запрещающего затененные переменные, зависит от личного вкуса. Иногда бывает удобно повторно использовать существующее имя, например `err`, для обозначения тех переменных, которые так или иначе связаны с ошибками. Но следует быть начеку, потому что теперь мы знаем, что можем столкнуться со сценарием, когда код компилируется, но переменная на самом деле получает значение, отличающееся от ожидаемого.


## ОШИБКА #2: лишний вложенный код

Важнейший аспект удобочитаемости — это фактор количества вложенных
уровней.
Предположим, что мы работаем над новым проектом и нужно понять, что делает следующая функция `join`:

```go
func join(s1, s2 string, max int) (string, error) {
    if s1 == "" {
        return "", errors.New("s1 is empty")
    } else {
        if s2 == "" {
            return "", errors.New("s2 is empty")
        } else {
            concat, err := concatenate(s1, s2) // Вызывает функцию concatenate для выполнения определенной конкатенации, но может возвращать ошибки
            if err != nil {
                return "", err
            } else {
                if len(concat) > max {
                    return concat[:max], nil
                } else {
                    return concat, nil
                }
            }
        }
    }
}

func concatenate(s1 string, s2 string) (string, error) {
    // ...
}
```

Эта функция `join` объединяет две строки и возвращает подстроку, если длина больше максимальной. Кроме того, она обрабатывает проверки `s1` и `s2` и проверяет, возвращает ли вызов `concatenate` ошибку.
С точки зрения реализации функциональности все сделано правильно. Но выстраивание ментальной модели, охватывающей все различные случаи, скорее всего, будет непростой задачей. Почему? Из-за количества вложенных уровней.

Посмотрим на код, выполняющий ту же функцию, но реализованный по другому:

```go
func join(s1, s2 string, max int) (string, error) {
    if s1 == "" {
        return "", errors.New("s1 is empty")
    }
    if s2 == "" {
        return "", errors.New("s2 is empty")
	}
    concat, err := concatenate(s1, s2)
    if err != nil {
        return "", err
    }
    if len(concat) > max {
        return concat[:max], nil
    }
    return concat, nil
}

func concatenate(s1 string, s2 string) (string, error) {
    // ...
}
```

В этой новой версии кода требует меньше когнитивного напряжения, хотя код выполняет тоже самое, что и раньше. Здесь есть только два вложенных уровня.

Как правило, чем больше вложенных уровней требует функция, тем сложнее ее читать и понимать.

* Когда происходит возврат из блока `if`, следует во всех случаях опускать блок `else`. Например, мы не должны писать:

```go
if foo() {
    // ...
    return true
} else {
    // ...
}
```

Вместо этого следует опустить блок `else`, как показано здесь:

```go
if foo() {
    // ...
    return true
}
// ...
```

Во второй версии этого фрагмента код, находившийся в блоке `else`, перемещается на верхний уровень, что упрощает его чтение.

* Можно следовать этой логике в случае с путем, не являющимся «счастливым»:

```go 
if s != "" {
    // ...
} else {
    return errors.New("empty string")
}
```

Нужно изменить это условие так:

```go
if s == "" { // Изменение условия в if
    return errors.New("empty string")
}
// ...
```

Эту версию кода читать легче, потому что она показывает «счастливый» путь на левом краю и уменьшает количество блоков.

## ОШИБКА #3: неправильно использовать функцию инициализации

Иногда в приложениях Go неправильно используются функции инициализации.
Потенциальные последствия — трудности в отслеживании и обработке ошибок или сложный в понимании код.
Функция инициализации (`init`) — это функция, используемая для инициализации состояния приложения. Она не имеет аргументов и не возвращает результата. Когда пакет инициализируется, оцениваются все объявления констант и переменных в пакете. Затем выполняются функции инициализации.

```go
package main

import "fmt"

var a = func() int {
    fmt.Println("var") // Исполняется в первую очередь
    return 0
}()

func init() {
    fmt.Println("init") // Исполняется во вторую очередь
}

func main() {
    fmt.Println("main") // Исполняется в последнюю очередь
}
```

В следующем примере мы определяем два пакета — *main* и *redis*, где *main* зависит от *redis*.

`main.go`:

```go
package main

import (
    "fmt"
    "redis"
)

func init() {
    // ...
}

func main() {
    err := redis.Store("foo", "bar") // Указание на зависимость от пакета redis
    // ...
}
```

`redis.go`:

```go
package redis

// imports

func init() {
    // ...
}

func Store(key, value string) error {
    // ...
}
```

Поскольку *main* зависит от *redis*, сначала выполняется функция инициализации в пакете *redis*, затем — в основном пакете, а затем сама функция *main*.
Мы можем определить несколько функций инициализации `init` для каждого пакета. В таком случае последовательность выполнения функции инициализации внутри пакета задается алфавитным порядком исходных файлов. Например, если пакет содержит файл `a.go` и файл `b.go` и в обоих содержится функция инициализации, то первой выполняется та из них, что находится в `a.go`.

Не следует слишком сильно полагаться на такой порядок выполнения функций инициализации внутри пакета — это может быть опасно, ведь исходные файлы могут быть переименованы и это может повлиять на порядок выполнения функций `init`.

Мы также можем определить несколько функций `init` в одном исходном файле.
Такой код вполне допустим:

```go 
func init() {
	fmt.Println("init 1") // Первая функция init
}
func init() {
	fmt.Println("init 2") //Вторая функция init
}
func main() {
}
```

Функцию `init` нельзя вызвать напрямую, как в следующем примере:

```go
package main

func init() {}

func main() {
    init()
}

// go build .
// ./main.go:6:2: undefined: init
```

## ОШИБКА #4: злоупотреблять геттерами и сеттерами

В Go нет автоматической поддержки геттеров и сеттеров, как в других языках. Не считается обязательным или идиоматичным использование геттеров и сеттеров для доступа к полям структуры (struct).

Если мы их используем, например с полем `Balance`, мы должны следовать вот этим соглашениям о наименованиях:

* Метод геттера должен называться `Balance` (а не `GetBalance`).
* Метод сеттера должен называться `SetBalance`.

```go
currentBalance := customer.Balance() // Геттер
if currentBalance < 0 {
    customer.SetBalance(0) // Сеттер
}
```

Не следует перегружать код геттерами и сеттерами в структурах, если они не приносят никакой пользы. Будьте прагматиками и ищите баланс между эффективностью и соблюдением идиом, которые в других парадигмах программирования иногда считаются непререкаемыми.

Go — уникальный язык, созданный исходя из целей достижения многих характеристик, включая простоту. Но если возникнет потребность в геттерах и сеттерах или эта потребность предвидится в будущем, гарантируя при этом «совместимость вперед», в их использовании нет ничего плохого.

## ОШИБКА #5: загрязнять интерфейсы

Загрязнение интерфейса (interface pollution) — это перегруз кода ненужными абстракциями, затрудняющими понимание. Это распространенная ошибка разработчиков, переходящих на Go с других языков и имеющих другие привычки.

*Чем больше интерфейс, тем слабее абстракция.*
*Роб Пайк (Rob Pike)*

Рассмотрим три конкретных сценария, когда считается, что интерфейсы могут быть полезны.

* **Общее поведение**
Первый вариант — это использование интерфейсов, когда несколько типов реализуют общее поведение. Тогда можно заключить это поведение внутрь какого-то интерфейса. Например в пакете `sort` добавляется следующий интерфейс:
    ```go
    type Interface interface {
        Len() int // Число элементов
        Less(i, j int) bool // Сравнение двух элементов
        Swap(i, j int) // Перестановка двух элементов
    }
    ```


* **Снижение связанности (decoupling)**
Еще один важный сценарий — отделение кода от его реализации. Если мы полагаемся на абстракцию вместо конкретной реализации, сама реализация может быть заменена на другую без необходимости менять код. Это и есть принцип подстановки Лисков (буква L в принципах SOLID Роберта Мартина).
Одно из преимуществ снижения связанности может относиться к юнит-тестам.
    ```go
    type CustomerService struct {
        store mysql.Store // Зависит от конкретного способа реализации
    }
    func (cs CustomerService) CreateNewCustomer(id string) error {
        customer := Customer{id: id}
        return cs.store.StoreCustomer(customer)
    }
    ```
    Поскольку `customerService` использует реальную реализацию для хранения `Customer`, нужно протестировать его с помощью интеграционных тестов, что требует запуска экземпляра MySQ.
    Для большей гибкости нужно отвязать `CustomerService` от фактической реализации. Сделать это можно через интерфейс:
    ```go
    type customerStorer interface { // Создается абстракция хранилища
        StoreCustomer(Customer) error
    }

    type CustomerService struct { // Отвязывает CustomerService от фактической реализации
        storer customerStorer
    }

    
    func (cs CustomerService) CreateNewCustomer(id string) error {
        customer := Customer{id: id}
        return cs.storer.StoreCustomer(customer)
    }
    ```

* **Ограничение поведения**
Представим, что мы реализуем пользовательский конфигурационный пакет для работы с динамической конфигурацией. Мы создаем специальный контейнер для конфигураций `int` с помощью структуры `IntConfig`, в которой определены два метода: `Get` и `Set`.
    ```go
    type IntConfig struct {
        // ...
    }
    func (c *IntConfig) Get() int {
        // Получить конфигурацию
    }
    func (c *IntConfig) Set(value int) {
        // Обновить конфигурацию
    }
    ```
    Теперь предположим, что мы получили `IntConfig`, который содержит в себе определенную конфигурацию, например какое-то пороговое значение. Но в нашем коде нас интересует только получение значения этой конфигурации, и мы хотим предотвратить его обновление. Как мы можем обеспечить, чтобы семантически эта конфигурация была доступна только для чтения, если мы не хотим изменять пакет конфигурации? Ответ: создав абстракцию, которая ограничивает поведение только получением значения конфигурации:
    ```go
    type intConfigGetter interface {
        Get() int
    }
    ```

Интерфейсы полезны для создания абстракций. И главное предостережение при знакомстве программиста с абстракциями — это помнить, что абстракции нужно открывать, а не создавать. Это означает, что мы не должны начинать создавать абстракции в коде, если для этого нет веской причины. Нужно не конструировать интерфейсы, а ждать возникновения конкретной потребности в них.
Следует быть очень осторожными при создании абстракций в коде: их следует обнаруживать, а не создавать. Для разработчиков характерно чрезмерно усложнять код в попытках угадать идеальный уровень абстракции. Этого следует избегать, поскольку в большинстве случаев в результате код «загрязняется» ненужными абстракциями и становится сложным для чтения.

## ОШИБКА #6: интерфейсы на стороне производителя

Go-разработчики часто неправильно понимают другой вопрос: где должен жить интерфейс?
Часто можно увидеть, как разработчики создают интерфейсы на стороне производителя наряду с конкретной реализацией. Этот программный дизайн привычен для разработчиков, имеющих опыт работы с C # или с Java. Но в Go в большинстве случаев так делать не следует.

* *Сторона производителя (Producer)* — интерфейс, определенный в том же пакете, что и конкретная реализация.
* *Сторона потребителя (Consumer)* — интерфейс, определенный во внешнем пакете, где он используется.

Интерфейсы в Go реализованы неявно, что обычно меняет правила игры по сравнению с языками с явной реализацией. В большинстве случаев подход, которому стоит следовать, аналогичен тому, что мы описали в предыдущем разделе: абстракции следует открывать, а не создавать. Это означает, что производитель не должен навязывать определенную абстракцию всем потребителям. Вместо этого потребитель должен решить, нужна ли ему какая-либо форма абстракции, а затем определить наилучший уровень абстракции для своих нужд.

Пример: создадим специальный пакет для хранения и извлечения данных о потребителях. Мы решаем, что все вызовы в том же пакете должны проходить через следующий интерфейс:

```go
package store

type CustomerStorage interface {
    StoreCustomer(customer Customer) error
    GetCustomer(id string) (Customer, error)
    UpdateCustomer(customer Customer) error
    GetAllCustomers() ([]Customer, error)
    GetCustomersWithoutContract() ([]Customer, error)
    GetCustomersWithNegativeBalance() ([]Customer, error)
}
```

Можно подумать, что есть веские причины для создания этого интерфейса и предоставления доступа к нему на стороне производителя. Возможно, это
хороший способ отвязать код потребителя от фактической реализации, но в Go это не лучшая практика. Интерфейсы в Go реализованы неявно, что обычно меняет правила игры по сравнению с языками с явной реализацией.

*Абстракции следует открывать, а не создавать* - Это означает, что производитель не должен навязывать определенную абстракцию всем потребителям. Вместо этого потребитель должен решить, нужна ли ему какая-либо форма абстракции, а затем определить наилучший уровень абстракции для своих нужд.
Возможно, другой потребитель захочет отвязать свой код, но его интересует только метод `GetAllCustomers`. Тогда он может создать интерфейс только одним методом, ссылаясь на структуру `Customer` из внешнего пакета:

```go
package client

type customersGetter interface {
    GetAllCustomers() ([]store.Customer, error)
}
```

Суть состоит в том, что пакет `client` теперь может определить для своих нужд наиболее точную абстракцию (в этом примере есть только один метод). Это связано с концепцией принципа разделения интерфейса (I — ISP — в SOLID), которая гласит, что ни один потребитель не должен зависеть от методов, которые он не использует. И в этом случае лучший подход — разместить конкретную реализацию на стороне производителя, дать к ней доступ и позволить потребителю решить, как ее использовать и нужна ли вообще здесь абстракция.

Для полноты изложения отметим, что подход интерфейсов на стороне про- изводителя иногда используется в стандартной библиотеке. Например, пакет `encoding` определяет интерфейсы, реализованные другими субпакетами, такими как `encoding/json` или `encoding/binary`. Является ли пакет encoding неверным с этой точки зрения? Точно нет. В этом случае абстракции, определенные в пакете `encoding`, используются во всей стандартной библиотеке, и разработчики языка знали, что предварительное создание этих абстракций полезно.
В большинстве случаев интерфейс должен жить на стороне потребителя. Но в определенных контекстах можно сделать его на стороне производителя.

## ОШИБКА #7: возврат интерфейсов

При разработке сигнатуры функции может потребоваться вернуть либо интерфейс, либо конкретную реализацию. Возврат интерфейса во многих случаях в Go считается плохой практикой.

В пакете `store` мы определяем структуру `InMemoryStore`, реализующую интерфейс `Store`. Мы также создаем функцию `NewInMemoryStore` для возврата интерфейса `Store`. При таком дизайне есть зависимость пакета реализации от пакета потребителя, и это может показаться странным. Например, пакет `client` больше не может вызывать функцию `NewInMemoryStore`, в противном случае возникла бы циклическая зависимость. Возможным решением может быть вызов этой функции из другого пакета и внедрение реализации `Store` в `client`.
Что произойдет, если структуру `InMemoryStore` будет использовать другой потребитель? Тогда, возможно, захотелось бы переместить интерфейс `Store` в другой пакет или обратно в пакет реализации, но мы уже обсуждали, почему во многих случаях это плохая идея.
Возврат интерфейса, как правило, ограничивает гибкость, поскольку мы за-
ставляем всех потребителей использовать один конкретный тип абстракции.

В Go лучше использовать:

* возврат структур вместо интерфейсов;
* допущение использования интерфейсов, если это возможно.

Конечно, есть и исключения. Разработчики знают, что правила никогда не выполняются на 100 %. Самое важное из них касается типа `error` — интерфейса, возвращаемого многими функциями.

Если мы четко знаем (а не просто предполагаем), что абстракция будет полезна для потребителей, то можем подумать о возврате интерфейса. В противном случае мы не должны навязывать использование абстракций; необходимость их использования должна быть «обнаружена» клиентами. Если клиенту по какой-либо причине нужно абстрагировать реализацию, он все равно сможет сделать это на клиентской стороне.

## ОШИБКА #8: any не говорит ни о чем

В Go тип интерфейса, который определяет нулевые методы, известен как пустой интерфейс, `interface{}`. В Go 1.18 предварительно объявленный тип `any` стал чем-то вроде псевдонима для пустого интерфейса, поэтому во всех случаях `interface{}` может быть заменен на `any`. Во многих случаях `any` можно считать чрезмерным обобщением.

```go
var i any

i = 42 // Тип int
i = "foo" // Тип string
i = struct { // Структура
    s string
}{
   s: "bar",
}
i = f // Функция
```

При присвоении значению типа `any` мы теряем всю информацию о типе, что требует подтверждения типа (type assertion), чтобы получить что-либо полезное из переменной i.

Посмотрим пример, где использование `any` не совсем точно:

```go
package store

type Customer struct{
    // какой-то код
}
type Contract struct{
    // какой-то код
}

type Store struct{}

func (s *Store) Get(id string) (any, error) { // Возвращает any
    // ...
}
func (s *Store) Set(id string, v any) error { // Принимает any
    // ...
}
```

Хотя в коде `Store` нет ничего ошибочного с точки зрения компиляции, следует остановиться и подумать о сигнатурах методов. Поскольку мы принимаем и возвращаем аргументы `any`, методам не хватает выразительности. Если другим разработчикам потребуется использовать структуру `Store`, им придется покопаться в документации или в коде, чтобы понять, как использовать эти методы. Следовательно, принятие или возврат типа `any` не передает значимой информации.
Следует избегать типа `any` и делать сигнатуры максимально явными. Что касается нашего примера, это может означать дублирование методов *Get*
и *Set* для каждого типа:

```go
func (s *Store) GetContract(id string) (Contract, error) {
    // ...
}
func (s *Store) SetContract(id string, contract Contract) error {
    // ...
}
func (s *Store) GetCustomer(id string) (Customer, error) {
    // ...
}
func (s *Store) SetCustomer(id string, customer Customer) error {
    // ...
}
```

Здесь методы достаточно выразительны, что снижает риск непонимания. Наличие большего количества методов не всегда проблема, поскольку клиенты также могут создавать свои собственные абстракции с помощью какого-либо интерфейса.

В каких случаи `any` полезен? Посмотрим на стандартную библиотеку и два примера, где функции или методы принимают аргументы `any`. Первый пример
находится в пакете `encoding/json`. Поскольку мы можем маршалировать любой
тип, функция `Marshal` принимает аргумент `any`

```go
func Marshal(v any) ([]byte, error) {
    // ...
}
```

Другой пример можно найти в пакете database/sql:

```go
func (c *Conn) QueryContext(ctx context.Context, query string, args ...any) (*Rows, error) {
    // ...
}
```

`any` может быть полезен, если есть реальная необходимость принять или вернуть любой возможный тип, в общем, мы должны любой ценой избегать чрезмерного обобщения своего кода. Возможно, иногда небольшое дублирование кода будет приветствоваться, если это улучшает другие аспекты, например выразительность.

## ОШИБКА #9: путаница в использовании дженериков

В Go 1.18 в язык добавлены дженерики. Это позволяет писать код с типами, которые можно указать позже и создавать при необходимости. При этом может возникнуть путаница, когда использовать дженерики.

**Когда полезно использовать дженерики:**

* *Структуры данных.* Мы можем использовать дженерики, чтобы выделить тип элемента, например, если реализуем двоичное дерево, связанный список или кучу.

* *Функции, работающие со срезами, картами и каналами любого типа.* Например, функция объединения двух каналов будет работать с любым типом канала. Следовательно, можно использовать параметры типа, чтобы определить тип канала:

```go
func merge[T any](ch1, ch2 <-chan T) <-chan T {
    // ...
}
```

* *Факторизация поведения вместо типов.* Пакет `sort`, например, содержит интерфейс `sort.Interface`, включающий в себя три метода:

```go
type Interface interface {
    Len() int
    Less(i, j int) bool
    Swap(i, j int)
}
```

Этот интерфейс используется различными функциями: `sort.Ints` или `sort.Float64s`. Используя параметры типа, можно выделить действие по сортировке:

```go
type SliceFn[T any] struct { // Используется параметр типа
    S       []T
    Compare func(T, T) bool // Сравниваются два элемента T
}

func (s SliceFn[T]) Len() int           { return len(s.S) }
func (s SliceFn[T]) Less(i, j int) bool { return s.Compare(s.S[i], s.S[j]) }
func (s SliceFn[T]) Swap(i, j int)      { s.S[i], s.S[j] = s.S[j], s.S[i] }
```

Поскольку структура `SliceFn` реализует `sort.Interface`, можно отсортировать предоставленный срез с помощью функции `sort.Sort(sort.Interface)`:
```go
s := SliceFn[int]{
    S: []int{3, 2, 1},
    Compare: func(a, b int) bool {
        return a < b
    },
}
sort.Sort(s)
fmt.Println(s.S)
```

**Использовать дженерики не рекомендуется:**

* *При вызове метода с аргументом типа.* Рассмотрим функцию, которая получает на входе `io.Writer` и вызывает метод `Write`:

```go
func foo[T io.Writer](w T) {
    b := getBytes()
    _, _ = w.Write(b)
}
```

В этом случае использование дженериков не принесет коду никакой пользы. Нужно напрямую сделать значение аргумента `w` равным `io.Writer`.

* *Когда это делает код более сложным.* Дженерики никогда не бывают обязательными, и разработчики Go прекрасно жили без них более десяти лет. Если мы используем дженерики — универсальные функции или структуры — и обнаруживаем, что это не делает код более понятным, то следует пересмотреть свое решение для конкретного случая.

Дженерики вводят некоторую форму абстракции, а нам нужно помнить, что ненужные абстракции только усложняют работу.
Не будем загрязнять код ненужными абстракциями и сосредоточимся на решении конкретных задач. Это означает, что использовать параметры типа не нужно, если на то нет оснований. Когда надо будет писать шаблонный код, и только тогда рассмотрите возможность использования дженериков.

## ОШИБКА #10: не знать о возможных проблемах со встраиванием типов

При создании структуры Go позволяет встраивать типы. Но иногда это может привести к неожиданному поведению, если мы не понимаем всех последствий такого встраивания.
В Go поле структуры называется встроенным, если оно объявлено без имени.
Например:

```go
type Foo struct {
    Bar // Встроенное поле
}

type Bar struct {
    Baz int
}
```

В структуре `Foo` тип `Bar` объявлен без связанного имени, следовательно, это встроенное поле. Мы используем встраивание для продвижения (*promote*) полей и методов встроенного типа. Поскольку `Bar` содержит поле `Baz`, это поле продвигается в `Foo`. Таким образом, `Baz` становится доступным из `Foo`. Доступ к `Baz` возможен по двум разным путям:

```go
foo := Foo{}

foo.Baz = 42
// или
foo.Bar.Baz = 42
```

Давайте рассмотрим пример неправильного их использования. Ниже мы реализуем `struct`, который хранит некоторые данные в памяти, и хотим защитить его от конкурентного доступа с помощью мьютекса:

```go
type InMem struct {
    sync.Mutex // Встроенное поле
    m map[string]int
}
func New() *InMem {
    return &InMem{m: make(map[string]int)}
}
```

Мы решили сделать карту неэкспортируемой, чтобы клиенты не могли взаимодействовать с ней напрямую, а только через экспортированные методы. Между тем поле мьютекс встроено. Поэтому мы можем реализовать метод `Get` так:

```go
func (i *InMem) Get(key string) (int, bool) {
    i.Lock() // Прямой доступ к методу Lock
    v, contains := i.m[key]
    i.Unlock() // То же самое относительно метода Unlock
    return v, contains
}
```

Этот мьютекс встроен, мы можем напрямую обращаться к методам `Lock` и `Unlock` из получателя i. 

Поскольку `sync.Mutex` — это встроенный тип, методы `Lock` и `Unlock` будут продвигаться и мы можем напрямую обращаться к этим методам из получателя i. Поэтому оба метода станут видимыми и для внешних потребителей, использующих `InMem`:

```go
m := inmem.New()
m.Lock() // ??
```

Такое продвижение, вероятно, — нежелательный эффект. В большинстве случаев мьютекс — это то, что мы хотим инкапсулировать в структуру и сделать невидимым для внешних клиентов. Поэтому здесь не следует делать его встроенным полем:

```go
type InMem struct {
    mu sync.Mutex // Указывает, что поле sync.Mutex не является встроенным
    m map[string]int 
}
```

Поскольку мьютекс не встроен и не экспортируется, доступ к нему внешних
потребителей закрыт.

Рассмотрим другой пример, где встраивание можно считать правильным подходом. Нужно написать собственный логгер, содержащий `io.WriteCloser` и делающий доступными два метода: `Write` и `Close`. Если бы `io.WriteCloser` не был встроенным, код был бы таким:

```go
type Logger struct {
    writeCloser io.WriteCloser
}
func (l Logger) Write(p []byte) (int, error) {
    return l.writeCloser.Write(p) // Перенаправляет вызов на writeCloser
}
func (l Logger) Close() error {
    return l.writeCloser.Close() // Перенаправляет вызов на writeCloser
}
func main() {
    l := Logger{writeCloser: os.Stdout}
    _, _ = l.Write([]byte("foo"))
    _ = l.Close()
}
```

`Logger` должен был предоставить доступ как к методу `Write`, так и к методу `Close`, которые бы только перенаправляли вызов на `io.WriteCloser`. Но если теперь сделать поле встроенным, то можно удалить эти методы перенаправления:

```go
type Logger struct {
    io.WriteCloser // io.Writer делается встроенным
}
```

Логгер остается для клиентов тем же самым, с двумя экспортированными методами `Write` и `Close`. Но при этом становится возможным не расписывать эти дополнительные методы для простой переадресации вызова.

Какой следует сделать вывод о встраивании типов? Прежде всего оно редко бывает по-настоящему нужно, а это значит, что независимо от сути конкретной задачи мы, скорее всего, сможем решить ее и без применения встраивания типов. В основном оно используется для удобства: для продвижения поведения.

Если же мы все-таки решаем использовать встраивание типов, то нужно помнить о двух основных ограничениях:

* Не следует его использовать исключительно как синтаксический сахар — для упрощения доступа к полю (например, `Foo.Baz()` вместо `Foo.Bar.Baz()`). Если это единственная причина, то вместо встраивания внутреннего типа лучше использовать поле.

* Оно не должно продвигать данные (поля) или поведение (методы), которые мы хотим скрыть от посторонних глаз: например, если оно позволяет клиентам получить доступ к поведению блокировки, которое должно оставаться приватным для структуры.

