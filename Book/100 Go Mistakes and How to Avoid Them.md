# 100 ошибок Go и как их избежать

В книге представлены семь основных категорий ошибок, которые можно классифицировать как:
* баги;
* излишнюю сложность;
* плохую читаемость;
* неоптимальную или неидиоматическую организацию;
* отсутствие удобства в API;
* неоптимизированный код;
* недостаточную производительность.

# Организация кода и проекта

## ОШИБКА #1: НЕПРЕДНАМЕРЕННО ЗАТЕНЯТЬ ПЕРЕМЕННЫЕ

Область видимости переменной — это те места кода, в которых можно ссылаться на эту переменную, другими словами, та часть приложения, где действует привязка имени. В Go имя переменной, уже объявленное во внешней области видимости, может быть повторно объявлено во внутренней области видимости.
Такая ситуация называется затенением переменной и может приводить к распространенным ошибкам.

```go
var client *http.Client // Объявляется переменная client
if tracing {
    client, err := createClientWithTracing() // Создается HTTP-клиент со включенной трассировкой. (Переменная client затенена в этом блоке)
    if err != nil {
        return err
    }
    log.Println(client)
} else {
    client, err := createDefaultClient() // Создается HTTP-клиент по умолчанию. (Переменная client также затенена в этом блоке)
    if err != nil {
        return err
    }
    log.Println(client)
}
// Использование переменной client
```

В результате оказывается, что внешняя переменная всегда равна нулю.

Есть два варианта исправления:

```go
var client *http.Client
if tracing {
    c, err := createClientWithTracing() if err != nil  // Создается временная переменная c
    if err != nil {
        return err
    }
    client = c // Переменной client присваивается значение этой временной переменной
} else {
    // Та же логика
}
```

```go
var client *http.Client
var err error // Объявляется переменная err
if tracing {
    client, err = createClientWithTracing() // Используется оператор присваивания, чтобы напрямую присвоить переменной client значение, возвращаемое *http.Client
    if err != nil {
        return err
    }
} else {
    // Та же логика
}
```

Основное различие между ними заключается в том, что во втором варианте мы выполняем только одно присваивание, что можно считать более легким для чтения. Кроме того, со вторым вариантом можно объединить и реализовать обработку ошибок вне блоков операторов `if/else`, как показано в следующем примере:

```go
if tracing {
    client, err = createClientWithTracing()
} else {
    client, err = createDefaultClient()
}
if err != nil {
    // Типичная обработка ошибок
}
```

Затенение переменной происходит, когда ее имя повторно объявляется во внутренней области видимости, но мы видели, что эта практика чревата ошибками. Установка правила, запрещающего затененные переменные, зависит от личного вкуса. Иногда бывает удобно повторно использовать существующее имя, например `err`, для обозначения тех переменных, которые так или иначе связаны с ошибками. Но следует быть начеку, потому что теперь мы знаем, что можем столкнуться со сценарием, когда код компилируется, но переменная на самом деле получает значение, отличающееся от ожидаемого.


## ОШИБКА #2: ЛИШНИЙ ВЛОЖЕННЫЙ КОД

Важнейший аспект удобочитаемости — это фактор количества вложенных
уровней.
Предположим, что мы работаем над новым проектом и нужно понять, что делает следующая функция `join`:

```go
func join(s1, s2 string, max int) (string, error) {
    if s1 == "" {
        return "", errors.New("s1 is empty")
    } else {
        if s2 == "" {
            return "", errors.New("s2 is empty")
        } else {
            concat, err := concatenate(s1, s2) // Вызывает функцию concatenate для выполнения определенной конкатенации, но может возвращать ошибки
            if err != nil {
                return "", err
            } else {
                if len(concat) > max {
                    return concat[:max], nil
                } else {
                    return concat, nil
                }
            }
        }
    }
}

func concatenate(s1 string, s2 string) (string, error) {
    // ...
}
```

Эта функция `join` объединяет две строки и возвращает подстроку, если длина больше максимальной. Кроме того, она обрабатывает проверки `s1` и `s2` и проверяет, возвращает ли вызов `concatenate` ошибку.
С точки зрения реализации функциональности все сделано правильно. Но выстраивание ментальной модели, охватывающей все различные случаи, скорее всего, будет непростой задачей. Почему? Из-за количества вложенных уровней.

Посмотрим на код, выполняющий ту же функцию, но реализованный по другому:

```go
func join(s1, s2 string, max int) (string, error) {
    if s1 == "" {
        return "", errors.New("s1 is empty")
    }
    if s2 == "" {
        return "", errors.New("s2 is empty")
	}
    concat, err := concatenate(s1, s2)
    if err != nil {
        return "", err
    }
    if len(concat) > max {
        return concat[:max], nil
    }
    return concat, nil
}

func concatenate(s1 string, s2 string) (string, error) {
    // ...
}
```

В этой новой версии кода требует меньше когнитивного напряжения, хотя код выполняет тоже самое, что и раньше. Здесь есть только два вложенных уровня.

Как правило, чем больше вложенных уровней требует функция, тем сложнее ее читать и понимать.

* Когда происходит возврат из блока `if`, следует во всех случаях опускать блок `else`. Например, мы не должны писать:

```go
if foo() {
    // ...
    return true
} else {
    // ...
}
```

Вместо этого следует опустить блок `else`, как показано здесь:

```go
if foo() {
    // ...
    return true
}
// ...
```

Во второй версии этого фрагмента код, находившийся в блоке `else`, перемещается на верхний уровень, что упрощает его чтение.

* Можно следовать этой логике в случае с путем, не являющимся «счастливым»:

```go 
if s != "" {
    // ...
} else {
    return errors.New("empty string")
}
```

Нужно изменить это условие так:

```go
if s == "" { // Изменение условия в if
    return errors.New("empty string")
}
// ...
```

Эту версию кода читать легче, потому что она показывает «счастливый» путь на левом краю и уменьшает количество блоков.

## ОШИБКА #3: НЕПРАВИЛЬНО ИСПОЛЬЗОВАТЬ ФУНКЦИЮ ИНИЦИАЛИЗАЦИИ

Иногда в приложениях Go неправильно используются функции инициализации.
Потенциальные последствия — трудности в отслеживании и обработке ошибок или сложный в понимании код.
Функция инициализации (`init`) — это функция, используемая для инициализации состояния приложения. Она не имеет аргументов и не возвращает результата. 

Функция `init()` — это специальная функция в Go, которая:
* Выполняется автоматически перед входом в main(),
* Может быть определена несколько раз в одном пакете (все будут вызваны),
* Выполняется после инициализации переменных уровня пакета, но до main(),
* Используется для настройки состояния пакета.

```go
package main

import "fmt"

var a = func() int {
    fmt.Println("var") // Исполняется в первую очередь
    return 0
}()

func init() {
    fmt.Println("init") // Исполняется во вторую очередь
}

func main() {
    fmt.Println("main") // Исполняется в последнюю очередь
}
```

Мы можем определить несколько функций инициализации `init` для каждого пакета. В таком случае последовательность выполнения функции инициализации внутри пакета задается алфавитным порядком исходных файлов. Например, если пакет содержит файл `a.go` и файл `b.go` и в обоих содержится функция инициализации, то первой выполняется та из них, что находится в `a.go`.

Не следует слишком сильно полагаться на такой порядок выполнения функций инициализации внутри пакета — это может быть опасно, ведь исходные файлы могут быть переименованы и это может повлиять на порядок выполнения функций `init`.

Мы также можем определить несколько функций `init` в одном исходном файле.
Такой код вполне допустим:

```go 
func init() {
	fmt.Println("init 1") // Первая функция init
}
func init() {
	fmt.Println("init 2") //Вторая функция init
}
func main() {
}
```

Функцию `init` нельзя вызвать напрямую, как в следующем примере:

```go
package main

func init() {}

func main() {
    init()
}

// go build .
// ./main.go:6:2: undefined: init
```

### Почему `init()` часто используется неправильно

Пример:
```go
var db *sql.DB

func init() {
    db = connectToDB() // ← инициализация
}
```

На первый взгляд — удобно. Но именно здесь и начинаются проблемы.

1. Скрытые побочные эффекты
Код внутри `init()` выполняется неявно. Читая `main()`, вы не видите, что где-то в импортированном пакете уже произошло подключение к БД, запись в лог, изменение глобального состояния и т.д. → Это нарушает принцип **явности**

2. Невозможность обработки ошибок
Функция `init()` не может возвращать ошибки. Если подключение к БД провалится — у вас только два варианта:
* Паниковать (`panic`) — аварийное завершение,
* Игнорировать ошибку — и получить `nil`-указатель позже.

Оба варианта **плохи**.

Пример плохого кода:
```go
func init() {
    db, err := sql.Open("postgres", "...")
    if err != nil {
        panic(err) // плохо: нельзя корректно завершить программу
    }
}
```

3. Затруднённое тестирование

При запуске тестов `init()` вызывается один раз при загрузке пакета. Это означает:
* Вы не можете переинициализировать состояние между тестами,
* Тесты становятся зависимыми от глобального состояния,
* Невозможно подменить реализацию (например, использовать in-memory DB вместо настоящей).

4. Порядок выполнения непредсказуем

Если у вас несколько `init()` в разных файлах одного пакета — порядок их выполнения определяется лексикографически по имени файла, а не логикой. Это легко приводит к багам.

5. Инициализация при импорте (side-effectful import)

Go позволяет импортировать пакет только ради его `init()`:
```go
import _ "myapp/db" // вызывает init(), чтобы зарегистрировать драйвер
```

Это иногда оправдано (например, `import _ "github.com/go-sql-driver/mysql"`), но часто становится источником магии.

### Когда `init()` допустим

1. Регистрация драйверов или форматов
```go
import "database/sql"
import _ "github.com/lib/pq" // регистрирует PostgreSQL драйвер через init()
```
Здесь `init()` используется только для регистрации, без побочных эффектов.

2. Инициализация чистых значений (без ошибок)
```go
var version string

func init() {
    version = buildVersion() // детерминированная функция без ошибок
}
```

Допустимо, если `buildVersion()` не может упасть и не зависит от внешнего мира.

3. Тестовые фикстуры (в `_test.go`)

Иногда в тестах используют `init()` для подготовки данных, но даже здесь лучше предпочесть `TestMain` или setup-функции.

### Как правильно инициализировать ресурсы

Вместо `init()` — используйте явные конструкторы или фабрики.

Плохо (с `init`):
```go
// storage/db.go
var DB *sql.DB

func init() {
    DB = mustConnect() // panic при ошибке
}
```

Хорошо (явная инициализация):
```go
// storage/db.go
type DB struct {
    conn *sql.DB
}

func NewDB(dsn string) (*DB, error) {
    conn, err := sql.Open("postgres", dsn)
    if err != nil {
        return nil, fmt.Errorf("failed to open DB: %w", err)
    }
    return &DB{conn: conn}, nil
}

// main.go
db, err := storage.NewDB(os.Getenv("DB_DSN"))
if err != nil {
    log.Fatal(err)
}
```

* Избегайте `init()` для инициализации ресурсов, зависящих от внешнего мира (БД, файлы, сеть).
* Не используйте `init()` для логики, которая может завершиться ошибкой.
* Предпочитайте явные конструкторы с возвратом ошибки.
* Если вы всё же используете `init()` — документируйте это и ограничьте его использование регистрацией или вычислением констант.
* Никогда не пишите бизнес-логику в `init()`.

`Если тебе нужно обработать ошибку — не клади код в init().`

В 95% случаев, где разработчики используют `init()`, достаточно обычной функции с возвратом ошибки.

## ОШИБКА #4: ЗЛОУПОТРЕБЛЯТЬ ГЕТТЕРАМИ И СЕТТЕРАМИ

В Go нет автоматической поддержки геттеров и сеттеров, как в других языках. Не считается обязательным или идиоматичным использование геттеров и сеттеров для доступа к полям структуры (struct).

Если мы их используем, например с полем `Balance`, мы должны следовать вот этим соглашениям о наименованиях:

* Метод геттера должен называться `Balance` (а не `GetBalance`).
* Метод сеттера должен называться `SetBalance`.

```go
currentBalance := customer.Balance() // Геттер
if currentBalance < 0 {
    customer.SetBalance(0) // Сеттер
}
```

Не следует перегружать код геттерами и сеттерами в структурах, если они не приносят никакой пользы. Будьте прагматиками и ищите баланс между эффективностью и соблюдением идиом, которые в других парадигмах программирования иногда считаются непререкаемыми.

Go — уникальный язык, созданный исходя из целей достижения многих характеристик, включая простоту. Но если возникнет потребность в геттерах и сеттерах или эта потребность предвидится в будущем, гарантируя при этом «совместимость вперед», в их использовании нет ничего плохого.

## ОШИБКА #5: ЗАГРЯЗНЯТЬ ИНТЕРФЕЙСЫ

Загрязнение интерфейса (interface pollution) — это перегруз кода ненужными абстракциями, затрудняющими понимание. Это распространенная ошибка разработчиков, переходящих на Go с других языков и имеющих другие привычки. Она тесно связана с принципами проектирования, особенно с Принципом разделения интерфейсов (ISP — Interface Segregation Principle) из SOLID.

*Чем больше интерфейс, тем слабее абстракция.*
*Роб Пайк (Rob Pike)*

Разработчики часто создают "жирные" интерфейсы — то есть интерфейсы с множеством методов, многие из которых не нужны конкретному потребителю. Это приводит к ненужным зависимостям, усложнению тестирования и нарушению гибкости.

Пример "загрязнённого" интерфейса:
```go
type OrderService interface {
    CreateOrder(order Order) error
    GetOrder(id string) (Order, error)
    CancelOrder(id string) error
    RefundOrder(id string) error
    ExportOrdersToCSV() (string, error)
    SendOrderConfirmationEmail(id string) error
    CalculateTax(order Order) float64
}
```

Теперь представь, что у тебя есть хендлер для создания заказа:
```go
type CreateOrderHandler struct {
    service OrderService // зависит от всего интерфейса
}

func (h *CreateOrderHandler) Handle(order Order) error {
    return h.service.CreateOrder(order) // использует ТОЛЬКО один метод!
}
```

Хендлер зависит от всех 7 методов, хотя ему нужен только один. Это:
* Нарушает **ISP**,
* Усложняет моки в тестах (приходится реализовывать все методы),
* Создаёт ложную связанность: если изменится `ExportOrdersToCSV`, это может повлиять на сборку `CreateOrderHandler`, даже если он его не использует.


Как избежать загрязнения интерфейсов:

1. Создавай минимальные интерфейсы — по одному или нескольким методам

Go поощряет маленькие интерфейсы. Самый известный пример — `io.Reader` и `io.Writer`:
```go
type Reader interface {
    Read(p []byte) (n int, err error)
}

type Writer interface {
    Write(p [] byte) (n int, err error)
}
```

Они делают ровно одну вещь.

2. Определяй интерфейсы на стороне потребителя (Ошибка #6)

Потребитель сам решает, какие методы ему нужны:
```go
// Внутри пакета handler
type orderCreator interface {
    CreateOrder(Order) error
}

type CreateOrderHandler struct {
    service orderCreator // ← только то, что нужно
}
```

* Тестирование проще: мок должен реализовать только `CreateOrder`,
* Изменения в других методах (`RefundOrder`, `ExportOrdersToCSV`) не влияют на этот хендлер,
* Код стал более устойчивым к изменениям.

3. Комбинируй интерфейсы при необходимости

Если компоненту действительно нужны два метода — создай интерфейс из двух:
```go
type orderManager interface {
    CreateOrder(Order) error
    CancelOrder(string) error
}
```

Или даже комбинируй через встраивание (embedding):
```go
type OrderCreator interface {
    CreateOrder(Order) error
}

type OrderCanceller interface {
    CancelOrder(string) error
}

type OrderManager interface {
    OrderCreator
    OrderCanceller
}
```

Но встраивай только тогда, когда это действительно нужно — не ради "удобства".

### Gризнаки загрязнённого интерфейса

|Признак|Почему это плохо|
|--|--|
|Интерфейс называется `XService` и содержит 10+ методов|Он делает слишком много|
|В тестах приходится реализовывать методы, которые не используются|Нарушение **ISP**|
|Изменение одного метода ломает несвязанные компоненты|Слабая модульность|
|Интерфейс определён в том же пакете, что и реализация|Часто ведёт к "жирным" контрактам|

Многие разработчики делают так:
`«У меня есть структура OrderService с 8 методами → значит, интерфейс должен содержать все 8».`
Это ошибка.

Правильно:
`«У меня есть потребитель, которому нужны методы A и B → значит, я создаю интерфейс с A и B».`

Реализация (`*OrderService`) может иметь 20 методов — но потребитель видит только то, что ему нужно.

**Итог:**
* Делай интерфейсы маленькими — идеально 1–3 метода.
* Определяй их там, где они используются (consumer-side).
* Не копируй методы реализации в интерфейс "на всякий случай".
* Следуй принципу: "клиент не должен зависеть от того, чем он не пользуется".
* Если интерфейс большой — разбей его на несколько узкоспециализированных.

Рассмотрим три конкретных сценария, когда считается, что интерфейсы могут быть полезны.

* **Общее поведение**
Первый вариант — это использование интерфейсов, когда несколько типов реализуют общее поведение. Тогда можно заключить это поведение внутрь какого-то интерфейса. Например в пакете `sort` добавляется следующий интерфейс:
    ```go
    type Interface interface {
        Len() int // Число элементов
        Less(i, j int) bool // Сравнение двух элементов
        Swap(i, j int) // Перестановка двух элементов
    }
    ```


* **Снижение связанности (decoupling)**
Еще один важный сценарий — отделение кода от его реализации. Если мы полагаемся на абстракцию вместо конкретной реализации, сама реализация может быть заменена на другую без необходимости менять код. Это и есть принцип подстановки Лисков (буква L в принципах SOLID Роберта Мартина).
Одно из преимуществ снижения связанности может относиться к юнит-тестам.
    ```go
    type CustomerService struct {
        store mysql.Store // Зависит от конкретного способа реализации
    }
    func (cs CustomerService) CreateNewCustomer(id string) error {
        customer := Customer{id: id}
        return cs.store.StoreCustomer(customer)
    }
    ```
    Поскольку `customerService` использует реальную реализацию для хранения `Customer`, нужно протестировать его с помощью интеграционных тестов, что требует запуска экземпляра MySQ.
    Для большей гибкости нужно отвязать `CustomerService` от фактической реализации. Сделать это можно через интерфейс:
    ```go
    type customerStorer interface { // Создается абстракция хранилища
        StoreCustomer(Customer) error
    }

    type CustomerService struct { // Отвязывает CustomerService от фактической реализации
        storer customerStorer
    }

    
    func (cs CustomerService) CreateNewCustomer(id string) error {
        customer := Customer{id: id}
        return cs.storer.StoreCustomer(customer)
    }
    ```

* **Ограничение поведения**
Представим, что мы реализуем пользовательский конфигурационный пакет для работы с динамической конфигурацией. Мы создаем специальный контейнер для конфигураций `int` с помощью структуры `IntConfig`, в которой определены два метода: `Get` и `Set`.
    ```go
    type IntConfig struct {
        // ...
    }
    func (c *IntConfig) Get() int {
        // Получить конфигурацию
    }
    func (c *IntConfig) Set(value int) {
        // Обновить конфигурацию
    }
    ```
    Теперь предположим, что мы получили `IntConfig`, который содержит в себе определенную конфигурацию, например какое-то пороговое значение. Но в нашем коде нас интересует только получение значения этой конфигурации, и мы хотим предотвратить его обновление. Как мы можем обеспечить, чтобы семантически эта конфигурация была доступна только для чтения, если мы не хотим изменять пакет конфигурации? Ответ: создав абстракцию, которая ограничивает поведение только получением значения конфигурации:
    ```go
    type intConfigGetter interface {
        Get() int
    }
    ```

Интерфейсы полезны для создания абстракций. И главное предостережение при знакомстве программиста с абстракциями — это помнить, что абстракции нужно открывать, а не создавать. Это означает, что мы не должны начинать создавать абстракции в коде, если для этого нет веской причины. Нужно не конструировать интерфейсы, а ждать возникновения конкретной потребности в них.
Следует быть очень осторожными при создании абстракций в коде: их следует обнаруживать, а не создавать. Для разработчиков характерно чрезмерно усложнять код в попытках угадать идеальный уровень абстракции. Этого следует избегать, поскольку в большинстве случаев в результате код «загрязняется» ненужными абстракциями и становится сложным для чтения.

## ОШИБКА #6: ИНТЕРФЕЙСЫ НА СТОРОНЕ ПРОИЗВОДИТЕЛЯ

Go-разработчики часто неправильно понимают другой вопрос: где должен жить интерфейс?
Часто можно увидеть, как разработчики создают интерфейсы на стороне производителя наряду с конкретной реализацией. Этот программный дизайн привычен для разработчиков, имеющих опыт работы с C # или с Java. Но в Go в большинстве случаев так делать не следует.

* *Сторона производителя (Producer)* — интерфейс, определенный в том же пакете, что и конкретная реализация.
* *Сторона потребителя (Consumer)* — интерфейс, определенный во внешнем пакете, где он используется.

Интерфейсы в Go реализованы неявно, что обычно меняет правила игры по сравнению с языками с явной реализацией. В большинстве случаев подход, которому стоит следовать, аналогичен тому, что мы описали в предыдущем разделе: абстракции следует открывать, а не создавать. Это означает, что производитель не должен навязывать определенную абстракцию всем потребителям. Вместо этого потребитель должен решить, нужна ли ему какая-либо форма абстракции, а затем определить наилучший уровень абстракции для своих нужд.

Пример: создадим специальный пакет для хранения и извлечения данных о потребителях. Мы решаем, что все вызовы в том же пакете должны проходить через следующий интерфейс:

```go
package store

type CustomerStorage interface {
    StoreCustomer(customer Customer) error
    GetCustomer(id string) (Customer, error)
    UpdateCustomer(customer Customer) error
    GetAllCustomers() ([]Customer, error)
    GetCustomersWithoutContract() ([]Customer, error)
    GetCustomersWithNegativeBalance() ([]Customer, error)
}
```

Можно подумать, что есть веские причины для создания этого интерфейса и предоставления доступа к нему на стороне производителя. Возможно, это
хороший способ отвязать код потребителя от фактической реализации, но в Go это не лучшая практика. Интерфейсы в Go реализованы неявно, что обычно меняет правила игры по сравнению с языками с явной реализацией.

*Абстракции следует открывать, а не создавать* - Это означает, что производитель не должен навязывать определенную абстракцию всем потребителям. Вместо этого потребитель должен решить, нужна ли ему какая-либо форма абстракции, а затем определить наилучший уровень абстракции для своих нужд.
Возможно, другой потребитель захочет отвязать свой код, но его интересует только метод `GetAllCustomers`. Тогда он может создать интерфейс только одним методом, ссылаясь на структуру `Customer` из внешнего пакета:

```go
package client

type customersGetter interface {
    GetAllCustomers() ([]store.Customer, error)
}
```

Суть состоит в том, что пакет `client` теперь может определить для своих нужд наиболее точную абстракцию (в этом примере есть только один метод). Это связано с концепцией принципа разделения интерфейса (I — ISP — в SOLID), которая гласит, что ни один потребитель не должен зависеть от методов, которые он не использует. И в этом случае лучший подход — разместить конкретную реализацию на стороне производителя, дать к ней доступ и позволить потребителю решить, как ее использовать и нужна ли вообще здесь абстракция.

Для полноты изложения отметим, что подход интерфейсов на стороне про- изводителя иногда используется в стандартной библиотеке. Например, пакет `encoding` определяет интерфейсы, реализованные другими субпакетами, такими как `encoding/json` или `encoding/binary`. Является ли пакет encoding неверным с этой точки зрения? Точно нет. В этом случае абстракции, определенные в пакете `encoding`, используются во всей стандартной библиотеке, и разработчики языка знали, что предварительное создание этих абстракций полезно.
В большинстве случаев интерфейс должен жить на стороне потребителя. Но в определенных контекстах можно сделать его на стороне производителя.

## ОШИБКА #7: ВОЗВРАТ ИНТЕРФЕЙСОВ

При разработке сигнатуры функции может потребоваться вернуть либо интерфейс, либо конкретную реализацию. Возврат интерфейса во многих случаях в Go считается плохой практикой.

В пакете `store` мы определяем структуру `InMemoryStore`, реализующую интерфейс `Store`. Мы также создаем функцию `NewInMemoryStore` для возврата интерфейса `Store`. При таком дизайне есть зависимость пакета реализации от пакета потребителя, и это может показаться странным. Например, пакет `client` больше не может вызывать функцию `NewInMemoryStore`, в противном случае возникла бы циклическая зависимость. Возможным решением может быть вызов этой функции из другого пакета и внедрение реализации `Store` в `client`.
Что произойдет, если структуру `InMemoryStore` будет использовать другой потребитель? Тогда, возможно, захотелось бы переместить интерфейс `Store` в другой пакет или обратно в пакет реализации, но мы уже обсуждали, почему во многих случаях это плохая идея.
Возврат интерфейса, как правило, ограничивает гибкость, поскольку мы за-
ставляем всех потребителей использовать один конкретный тип абстракции.

В Go лучше использовать:

* возврат структур вместо интерфейсов;
* допущение использования интерфейсов, если это возможно.

Конечно, есть и исключения. Разработчики знают, что правила никогда не выполняются на 100 %. Самое важное из них касается типа `error` — интерфейса, возвращаемого многими функциями.

Если мы четко знаем (а не просто предполагаем), что абстракция будет полезна для потребителей, то можем подумать о возврате интерфейса. В противном случае мы не должны навязывать использование абстракций; необходимость их использования должна быть «обнаружена» клиентами. Если клиенту по какой-либо причине нужно абстрагировать реализацию, он все равно сможет сделать это на клиентской стороне.

## ОШИБКА #8: ANY НЕ ГОВОРИТ НИ О ЧЕМ

В Go тип интерфейса, который определяет нулевые методы, известен как пустой интерфейс, `interface{}`. В Go 1.18 предварительно объявленный тип `any` стал чем-то вроде псевдонима для пустого интерфейса, поэтому во всех случаях `interface{}` может быть заменен на `any`. Во многих случаях `any` можно считать чрезмерным обобщением.

```go
var i any

i = 42 // Тип int
i = "foo" // Тип string
i = struct { // Структура
    s string
}{
   s: "bar",
}
i = f // Функция
```

При присвоении значению типа `any` мы теряем всю информацию о типе, что требует подтверждения типа (type assertion), чтобы получить что-либо полезное из переменной i.

Посмотрим пример, где использование `any` не совсем точно:

```go
package store

type Customer struct{
    // какой-то код
}
type Contract struct{
    // какой-то код
}

type Store struct{}

func (s *Store) Get(id string) (any, error) { // Возвращает any
    // ...
}
func (s *Store) Set(id string, v any) error { // Принимает any
    // ...
}
```

Хотя в коде `Store` нет ничего ошибочного с точки зрения компиляции, следует остановиться и подумать о сигнатурах методов. Поскольку мы принимаем и возвращаем аргументы `any`, методам не хватает выразительности. Если другим разработчикам потребуется использовать структуру `Store`, им придется покопаться в документации или в коде, чтобы понять, как использовать эти методы. Следовательно, принятие или возврат типа `any` не передает значимой информации.
Следует избегать типа `any` и делать сигнатуры максимально явными. Что касается нашего примера, это может означать дублирование методов *Get*
и *Set* для каждого типа:

```go
func (s *Store) GetContract(id string) (Contract, error) {
    // ...
}
func (s *Store) SetContract(id string, contract Contract) error {
    // ...
}
func (s *Store) GetCustomer(id string) (Customer, error) {
    // ...
}
func (s *Store) SetCustomer(id string, customer Customer) error {
    // ...
}
```

Здесь методы достаточно выразительны, что снижает риск непонимания. Наличие большего количества методов не всегда проблема, поскольку клиенты также могут создавать свои собственные абстракции с помощью какого-либо интерфейса.

В каких случаи `any` полезен? Посмотрим на стандартную библиотеку и два примера, где функции или методы принимают аргументы `any`. Первый пример
находится в пакете `encoding/json`. Поскольку мы можем маршалировать любой
тип, функция `Marshal` принимает аргумент `any`

```go
func Marshal(v any) ([]byte, error) {
    // ...
}
```

Другой пример можно найти в пакете database/sql:

```go
func (c *Conn) QueryContext(ctx context.Context, query string, args ...any) (*Rows, error) {
    // ...
}
```

`any` может быть полезен, если есть реальная необходимость принять или вернуть любой возможный тип, в общем, мы должны любой ценой избегать чрезмерного обобщения своего кода. Возможно, иногда небольшое дублирование кода будет приветствоваться, если это улучшает другие аспекты, например выразительность.

## ОШИБКА #9: ПУТАНИЦА В ИСПОЛЬЗОВАНИИ ДЖЕНЕРИКОВ

В Go 1.18 в язык добавлены дженерики. Это позволяет писать код с типами, которые можно указать позже и создавать при необходимости. При этом может возникнуть путаница, когда использовать дженерики.

Разработчики начинают использовать дженерики везде, где "можно", даже когда это не нужно — например, для простых функций, где `interface{}` или конкретные типы работают лучше. Это создаёт ложное ощущение "более продвинутого" кода, но на деле вредит простоте и ясности, которые Go так ценит.

Типичные проявления путаницы:

1. Использование дженериков вместо `interface{}` или конкретных типов без пользы

```go
func Print[T any](v T) {
    fmt.Println(v)
}
```

Зачем? Ведь можно просто:
```go
func Print(v interface{}) {
    fmt.Println(v)
}
```

Здесь дженерики ничего не дают: нет ограничений (constraints), нет обработки типа, нет возврата значения. Это просто синтаксический шум.

2. Создание дженерик-структур без реальной необходимости

Плохо:
```go
type Repository[T any] struct {
    db *sql.DB
}

func (r *Repository[T]) Save(entity T) error { ... }
```

Но если у тебя есть только `UserRepository` и `OrderRepository`, и они работают с разной логикой — дженерики здесь не помогут. Более того, ты потеряешь:
* Читаемость (`Repository[User]` vs `UserRepository`),
* Возможность специализировать поведение под тип,
* Простоту тестирования.

Лучше используй конкретные структуры или интерфейсы, если нужна абстракция.

3. Игнорирование ограничений (constraints)

Дженерики без ограничений (`any`) часто бесполезны:
```go
func Add[T any](a, b T) T {
    return a + b // ОШИБКА: оператор + не определён для любого типа!
}
```

Это не скомпилируется. Нужно указать, что `T` должен поддерживать сложение:
```go
import "golang.org/x/exp/constraints"

func Add[T constraints.Ordered](a, b T) T {
    return a + b
}
```

Но даже тогда — задайся вопросом: часто ли тебе нужно складывать значения разных числовых типов в одном месте?
Часто ответ — нет, и проще написать отдельные функции:
```go
func AddInt(a, b int) int
func AddFloat(a, b float64) float64
```

4. Попытка сделать "универсальный" код, который на деле не переиспользуется

Многие пишут дженерик-функции вроде:
```go
func Map[T, R any](slice []T, fn func(T) R) []R {
    result := make([]R, len(slice))
    for i, v := range slice {
        result[i] = fn(v)
    }
    return result
}
```

Это выглядит круто… но:
* Такая функция уже есть в популярных библиотеках (`slices.Map` в Go 1.21+),
* Если ты используешь её только один раз — зачем усложнять?
* В Go часто проще написать цикл напрямую, чем абстрагироваться.

Пример: вместо
```go
names := Map(users, func(u User) string { return u.Name })
```

проще и понятнее:
```go
names := make([]string, len(users))
for i, u := range users {
    names[i] = u.Name
}
```

Это быстрее, читабельнее и не требует дженериков

**Когда полезно использовать дженерики:**

1. Ты реализуешь общую структуру данных

Стек, очередь, дерево, кэш:
```go
type Stack[T any] struct {
    items []T
}

func (s *Stack[T]) Push(v T) { s.items = append(s.items, v) }
func (s *Stack[T]) Pop() (T, bool) { ... }
```

Здесь дженерики оправданы: логика одинакова для любого типа.

2. Ты пишешь утилиты, которые реально переиспользуются во многих местах

Например, безопасное получение значения из map:
```go
func GetOrDefault[K comparable, V any](m map[K]V, key K, def V) V {
    if v, ok := m[key]; ok {
        return v
    }
    return def
}
```

Но даже здесь: начни с конкретного случая, и обобщай только при повторении.

3. Ты хочешь сохранить типобезопасность без дублирования кода

Например, валидатор, который работает с разными типами, но возвращает тот же тип:
```go
func ValidateAndReturn[T Validatable](v T) (T, error) {
    if err := v.Validate(); err != nil {
        return v, err
    }
    return v, nil
}
```

при условии, что `Validatable` — интерфейс с методом `Validate()`


Дженерики вводят некоторую форму абстракции, а нам нужно помнить, что ненужные абстракции только усложняют работу.
Не будем загрязнять код ненужными абстракциями и сосредоточимся на решении конкретных задач. Это означает, что использовать параметры типа не нужно, если на то нет оснований. Когда надо будет писать шаблонный код, и только тогда рассмотрите возможность использования дженериков.

|Ситуация|Что делать|
|--|--|
|Функция принимает/возвращает один тип|Используй конкретный тип|
|Нужно работать с `int`, `float64`, `string` одинаково|Подумай дважды — часто лучше отдельные функции|
|Хочешь "сделать как в других языках"|Остановись — Go не Java и не TypeScript|
|Пишешь алгоритм над коллекцией|Сначала попробуй обычный цикл|
|Создаёшь контейнер (список, кэш и т.д.)|Дженерики уместны|

Используй дженерики редко, осознанно и только там, где они действительно устраняют дублирование или добавляют типобезопасность без ущерба для ясности.

Ошибка #9 — это ловушка "синдрома новой игрушки": дженерики появились — и многие начали применять их повсюду, даже там, где они вредят философии Go.

## ОШИБКА #10: НЕ ЗНАТЬ О ВОЗМОЖНЫХ ПРОБЛЕМАХ СО ВСТРАИВАНИЕМ ТИПОВ

При создании структуры Go позволяет встраивать типы. Но иногда это может привести к неожиданному поведению, если мы не понимаем всех последствий такого встраивания.
В Go поле структуры называется встроенным, если оно объявлено без имени.
Например:

```go
type Foo struct {
    Bar // Встроенное поле
}

type Bar struct {
    Baz int
}
```

В структуре `Foo` тип `Bar` объявлен без связанного имени, следовательно, это встроенное поле. Мы используем встраивание для продвижения (*promote*) полей и методов встроенного типа. Поскольку `Bar` содержит поле `Baz`, это поле продвигается в `Foo`. Таким образом, `Baz` становится доступным из `Foo`. Доступ к `Baz` возможен по двум разным путям:

```go
foo := Foo{}

foo.Baz = 42
// или
foo.Bar.Baz = 42
```

Давайте рассмотрим пример неправильного их использования. Ниже мы реализуем `struct`, который хранит некоторые данные в памяти, и хотим защитить его от конкурентного доступа с помощью мьютекса:

```go
type InMem struct {
    sync.Mutex // Встроенное поле
    m map[string]int
}
func New() *InMem {
    return &InMem{m: make(map[string]int)}
}
```

Мы решили сделать карту неэкспортируемой, чтобы клиенты не могли взаимодействовать с ней напрямую, а только через экспортированные методы. Между тем поле мьютекс встроено. Поэтому мы можем реализовать метод `Get` так:

```go
func (i *InMem) Get(key string) (int, bool) {
    i.Lock() // Прямой доступ к методу Lock
    v, contains := i.m[key]
    i.Unlock() // То же самое относительно метода Unlock
    return v, contains
}
```

Этот мьютекс встроен, мы можем напрямую обращаться к методам `Lock` и `Unlock` из получателя i. 

Поскольку `sync.Mutex` — это встроенный тип, методы `Lock` и `Unlock` будут продвигаться и мы можем напрямую обращаться к этим методам из получателя i. Поэтому оба метода станут видимыми и для внешних потребителей, использующих `InMem`:

```go
m := inmem.New()
m.Lock() // ??
```

Такое продвижение, вероятно, — нежелательный эффект. В большинстве случаев мьютекс — это то, что мы хотим инкапсулировать в структуру и сделать невидимым для внешних клиентов. Поэтому здесь не следует делать его встроенным полем:

```go
type InMem struct {
    mu sync.Mutex // Указывает, что поле sync.Mutex не является встроенным
    m map[string]int 
}
```

Поскольку мьютекс не встроен и не экспортируется, доступ к нему внешних
потребителей закрыт.

Рассмотрим другой пример, где встраивание можно считать правильным подходом. Нужно написать собственный логгер, содержащий `io.WriteCloser` и делающий доступными два метода: `Write` и `Close`. Если бы `io.WriteCloser` не был встроенным, код был бы таким:

```go
type Logger struct {
    writeCloser io.WriteCloser
}
func (l Logger) Write(p []byte) (int, error) {
    return l.writeCloser.Write(p) // Перенаправляет вызов на writeCloser
}
func (l Logger) Close() error {
    return l.writeCloser.Close() // Перенаправляет вызов на writeCloser
}
func main() {
    l := Logger{writeCloser: os.Stdout}
    _, _ = l.Write([]byte("foo"))
    _ = l.Close()
}
```

`Logger` должен был предоставить доступ как к методу `Write`, так и к методу `Close`, которые бы только перенаправляли вызов на `io.WriteCloser`. Но если теперь сделать поле встроенным, то можно удалить эти методы перенаправления:

```go
type Logger struct {
    io.WriteCloser // io.Writer делается встроенным
}
```

Логгер остается для клиентов тем же самым, с двумя экспортированными методами `Write` и `Close`. Но при этом становится возможным не расписывать эти дополнительные методы для простой переадресации вызова.

Какой следует сделать вывод о встраивании типов? Прежде всего оно редко бывает по-настоящему нужно, а это значит, что независимо от сути конкретной задачи мы, скорее всего, сможем решить ее и без применения встраивания типов. В основном оно используется для удобства: для продвижения поведения.

Если же мы все-таки решаем использовать встраивание типов, то нужно помнить о двух основных ограничениях:

* Не следует его использовать исключительно как синтаксический сахар — для упрощения доступа к полю (например, `Foo.Baz()` вместо `Foo.Bar.Baz()`). Если это единственная причина, то вместо встраивания внутреннего типа лучше использовать поле.

* Оно не должно продвигать данные (поля) или поведение (методы), которые мы хотим скрыть от посторонних глаз: например, если оно позволяет клиентам получить доступ к поведению блокировки, которое должно оставаться приватным для структуры.

## ОШИБКА #11: НЕ ИСПОЛЬЗОВАТЬ ПАТТЕРН ФУНКЦИОНАЛЬНЫХ ОПЦИЙ

Ошибка посвящена неправильному или избыточному использованию паттерна **Functional Options**, особенно в тех случаях, когда он не нужен или усложняет API без пользы.

**Не используй паттерн Functional Options автоматически — применяй его только тогда, когда у тебя действительно есть опциональные параметры конфигурации, и их количество/гибкость оправдывает сложность.**

Многие разработчики начинают применять этот паттерн "по привычке", даже когда:
* У конструктора всего 1–2 параметра,
* Все параметры обязательны,
* Или альтернативы (например, структура конфигурации) проще и понятнее.

Это приводит к избыточной сложности, ухудшению читаемости и трудностям при тестировании.

**Functional Options** - это идиома Go для гибкой настройки объектов с опциональными параметрами:
```go
type Server struct {
    addr    string
    timeout time.Duration
    retries int
}

// Тип опции — функция, которая модифицирует Server
type Option func(*Server)

func WithTimeout(t time.Duration) Option {
    return func(s *Server) {
        s.timeout = t
    }
}

func WithRetries(r int) Option {
    return func(s *Server) {
        s.retries = r
    }
}

// Конструктор принимает вариадические опции
func NewServer(addr string, opts ...Option) *Server {
    s := &Server{
        addr:    addr,
        timeout: 30 * time.Second, // значение по умолчанию
        retries: 3,
    }
    for _, opt := range opts {
        opt(s)
    }
    return s
}
```

Использование:
```go
server := NewServer("localhost:8080", WithTimeout(10*time.Second), WithRetries(5))
```

Это удобно, когда:
* Есть много опциональных параметров,
* Некоторые параметры редко меняются,
* Хочется сохранить чистый и расширяемый API.

**Это ошибка когда:**

Представь, что у тебя простой клиент:
```go
type Client struct {
    url string
}

func NewClient(url string) *Client {
    return &Client{url: url}
}
```

Всё просто, понятно, работает.

Но ты думаешь: «А вдруг завтра понадобится таймаут? Надо сразу сделать Functional Options» — и переписываешь:
```go
type Client struct {
    url     string
    timeout time.Duration
}

type Option func(*Client)

func WithTimeout(t time.Duration) Option {
    return func(c *Client) { c.timeout = t }
}

func NewClient(url string, opts ...Option) *Client {
    c := &Client{url: url, timeout: 5 * time.Second}
    for _, opt := range opts {
        opt(c)
    }
    return c
}
```

А пока используешь так:
```go
client := NewClient("https://api.example.com")
```

**Проблемы:**

Ты добавил сложность без реальной потребности. Пока нет второго параметра — паттерн не оправдан.

Более того:
* Код стал длиннее,
* Появились дополнительные типы (Option),
* Интерфейс NewClient теперь менее очевиден (что можно передать? какие опции существуют?),
* Тестировать сложнее (нужно проверять комбинации опций).

**Когда Functional Options оправдан:**
* Есть несколько опциональных параметров (≥2–3),
* Некоторые параметры редко используются,
* Ты хочешь сохранить обратную совместимость при расширении API,
* Альтернатива (например, передача структуры Config) менее удобна.

Пример оправданного использования — из стандартной библиотеки:
```go
http.NewRequestWithContext(ctx, method, url, body)
// или
sql.OpenDB(connector) + driver-specific options
```

Или пример — `grpc.Dial`:
```go
conn, err := grpc.Dial(addr,
    grpc.WithTransportCredentials(credentials),
    grpc.WithTimeout(5*time.Second),
    grpc.WithBlock(),
)
```

Здесь десятки возможных настроек — без Functional Options было бы невозможно.

### Альтернативы

1. Структура конфигурации

Если параметров много, но они обычно задаются вместе, лучше использовать `Config`:
```go
type Config struct {
    URL     string
    Timeout time.Duration
    Retries int
}

func NewClient(cfg Config) *Client { ... }
```

Плюсы:
* Явно видно все поля,
* Легко сериализовать (например, из YAML),
* Проще документировать.

2. Простой конструктор с фиксированными параметрами

Если параметров мало и все обязательны — просто передавай их напрямую.

|Ситуация|Что делать|
|--|--|
|1–2 обязательных параметра|Простой конструктор: `NewX(a, b)`|
|Много опциональных параметров, часто расширяется|Functional Options|
|Много параметров, но обычно задаются вместе|Структура `Config`|
|Не знаешь, будут ли опции нужны|Не добавляй их заранее! Добавь позже, когда будет реальная потребность|

**YAGNI (You Aren’t Gonna Need It) — не усложняй код "на будущее".**

Ошибка #11 — это преждевременная абстракция.

## ОШИБКА #12: НЕОРГАНИЗОВАННОСТЬ ПРОЕКТА

Ошибка посвящена одной из самых частых, но при этом критически важных проблем в Go-проектах — отсутствию четкой и продуманной структуры кода.

**Разработчики часто начинают проекты без чёткого плана структуры, кладут всё в main.go или создают произвольные папки вроде utils, helpers, common — что приводит к спагетти-коду, циклическим зависимостям и сложности тестирования.**

Принципы хорошей организации Go-проекта:

Следуй стандартной макет-структуре
Официальный документ Standard Go Project Layout (https://github.com/golang-standards/project-layout?tab=readme-ov-file)
* Не от команды Go, но де-факто принят сообществом
* В 2021 году Расс Кокс (Russ Cox), один из основных мейнтейнеров Go, раскритиковал этот макет. В основном проект существует в рамках организации GitHub golang-standards, хоть и не является официальным стандартом. Имейте в виду, что в отношении структуры проекта нет
обязательных соглашений. 

Предлагает следующее:
```
myapp/
├── cmd/
│   └── myapp/
│       └── main.go          ← точка входа
├── internal/
│   ├── api/                 ← HTTP-хендлеры
│   ├── service/             ← бизнес-логика
│   ├── storage/             ← работа с БД
│   └── domain/              ← модели и интерфейсы (чистая логика)
├── pkg/                     ← публичные библиотеки (если проект — библиотека)
├── scripts/
├── configs/
├── deployments/
├── go.mod
└── README.md
```

`internal/` — всё, что не должно быть доступно извне.

Запрещённые слова в путях:

* `utils`
* `helpers`
* `common`
* `misc`

Почему? Потому что они становятся свалками для всего подряд, нарушая принцип единственной ответственности. Вместо этого — называй папки по их роли:

* `auth` — аутентификация,
* `payment` — платежи,
* `email` — отправка писем,
* `validator` — валидация.

Если ты пишешь утилиту для работы со строками — возможно, она вообще не нужна, или её место в конкретном модуле (`user/format.go`, а не `utils/string.go`).

### Разделяй по слоям (архитектурные границы)

Часто применяют:
* Domain-Driven Design (DDD): `domain` → `application` → `infrastructure`
* Clean Architecture / Hexagonal: core logic не зависит от внешних деталей (БД, HTTP)
* Modular Monolith: каждый модуль (`user`, `order`) содержит всё, что ему нужно (handler, service, repo)

Пример:
```
internal/
├── user/
│   ├── domain/
│   │   └── user.go
│   ├── service/
│   │   └── service.go
│   ├── storage/
│   │   └── postgres.go
│   └── handler/
│       └── http.go
└── order/
    └── ...
```

Не смешивай уровни абстракции:
* `main.go` должен только собирать зависимости и запускать приложение.
* Бизнес-логика никогда не должна быть в `cmd/`.
* Конфигурация, логирование, подключение к БД — выносится в отдельные компоненты.

Плохо:
```go
// cmd/myapp/main.go
func main() {
    db := sql.Open(...) // ← логика подключения к БД в main!
    if user.Balance < 0 { ... } // ← бизнес-логика в main!
}
```

Хорошо:
```go
// cmd/myapp/main.go
func main() {
    cfg := loadConfig()
    app := application.New(cfg)
    app.Run()
}
```

Управляй зависимостями через go.mod и внутренние границы:
* Используй `internal/`, чтобы запретить импорт извне.
* Избегай циклических импортов — они невозможны в Go, но попытки их создать указывают на плохую архитектуру.
* Если модуль A зависит от B, а B — от A → нужно выделить общую часть в третий модуль (часто — `domain`).

|Признак|Проблема|
|--|--|
|Всё в одном файле `main.go`|Невозможно тестировать, расширять|
|Папка `utils` с 20 файлами|Нет чёткой ответственности|
|Импорты из `cmd/` в другие пакеты|Нарушение слоёв|
|Бизнес-логика в HTTP-хендлерах|Слишком тесная связь с транспортом|
|Модели БД (`gorm.Model`) используются напрямую в API|Нет разделения между слоями|

Как избежать:
* Начни с `internal/` и `cmd/` — даже для маленького проекта.
* Выдели `domain` — чистые структуры и интерфейсы без зависимостей.
* Пиши интерфейсы на стороне потребителя (см. Ошибка #6).
* Группируй по функциональности, а не по типу файла:
    - Плохо: `handlers/`, `services/`, `repos/` (анемичная архитектура)
    - Хорошо: `user/`, `payment/`, `notification/` (модульная)
* Проводи регулярный ревью структуры — особенно при росте проекта.

`«Хорошая организация проекта — это инвестиция в будущее. Она не замедляет разработку, а ускоряет поддержку, тестирование и масштабирование».`

Если ты не можешь объяснить, зачем существует папка — её, скорее всего, не должно быть.

Ошибка #12 — не про синтаксис, а про дисциплину.

## ОШИБКА #13: СОЗДАВАТЬ ПАКЕТЫ УТИЛИТ

Разработчики создают пакеты с названиями вроде `utils`, `helpers`, `common`, `misc` и складывают туда "всё подряд", что кажется переиспользуемым. Это приводит к неструктурированному коду, слабой связанности и трудностям в поддержке.


**«В Go не должно быть пакета `utils`. Если вы чувствуете, что он вам нужен — вы делаете что-то не так».**

Почему это плохо?
* Нарушает принцип единственной ответственности. Пакет должен отвечать за одну конкретную область (например, `auth`, `email`, `payment`). Пакет `utils` — это мусорка.
* Создаёт скрытые зависимости. Когда любой модуль может импортировать `utils`, возникает неявная связность.
* Мешает повторному использованию. Если вы когда-нибудь захотите вынести модуль (например, `user`) в отдельную библиотеку — вы обнаружите, что он зависит от `utils`, который содержит код из десятка других модулей → Вынуждены либо тащить весь `utils`, либо рефакторить.
* Затрудняет навигацию и понимание. Например новый разработчик видит:
```go
if utils.IsValidEmail(user.Email) { ... }
```
— но не понимает контекста. Это общая валидация? Или специфичная для пользователей? Где ещё используется?

Например:
```go
package util

func NewStringSet(...string) map[string]struct{} {
    // ...
}
func SortStringSet(map[string]struct{}) []string {
    // ...
}
```

Клиент будет использовать этот пакет вот так:
```go
set := util.NewStringSet("c", "a", "b")
fmt.Println(util.SortStringSet(set))
```

Проблема в том, что название пакета `util` бессмысленно. Мы могли бы назвать его `common`, `shared` или `base`, но эти названия тоже бессмысленны и не дают никакого представления о том, что делает этот пакет.

Вместо «пакет утилит» (utility package) лучше придумать более выразительное имя, например stringset («набор строк»):

```go
package stringset

func New(...string) map[string]struct{} { ... }
func Sort(map[string]struct{}) []string { ... }
```

В этом примере мы удалили суффиксы для `NewStringSet` и `SortStringSet`, которые соответственно стали `New` и `Sort`. На стороне клиента это теперь выглядит так:
```go
set := stringset.New("c", "a", "b")
fmt.Println(stringset.Sort(set))
```

Можно пойти еще дальше. Вместо создания служебных функций можно создать специфический тип и предоставить `Sort` как метод так:

```go
package stringset

type Set map[string]struct{}
func New(...string) Set { ... }
func (s Set) Sort() []string { ... }
```

Это изменение делает клиент еще более простым. На пакет `stringset` будет только одна ссылка:
```go
set := stringset.New("c", "a", "b")
fmt.Println(set.Sort())
```

Ошибка #13 — это симптом более глубокой проблемы: отсутствия чётких границ ответственности.
Go поощряет маленькие, сфокусированные пакеты, а не монолитные свалки.

## ОШИБКА #14: ИГНОРИРОВАТЬ КОЛЛИЗИИ ИМЕН ПАКЕТОВ

Коллизии имен пакетов возникают, когда переменная имеет такое же имя, как и у существующего пакета, что мешает его переиспользованию. Рассмотрим пример с библиотекой, открывающей клиент Redis:

```go
package redis

type Client struct { ... }
func NewClient() *Client { ... }
func (c *Client) Get(key string) (string, error) { ... }
```

Перейдем на сторону клиента. Несмотря на существование имени пакета redis, в Go вполне допустимо создать и переменную с именем redis:

```go
redis := redis.NewClient()  // Вызывается NewClient из пакета redis
v, err := redis.Get("foo")  // Используется переменная с именем redis
```

Здесь происходит коллизия имени переменной redis с именем пакета redis. Хотя такое использование наименований и разрешено, его следует избегать. Во всей области действия переменной redis пакет redis будет недоступен.

Предположим, что какой-то квалификатор ссылается как на переменную, так и на имя пакета внутри всей функции. В этом случае тот, кто читает код, может и не понять, на что он ссылается. Как избежать такой коллизии? 

1. Использовать другое имя переменной. Например:
```go
redisClient := redis.NewClient()
v, err := redisClient.Get("foo")
```

2. Но если по какой-то причине нужно оставить redis в качестве имени нашей переменной, можно поиграть с импортом пакетов. Применяя импорт пакетов, можно использовать псевдоним, чтобы изменить квалификатор для ссылки на пакет redis. Например:
```go
import redisapi "mylib/redis" // Для пакета redis создается псевдоним

// ...
redis := redisapi.NewClient() // Указывается на доступ к пакету redis через псевдоним redisapi
v, err := redis.Get("foo")
```

Для импорта использовался псевдоним redisapi, ссылающийся на пакет redis, чтобы сохранить имя переменной redis.

## ОШИБКА #15: НЕ ПИСАТЬ ДОКУМЕНТАЦИЮ ПО КОДУ

Создание соответствующей документации — важная часть написания кода. Она упрощает клиентам использование API, а также помогает в поддержке и сопровождении проекта.

Прежде всего, каждый экспортируемый элемент должен быть задокументирован. Будь то структура, интерфейс, функция или что-то еще, если элемент экспортируется, он должен быть задокументирован. Принято добавлять комментарии, начиная с имени экспортируемого элемента. Например:
```go
// Customer — это представление потребителя.
type Customer struct{}
// ID возвращает идентификатор потребителя.
func (c Customer) ID() string { return "" }
```

По правилам, каждый комментарий должен быть полным предложением, заканчивающимся точкой. Также имейте в виду, что когда мы описываем функцию (или метод), мы должны указывать то, что функция должна делать, а не то, как она это делает. В идеале документация должна содержать достаточно информации, чтобы клиенту не нужно было каждый раз изучать код, чтобы понять, как использовать экспортируемый элемент.

Экспортированный элемент можно объявить устаревшим с помощью комментария `// Deprecated`

Когда дело доходит до документирования переменной или константы, нас может заинтересовать передача связанных с ними двух аспектов: назначения и содержания. Первый должен быть отражен в документации, что будет полезно для внешних клиентов. Последний не обязательно делать публичным. Например:
```go
// DefaultPermission разрешение по умолчанию, используемое движком магазина.
const DefaultPermission = 0o644 // Необходим доступ на чтение и запись.
```

По соглашению комментарий начинается с `// Package`, за которым следует имя пакета:
```go
// Пакет math предоставляет основные константы и математические функции.
//
// Этот пакет не гарантирует битовую идентичность результатов
// в разных архитектурах.
package math
```

Каждый экспортируемый элемент должен быть задокументирован. Документирование кода не должно быть чем-то ограничено. Пользуйтесь всеми возможностями, чтобы убедиться, что оно поможет клиентам и мейнтейнерам понять назначение кода.

## ОШИБКА #16: НЕ ИСПОЛЬЗОВАТЬ ЛИНТЕРЫ

Линтер — это автоматический инструмент для анализа кода и отлова ошибок в нем.

Рассмотрим пример. В разделе, посвященном ошибке #1, мы обсуждали затенение переменных. Используя линтер `vet`, встроенный в набор инструментов Go, а также `shadow`, можно обнаружить затененные переменные:

```go
package main

import "fmt"

func main() {
    i := 0
    if true {
        i := 1 // Затененная переменная
        fmt.Println(i)
    }
    fmt.Println(i)
}
```

Как мы видим, `vet` сообщает, что переменная `i` в этом примере затенена. Использование соответствующих линтеров поможет сделать код более надежным и обнаружить потенциальные ошибки.

Взгляните на `golangci-lint` (https://github.com/golangci/golangci-lint). Это инструмент для анализа кода, который обеспечивает видимость поверх многих полезных линтеров и форматировщиков. Он позволяет запускать линтеры параллельно для повышения скорости анализа, что весьма удобно.

Линтеры и форматировщики — это мощные способы улучшить качество и согласованность кода. Уделите время тому, чтобы понять, какие из них следует использовать, и убедитесь, что автоматизировали их выполнение (например, с помощью CI или с Git pre-commit hook).

## ИТОГ:

* Избегайте затенения переменных во избежание ссылок на неправильную переменную или запутывания читателей кода.
* Избегайте использования вложенных уровней и выравнивайте «счастливый путь» по левому краю — это упрощает построение ментальной модели кода
* При инициализации переменных помните, что функции инициализации содержат в себе ограниченные возможности по обработке ошибок, что усложняет обработку состояний и тестирование. В большинстве случаев инициализации следует обрабатывать как специальные функции.
* Принудительное использование геттеров и сеттеров не является в Go идиоматическим. Правильный подход заключается в том, чтобы быть прагматичным и находить должный баланс между эффективностью и следованием определенным идиомам.
* Абстракции следует «открывать», а не создавать. Для предотвращения излишней сложности создавайте интерфейс только тогда, когда он действительно нужен, а не тогда, когда вы лишь предполагаете, что он может понадобиться в будущем, либо если можете доказать, что абстракция допустима.
* Размещение интерфейсов на стороне потребителя позволяет избежать излишних абстракций.
* Чтобы избавиться от ограничений с точки зрения гибкости, в большинстве случаев функции должны возвращать не интерфейсы, а конкретные реализации. И наоборот, функции должны принимать интерфейсы всегда, когда это возможно.
* Используйте `any` только в том случае, если нужно принять или вернуть любой возможный тип, например `json.Marshal`. В противном случае `any` не несет значимой информации и может привести к проблемам при компиляции, позволяя вызывающей функции обращаться к методам с любым типом данных.
* Полагаясь на дженерики и параметры типа, можно избежать написания шаблонного кода для разделения элементов или поведения. Используйте параметры типа лишь тогда, когда видите конкретную необходимость в них. В противном случае они вводят ненужные абстракции и усложняют код.
* Использование встраивания типов также поможет избежать шаблонного кода. Но убедитесь, что это не приведет к проблемам с видимостью в тех случаях, когда некоторые поля должны оставаться скрытыми.
* Для подходящей обработки параметров в удобной для API манере используйте паттерн функциональных опций.
* Следование макету проекта может стать хорошим способом структурировать проект, особенно если в новом проекте вы стремитесь к соблюдению имеющихся соглашений для стандартизации.
* Именование — важнейшая часть проектирования приложений. Создание пакетов с именами `common`, `util` или `shared` не имеет ценности для читателя кода. Преобразуйте имена таких пакетов во что-то более осмысленное и конкретное.
* Чтобы избежать коллизий имен переменных и пакетов, приводящих к путанице или ошибкам, используйте уникальные имена для каждого из них. Если это невозможно, применяйте псевдоним импорта, изменяя квалификатор так, чтобы отличать имя пакета от имени переменной, или придумайте лучшие имена.
* Чтобы клиенты и мейнтейнеры проекта лучше понимали назначение кода, документируйте экспортированные элементы.
* Чтобы улучшить качество и внутреннюю согласованность кода, используйте линтеры и средства форматирования.

# Типы данных

## ОШИБКА #17: ПУТАНИЦА С ВОСЬМЕРИЧНЫМИ ЛИТЕРАЛАМИ

Рассмотрим частую путаницу с представлением восьмеричного литерала, которая может привести к ошибкам. Как вы думаете, что выведет этот код:
```go
sum := 100 + 010
fmt.Println(sum)
```

На первый взгляд можно ожидать, что в результате выполнения этого кода будет выведено 100 + 10 = 110. Но вместо этого получается 108.

В Go целочисленный литерал, начинающийся с 0, считается восьмеричным целым числом (то есть числом по основанию 8), поэтому 10 по основанию 8 равняется 8 по основанию 10. Таким образом, сумма в предыдущем примере равна 100 + 8 = 108. Помнить о таком свойстве целочисленных литералов очень важно, чтобы избегать путаницы при чтении кода.

Восьмеричные целые числа полезны в разных сценариях. Допустим, мы хотим открыть файл с помощью os.OpenFile. Эта функция требует передачи разрешения как uint32. Если мы хотим соответствовать разрешению Linux, то для лучшей читаемости можем передать восьмеричное число вместо числа по основанию 10:
```go
file, err := os.OpenFile("foo", os.O_RDONLY, 0644)
```

В этом примере `0644` представляет определенное разрешение Linux (чтение для всех пользователей, а запись только для текущего). Также можно добавить символ o (буква o в нижнем регистре) после нуля:
```go
file, err := os.OpenFile("foo", os.O_RDONLY, 0o644)
```

Префиксы `0o` и `0` несут одно и то же значение. Но использование `0o` поможет
сделать код более понятным.

Представления других целочисленных литералов:
* двоичных — используется префикс `0b` или `0B` (например, `0b100` равно десятичному 4)
* шестнадцатеричных — используется префикс `0x` или `0X` (например, `0xF` равно десятичному 15)
* мнимых — используется суффикс i (например, 3i)

Так же можно использовать символ подчеркивания (_) в качестве разделителя для удобства чтения. Например, записать 1 миллиард так: 1_000_000_000

## ОШИБКА #18: ИГНОРИРОВАТЬ ЦЕЛОЧИСЛЕННЫЕ ПЕРЕПОЛНЕНИЯ

Непонимание того, как целочисленные переполнения обрабатываются в Go, может привести к критическим ошибкам.

В Go есть в общей сложности 10 типов целых чисел:
* Целые числа со знаком
    - int8 (8 bits)
    - int16 (16 bits)
    - int32 (32 bits)
    - int64 (64 bits)
    - int (32 bits / 64 bits)
* Целые числа без знака:
    - uint8 (8 bits)
    - uint16 (16 bits)
    - uint32 (32 bits)
    - uint64 (64 bits)
    - uint (32 bits / 64 bits)

Чаще всего используются два других целочисленных типа: `int` и `uint`. Они имеют размер, который зависит от системы: 32 бита в 32-битных системах или 64 бита в 64-битных системах.

Предположим, нужно инициализировать `int32` до его максимального значения, а затем увеличить:
```go
var counter int32 = math.MaxInt32
counter++
fmt.Printf("counter=%d\n", counter)
```

Данный код компилируется и не вызывает паники во время выполнения. Однако оператор `counter++` генерирует целочисленное переполнение:
```go
counter=-2147483648
```

Оно возникает, когда результатом арифметической операции является значение вне диапазона, который может быть представлен заданным числом байтов. В int32 используются 32 бита.

В Go целочисленное переполнение, которое можно обнаружить во время компиляции, приводит к ошибке компиляции. Например:
```go
var counter int32 = math.MaxInt32 + 1
constant 2147483648 overflows int32
```

Но во время выполнения целочисленное переполнение или антипереполнение (потеря значимости) не происходит, и это не приводит к панике приложения.

Важно помнить о таком поведении, поскольку оно может привести к скрытым ошибкам. В большинстве случаев, например при обработке счетчика запросов или основных операциях сложения/умножения, волноваться не стоит, если мы используем правильный целочисленный тип. Но, например, в проектах с ограниченным объемом памяти, использующих меньшие целочисленные типы, работающих с большими числами или выполняющих операции конверсии/преобразования, может потребоваться провести проверки на предмет возможных переполнений.

1. Обнаружение целочисленного переполнения при инкрементировании

```go
func Inc32(counter int32) int32 {
    if counter == math.MaxInt32 { // Сравнение с math.MaxInt32
        panic("int32 overflow")
    }
    return counter + 1
}
```

Эта функция проверяет, достигла ли переменная значения math.MaxInt32. Если да, то ее увеличение приведет к переполнению.


Для `int`:
```go
func IncInt(counter int) int {
    if counter == math.MaxInt {
        panic("int overflow")
    }
    return counter + 1
}
```

Для `uint`:
```go
func IncUint(counter uint) uint {
    if counter == math.MaxUint {
        panic("uint overflow")
    }
    return counter + 1
}
```

2. Обнаружение целочисленного переполнения при сложении

```go
func AddInt(a, b int) int {
    if a > math.MaxInt - b { // Проверяется, не произойдет ли целочисленное переполнение
        panic("int overflow")
    }
    return a + b
    }
```
В этом примере *a* и *b* — два операнда. Если *a* больше, чем *math.MaxInt — b*, операция приведет к целочисленному переполнению.

3. Обнаружение целочисленного переполнения при умножении

```go
func MultiplyInt(a, b int) int {
    if a == 0 || b == 0 { // Если один из операндов равен нулю, значение 0 возвращается напрямую
        return 0
    }
    result := a * b
    if a == 1 || b == 1 { // Проверяется, равен ли один из операндов 1
        return result
    }
    if a == math.MinInt || b == math.MinInt { // Проверяется, равен ли один из операндов math.MinInt
        panic("integer overflow")
    }
    if result/b != a { // Проверяется, приводит ли операция умножения к целочисленному переполнению
        panic("integer overflow")
    }
    return result
    }
```

Также помните, что в Go есть пакет для работы с большими числами: `math/big`. Используйте его, если `int` недостаточно.

## ОШИБКА #19: НЕ ПОНИМАТЬ ПРОБЛЕМ, СВЯЗАННЫХ С ПЛАВАЮЩЕЙ ТОЧКОЙ

Использовать `float64` (или `float32`) для представления десятичных чисел, где требуется точность (например, деньги, проценты, налоги), не осознавая, что числа с плавающей точкой не могут точно представлять многие десятичные дроби.

Это не ошибка Go — это особенность стандарта IEEE 754, на котором основаны все современные процессоры. Но в Go, как и в других языках, легко "наступить на грабли", если не знать об этом.

Пример:
```go
package main

import "fmt"

func main() {
    a := 0.1
    b := 0.2
    c := a + b
    fmt.Println(c)           // Вывод: 0.30000000000000004
    fmt.Println(c == 0.3)    // Вывод: false
}
```

0.1 и 0.2 нельзя точно представить в двоичной системе с плавающей точкой — так же, как нельзя точно записать 1/3 в десятичной системе (получится 0.333...).

Результат — округление, и при арифметике ошибки накапливаются.

Типичные сценарии, где это ломает логику:

1. Финансовые расчёты:
```go
balance := 100.0
payment := 30.1
balance -= payment
fmt.Println(balance) // 69.89999999999999
```

* Если вы сравниваете `balance == 69.9` — условие не выполнится.
* Если округляете без контроля — можете "потерять" копейки.

2. Сравнение float-значений напрямую
```go
if price == expectedPrice { ... } // Опасно!
```

Всегда используйте эпсилон-сравнение:
```go
func equal(a, b, eps float64) bool {
    return math.Abs(a-b) < eps
}
```

3. Накопление ошибок в циклах
```go
var total float64
for i := 0; i < 10; i++ {
    total += 0.1
}
fmt.Println(total) // 0.9999999999999999, а не 1.0
```

### Как правильно работать с десятичными числами

1. Используйте целые числа (центы, копейки)

```go
type Money int64 // хранит сумму в копейках

func NewMoney(dollars int64, cents int64) Money {
    return Money(dollars*100 + cents)
}

func (m Money) String() string {
    dollars := m / 100
    cents := m % 100
    return fmt.Sprintf("$%d.%02d", dollars, cents)
}

// Пример:
balance := NewMoney(100, 0)   // $100.00
payment := NewMoney(30, 10)   // $30.10
balance -= payment            // $69.90 — точно!
```

Плюсы:
* Абсолютная точность
* Нет проблем с округлением
* Быстро и эффективно

2. Используйте специализированные библиотеки для десятичной арифметики

* `github.com/shopspring/decimal` — самая популярная библиотека для точных десятичных вычислений.
* `github.com/ericlagergren/decimal` — альтернатива.

Пример с `shopspring/decimal`:
```go
import "github.com/shopspring/decimal"

a := decimal.NewFromFloat(0.1)
b := decimal.NewFromFloat(0.2)
c := a.Add(b)
fmt.Println(c.String()) // "0.3"
fmt.Println(c.Equal(decimal.NewFromFloat(0.3))) // true
```

Но: `NewFromFloat(0.1)` уже содержит ошибку, потому что `0.1` → `float64` → неточно.
Лучше использовать строки:
```go
a := decimal.NewFromString("0.1") // точное представление
```

3. Округляйте явно и контролируемо

Если вы всё же используете `float64` (например, в ML или графике), никогда не сравнивайте напрямую и округляйте при выводе:

```go
import "math"

func round(f float64, places int) float64 {
    shift := math.Pow(10, float64(places))
    return math.Round(f*shift) / shift
}

price := 0.1 + 0.2
fmt.Println(round(price, 2)) // 0.3
```

`Но помните: округление — это маскировка ошибки, а не её решение.`

Безопасно использовать `float64`, когда:
* Точность не критична (графика, физика, ML, метрики)
* Работаете с нормализованными значениями (от 0 до 1)
* Выполняете статистические расчёты, где небольшие погрешности допустимы

Никогда не используйте `float64` для:
* Денег
* Налогов
* Процентных ставок (если от них зависит финансовый результат)
* Идентификаторов или ключей
* Точного сравнения.

**Итог:**
* Не храните деньги в `float64` — это антипаттерн.
* Если видите `float64` в доменной модели — задайте вопрос: "А точно ли здесь нужна плавающая точка?"
* При парсинге JSON с денежными суммами — не мапьте напрямую в `float64`. Используйте кастомный тип или string → decimal.
* Тестируйте граничные случаи: 0.1 + 0.2, 1 - 0.9, деление на 3 и т.д.

Ошибка #19 — это не про Go, а про математику.

## ОШИБКА #20: НЕ ПОНИМАТЬ ОСОБЕННОСТЕЙ, СВЯЗАННЫХ С ДЛИНОЙ СРЕЗА И ЕГО ЕМКОСТЬЮ

Одна из самых коварных и часто встречающихся проблем в Go. Многие разработчики интуитивно думают, что `len` и `cap` — это почти одно и то же, или игнорируют `cap` вообще. Но именно непонимание взаимосвязи между длиной (`len`) и вместимостью (`cap`) приводит к:
* неожиданному поведению при срезах
* скрытым багам с совместным использованием памяти
* избыточным аллокациям или, наоборот, неожиданной экономии памяти

Разработчики не осознают, что `s[i:j]` может выходить за пределы `len(s)`, если `j ≤ cap(s)`, и что `append` может модифицировать "невидимую" часть базового массива, влияя на другие слайсы.

```go
// Логически:
type slice struct {
    ptr  *T   // указатель на базовый массив
    len  int  // сколько элементов "видно"
    cap  int  // сколько элементов выделено от ptr до конца массива
}
```

Примеры:

1. Срез за пределами длины (но в пределах вместимости)

```go
s1 := make([]int, 2, 5) // len=2, cap=5 → [0, 0, ?, ?, ?]
s2 := s1[1:4]           // ДОПУСТИМО потому что 4 ≤ cap(s1)
```

Многие думают: «Но `s1` же длиной 2, как можно взять `[1:4]`?»
На самом деле: границы среза проверяются по `cap`, а не по `len`.
Это не ошибка времени выполнения, потому что базовый массив имеет 5 элементов.

* `s2` имеет `len = 3`, `cap = 4`
* `s2` видит элементы с индексов `1, 2, 3` базового массива
* Элементы с индексами 2 и 3 — непроинициализированные (нули), но доступны

2. `append` может "портить" другие слайсы

```go
s1 := []int{1, 2, 3, 4, 5}
s2 := s1[1:3]        // [2, 3], len=2, cap=4
s3 := append(s2, 10) // добавляем в s2
fmt.Println(s1)      // [1 2 3 10 5] ← s1 изменился!
```

* `s2` и `s1` делят один базовый массив
* `append(s2, 10)` записал 10 в позицию `s1[3]`
* `s1` "видит" это изменение, потому что он включает этот элемент

Это не баг Go — это особенность, но она ломает ожидания, если не понимать `cap`.

3. `append` не всегда создаёт новый массив

```go
s := make([]int, 2, 5) // [0, 0, ?, ?, ?]
s = append(s, 1)       // len=3, cap=5 → НЕТ realloc
s = append(s, 2)       // len=4 → всё ещё в пределах cap
s = append(s, 3)       // len=5 → всё ещё OK
s = append(s, 4)       // len=6 > cap=5 → realloc! Новый массив.
```

До последнего `append` все изменения происходили в том же массиве. После — `s` указывает на новый блок памяти.

Это критично для:
* производительности (избегаем лишних аллокаций),
* безопасности (если другой слайс смотрит в старый массив).

### Необходимо понимать:

1. Границы среза `s[low:high]` проверяются так:

* `0 ≤ low ≤ high ≤ cap(s)`
* НЕ `high ≤ len(s)`

```go
s := make([]int, 2, 10)
_ = s[1:5] // OK!
_ = s[1:10] // OK!
_ = s[1:11] // panic: out of bounds
```

2. `len(s)` — сколько элементов используется, `cap(s)` — сколько выделено

`len` определяет, сколько элементов вы можете прочитать/записать без `append`
`cap` определяет, насколько можно расширить слайс без перераспределения

3. `append` использует `cap` для принятия решения о realloc

* Если `len(s) < cap(s)` → пишет в существующий массив
* Иначе → выделяет новый массив (обычно удваиваться до тех пор, пока он не станет содержать 1024 элемента, после чего будет увеличиваться на 25 %)

4. Срезы могут "смотреть" в разные части одного массива

Изменения через один слайс могут быть видны в другом, если:
* нет realloc
* индексы пересекаются

### Как избежать ошибки #20

1. Всегда помните про `cap` при создании срезов. Если вы делаете `s[i:j]`, подумайте: «А не затрону ли я чужие данные, если сделаю `append`?»

2. Если нужна изоляция — делайте копию

```go
original := []int{1, 2, 3, 4, 5}
sub := original[1:3]

// Чтобы изолировать:
safeSub := make([]int, len(sub))
copy(safeSub, sub)
// ИЛИ (Go 1.22+):
safeSub := slices.Clone(sub)
```

3. Используйте `s[i:j:j]` для ограничения вместимости (full slice expression)

```go
s1 := []int{1, 2, 3, 4, 5}
s2 := s1[1:3:3] // len=2, cap=2 (а не 4!)
```

Теперь `append(s2, x)` гарантированно вызовет realloc, и не повлияет на `s1`. Это мощный инструмент для защиты от неожиданных побочных эффектов.

4. Не предполагайте, что `append` "безопасен"

Особенно если слайс пришёл извне (например, параметр функции).

**Слайс — это окно в массив. Окно можно сдвигать и расширять, но за занавеской — один и тот же массив… пока вы не ударитесь в стену (`cap`).**

## ОШИБКА #21: НЕЭФФЕКТИВНАЯ ИНИЦИАЛИЗАЦИЯ СРЕЗА

Это типичная проблема, с которой сталкиваются разработчики на Go, особенно при работе с динамическими коллекциями. Суть ошибки в том, что неправильный способ создания среза приводит к избыточным аллокациям памяти и снижению производительности, хотя Go предоставляет простые и эффективные альтернативы.

Использовать `var s []T` или `s := []T{}` и затем многократно вызывать `append`, когда заранее известен (или оценим) конечный размер среза - Это заставляет Go многократно перераспределять память (realloc), копируя данные при каждом превышении текущей вместимости (`cap`).

Пример неэффективного кода:
```go
// Плохо: неизвестная вместимость
func getNumbers(n int) []int {
    var numbers []int // len=0, cap=0
    for i := 0; i < n; i++ {
        numbers = append(numbers, i)
    }
    return numbers
}
```

Что происходит:
* При первом `append` → выделяется массив на 1 элемент
* При втором → новый массив на 2 элемента, копирование
* При третьем → новый массив на 4 элемента (Go обычно удваивает ёмкость)
* При пятом → новый массив на 8 элементов
* И так до тех пор, пока не хватит места.

Для n = 1000:
* Будет ~10 реаллокаций
* Будет скопировано тысячи лишних значений

`Это O(n log n) по количеству копирований, хотя может быть O(n)`

Правильный подход: предварительное выделение ёмкости. Если вы знаете или можете оценить размер среза — используйте make:
```go
// Хорошо: выделяем сразу нужную ёмкость
func getNumbers(n int) []int {
    numbers := make([]int, 0, n) // len=0, cap=n
    for i := 0; i < n; i++ {
        numbers = append(numbers, i) // realloc НЕ происходит
    }
    return numbers
}
```

Теперь:
* Память выделяется один раз
* `append` просто записывает в уже выделенный блок
* Никаких копирований — максимальная эффективность

**Формы неэффективной инициализации:**

1. Инициализация с ненужной длиной:
```go
// Плохо: создаём срез с нулями, потом перезаписываем
numbers := make([]int, n) // len=n, все элементы = 0
for i := 0; i < n; i++ {
    numbers[i] = compute(i)
}
```

**Это не всегда плохо — если вы точно заполните все элементы, то это нормально и даже быстрее, чем `append`. Но если вы не используете все элементы, или заполняете не подряд — лучше `len=0, cap=n`.**

2. Использование литерала с последующим ростом:
```go
s := []string{"a"} // cap=1
s = append(s, "b", "c", "d") // realloc как минимум 2 раза
```

Лучше:
```go
s := make([]string, 1, 4)
s[0] = "a"
s = append(s, "b", "c", "d")
```

**Используйте `make`, когда:**

* Преобразуете другой срез/мапу в новый срез:
```go
result := make([]User, 0, len(users))
```

* Читаете из базы/файла с известным количеством строк
* Генерируете последовательность фиксированной длины.

Результат можно измерить с помощью benchmark'ов
```go
func BenchmarkBad(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = getNumbersBad(1000)
    }
}

func BenchmarkGood(b *testing.B) {
    for i := 0; i < b.N; i++ {
        _ = getNumbersGood(1000)
    }
}
```

```bash
go test -bench=.
```

`Если вы знаете, сколько элементов будет в срезе — выделите ёмкость заранее. Это бесплатно, безопасно и значительно эффективнее.`

Ошибка #21 — это ошибка "ленивой оптимизации": кажется, что Go сам всё сделает хорошо, но на деле вы платите за лишние аллокации и копирования.

## ОШИБКА #22: ПУТАТЬ ПУСТЫЕ И НУЛЕВЫЕ СРЕЗЫ

Хотя с точки зрения логики программы нулевой и пустой срезы часто ведут себя одинаково, они не эквивалентны на уровне памяти и семантики, и в некоторых контекстах эта разница критична.

Суть ошибки: Считать, что `var s []T` (нулевой срез) и `s := []T{}` (пустой срез) — это одно и то же, и использовать их взаимозаменяемо без учёта контекста.

1. Нулевой срез (nil slice)

```go
var s []int
// или
var s = ([]int)(nil)
```

* Указатель = `nil`
* `Len = 0`, `Cap = 0`
* Не ссылается ни на какой массив

2. Пустой срез (empty slice)

```go
s := []int{}
// или
s := make([]int, 0)
```

* Указатель не nil (указывает на специальный "пустой" блок памяти)
* `Len = 0`, `Cap = 0`
* Ссылается на выделенный (хоть и пустой) массив

`В Go все нулевые слайсы равны nil, а пустые — нет`

В большинстве повседневных операций — разницы нет:
```go
var nilSlice []int
emptySlice := []int{}

fmt.Println(len(nilSlice) == len(emptySlice)) // true (0 == 0)
fmt.Println(cap(nilSlice) == cap(emptySlice)) // true (0 == 0)

for range nilSlice { /* не выполнится */ }
for range emptySlice { /* не выполнится */ }

nilSlice = append(nilSlice, 1)   // OK → [1]
emptySlice = append(emptySlice, 1) // OK → [1]
```

Разница проявляется:

1. Сравнение с `nil`
```go
var s1 []int        // nil
s2 := []int{}       // не nil

fmt.Println(s1 == nil) // true
fmt.Println(s2 == nil) // false ← важно!
```

Если код проверяет `if slice == nil`, то пустой срез не пройдёт эту проверку.

2. JSON-сериализация (самый частый источник багов)
```go
type Response struct {
    Items []string `json:"items"`
}

// Случай 1: nil-слайс
r1 := Response{Items: nil}
json1, _ := json.Marshal(r1)
fmt.Println(string(json1)) // {"items":null}

// Случай 2: пустой слайс
r2 := Response{Items: []string{}}
json2, _ := json.Marshal(r2)
fmt.Println(string(json2)) // {"items":[]}
```

* Клиенты (особенно на TypeScript, Java, Swift) могут ожидать массив, а получить `null` → падение при парсинге.
* Некоторые API требуют явного `[]`, чтобы сигнализировать: «данные загружены, просто пусто», а `null` означает: «данные не загружались».

3. Работа с базами данных (например, через `sql.Scanner`)

Некоторые драйверы или ORM (вроде GORM) могут по-разному интерпретировать `nil` и `[]`:
* `nil` → сохранить как NULL в SQL,
* `[]` → сохранить как пустой массив (если тип поддерживает массивы, например, в PostgreSQL).

4. Семантическое значение в доменной модели

* `nil` может означать: «значение не установлено»,
* `[]` — «значение установлено и оно пустое».

Пример: фильтр по тегам
```go
type SearchRequest struct {
    Tags []string // nil = не фильтровать, [] = искать без тегов
}
```

Если вы всегда инициализируете как `[]string{}`, вы теряете информацию о намерении клиента.

Вариант `[]string{}` — следует избегать, если инициализируется срез без элементов.


|Характеристика|Нулевой срез (`var s []T`)|Пустой срез (`s := []T{}`)|
|--|--|--|
|`len`|0|0|
|`cap`|0|0|
|`s == nil`|`true`|`false`|
|JSON|`null`|`[]`|
|Базовый массив|отсутствует|существовует|
|Семантика|не инициализирован|инициализирован, но пуст|

`Если клиент или система ожидает массив — никогда не отправляйте null. Инициализируйте срез как пустой явно.`

## ОШИБКА #23: НЕПРАВИЛЬНО ПРОВЕРЯТЬ ПУСТОТУ СРЕЗА

В этом примере вызываем функцию `getOperations`, которая возвращает срез типа `float32`. Далее мы хотим вызывать функцию `handle` только в том случае, если этот срез содержит элементы. Вот первая (ошибочная) версия кода этих действий:
```go
func handleOperations(id string) {
    operations := getOperations(id)
    if operations != nil { // Проверяется, является ли срез operations нулевым
        handle(operations)
    }
}
func getOperations(id string) []float32 {
    operations := make([]float32, 0) // Инициализируется срез operations
    if id == "" {
        return operations // Возвращается operations, если заданный id пуст
    }
    // Добавление элементов к operations
    return operations
}
```

Мы определяем, есть ли в срезе элементы, проверяя, не является ли срез `operations` нулевым. Но у этого кода есть проблема: функция `getOperations` никогда не возвращает нулевой срез, она возвращает пустой срез. Поэтому значение проверки `operations != nil` всегда будет `true`.

Что делать? Один из подходов — изменить `getOperations` так, чтобы он возвращал нулевой срез, если id пуст:
```go
func getOperations(id string) []float32 {
    operations := make([]float32, 0)
    if id == "" {
        return nil // Возврат nil вместо operations
    }
    // Добавление элементов к operations
    return operations
}
```

Но такой подход работает не во всех ситуациях — контекст, в котором мы находимся, не всегда позволяет изменить вызываемый объект. Например, если используется внешняя библиотека, мы не будем создавать пулреквест только для того, чтобы заменить пустые срезы на нулевые. Как тогда проверить, является срез пустым или нулевым? Нужно проверить
его длину:
```go
func handleOperations(id string) {
    operations := getOperations(id)
    if len(operations) != 0 { // Проверка длины среза
        handle(operations)
    }
}
```

В предыдущем разделе мы упоминали, что пустой срез по определению имеет нулевую длину. При этом нулевые срезы всегда пусты. Поэтому, проверяя длину среза, мы учитываем все возможные сценарии:
* Если срез равен `nil`, то `len(operations) != 0` принимает значение `false`
* Если срез не равен `nil`, а является пустым, то значение `len(operations) != 0`
также будет `false`

Следовательно, проверка длины — лучший способ, поскольку мы не всегда можем контролировать то, что будет происходить в результате выполнения вызываемых функций. Тот же принцип применим и к картам. Чтобы проверить, пуста ли карта, проверяйте ее длину, а не то, равна ли она `nil`.

## ОШИБКА #24: НЕПРАВИЛЬНО СОЗДАВАТЬ КОПИИ СРЕЗОВ

Встроенная функция `copy` позволяет копировать элементы из исходного среза в другой. Хотя эта встроенная функция удобна, Go-разработчики не всегда правильно ее понимают.

В следующем примере мы создаем один срез и копируем его элементы в другой.
```go
src := []int{0, 1, 2}
var dst []int
copy(dst, src)
fmt.Println(dst)
```

В результате мы получим `[]`, а не `[0 1 2]`. Что же мы упустили?

Чтобы эффективно использовать функцию `copy`, важно понимать, что число элементов, скопированных в другой срез, определяется минимумом между:
* длиной исходного среза
* длиной второго среза

В предыдущем примере `src` — это срез длиной 3, а `dst` — срез с нулевой длиной, поскольку он инициализируется со своим нулевым значением. Поэтому функция copy копирует количество элементов, равное минимуму в наборе 3 и 0: здесь этот минимум будет равен 0. Поэтому полученный срез будет пустым.

Если мы хотим выполнить полное копирование, второй срез должен иметь длину больше или равную длине исходного. Здесь мы устанавливаем длину, отталкиваясь от параметров исходного среза:
```go
src := []int{0, 1, 2}
dst := make([]int, len(src)) // Создается срез dst, но уже с заданной длиной
copy(dst, src)
fmt.Println(dst)
```

Поскольку `dst` теперь срез, инициализированный с длиной, равной 3, то копируются три элемента. На этот раз, если мы запустим код, его результатом будет `[0 1 2]`.

Использование встроенной функции `copy` — не единственный способ копирования элементов среза. Есть альтернативы, самая известная из которых следующая (в ней используется `append`):
```go
src := []int{0, 1, 2}
dst := append([]int(nil), src...)
```

Мы присоединяем элементы из исходного среза в другой, нулевой. Следовательно, этот код создает копию среза длиной 3 и емкостью 3. Но использование функции `copy` более идиоматично и, следовательно, легче для понимания, даже несмотря на то, что требует дополнительной строки.

Копирование элементов из одного среза в другой — довольно частая операция. При использовании функции `copy` мы должны помнить, что количество скопированных элементов определяется минимумом между длинами двух срезов.

## ОШИБКА #25: НЕОЖИДАННЫЕ ПОБОЧНЫЕ ЭФФЕКТЫ ПРИ ИСПОЛЬЗОВАНИИ APPEND В ОПЕРАЦИЯХ СО СРЕЗАМИ

Суть ошибки в том, что `append` может модифицировать не только целевой слайс, но и другие слайсы, которые делят с ним базовый массив, особенно если вы не учитываете текущую вместимость (`cap`).
Это приводит к скрытым багам, где изменения в одном месте неожиданно влияют на данные в другом — даже если эти слайсы логически "независимы".

```go
package main

import "fmt"

func main() {
    s1 := []int{1, 2, 3, 4, 5}
    s2 := s1[1:3] // [2, 3], len=2, cap=4 (указывает в тот же массив)

    s3 := append(s2, 10) // добавляем в s2
    fmt.Println("s1:", s1) // [1 2 3 10 5] ← s1 изменился!
    fmt.Println("s2:", s2) // [2 3]
    fmt.Println("s3:", s3) // [2 3 10]
}
```

Почему так происходит?
* `s1` — это слайс длиной 5, указывающий на массив `[1,2,3,4,5]`.
* `s2 := s1[1:3]` — новый слайс, но тот же массив, начиная с индекса 1.
* `cap(s2) = 4`, потому что от позиции 1 до конца `s1` — 4 элемента.
* При `append(s2, 10)`:
    - `len(s2) = 2,` `cap(s2) = 4` → места хватает,
    - 10 записывается в ячейку с индексом 3 базового массива,
    - которая принадлежит `s1` → `s1[3]` становится `10`.

Это не баг Go — это особенность, но она ломает ожидания, если не понимать модель памяти.

Разработчик думает:
* «Я работаю с `s2` — это копия части `s1`. Мои изменения не должны влиять на `s1`».
Но на самом деле:
* Слайсы — это не копии данных, а "окна" в общий массив.
И `append` — это мутация базового массива, если есть место (`cap` позволяет).

### Опасные сценарии:

1. Модификация исходного среза при фильтрации "на месте":
```go
// Попытка удалить чётные числа
nums := []int{1, 2, 3, 4, 5}
var result []int
for _, n := range nums {
    if n%2 == 1 {
        result = append(result, n)
    }
}
// Всё ок? Да, но...

// А если сделать так:
filtered := nums[:0] // len=0, cap=5 — тот же массив!
for _, n := range nums {
    if n%2 == 1 {
        filtered = append(filtered, n) // пишет в nums!
    }
}
fmt.Println(nums) // [1 3 5 4 5] ← испортили исходный срез!
```

Такой подход иногда используется для экономии памяти, но крайне опасен, если `nums` используется дальше.

2. Параллельное использование слайсов (без конкурентности, но с общим массивом)
```go
data := loadRecords() // []Record
worker1 := data[0:100]
worker2 := data[100:200]

// Если worker1 делает append в свой слайс с cap > 100 — он может затереть данные worker2
```

### Как избежать побочных эффектов

1. Если нужна изоляция — делайте копию:
```go
s2 := make([]int, len(originalSlice))
copy(s2, originalSlice)
// или (Go 1.22+):
s2 := slices.Clone(originalSlice)
```

Теперь `append(s2, ...)` безопасен.

2. Ограничьте вместимость с помощью full slice expression:
```go
s1 := []int{1, 2, 3, 4, 5}
s2 := s1[1:3:3] // третий параметр — максимальная ёмкость
// Теперь: len=2, cap=2

s3 := append(s2, 10) // cap(s2)=2 → realloc Новый массив.
fmt.Println(s1) // [1 2 3 4 5] ← не изменился!
```

Синтаксис: `s[low:high:max]` → `cap = max - low`. Это гарантирует, что `append` не сможет затронуть элементы за пределами `s2`.

3. Не используйте `s[:0]` для "очистки", если исходный срез ещё нужен:

Вместо:
```go
tmp := original[:0] // опасно!
```

Лучше:
```go
tmp := make([]T, 0, len(original)) // новый массив
```

Или, если хотите переиспользовать память — убедитесь, что original больше не используется.

4. Будьте осторожны с `append` в циклах над исходным срезом:
```go
// Плохо:
for i := range items {
    newItem := process(items[i])
    items = append(items, newItem) // может перезаписать items[i+1]!
}

// Хорошо:
newItems := make([]Item, 0, len(items)*2)
for _, item := range items {
    newItems = append(newItems, item, process(item))
}
```

Иногда это намеренная оптимизация:
```go
// Пул буферов
buf := make([]byte, 0, 1024)
for {
    buf = buf[:0] // reuse capacity
    readInto(buf)
    process(buf)
}
```

Здесь мы сознательно переиспользуем память, и знаем, что старые данные не нужны.
`Но это продвинутый паттерн, и его нужно документировать.`

`append` — мощная и эффективная функция, но она не "чистая": она может иметь побочные эффекты на другие слайсы.
Если вы не уверены, что слайс изолирован — не делайте `append` без копирования или ограничения `cap`.

## ОШИБКА #26: СРЕЗЫ И УТЕЧКИ ПАМЯТИ

Одна из самых тонких и важных тем в Go, особенно когда речь идёт о долгоживущих приложениях. Хотя Go имеет сборщик мусора, неправильная работа со срезами может привести к "утечкам" памяти, даже если вы не держите явные ссылки на большие данные.

Обсудим два случая: один, при котором происходит утечка емкости, и другой — связанный с указателями.

### 1. Утечки ёмкости (Capacity Leaks)

Суть проблемы: Когда вы создаёте небольшой срез из большого, он сохраняет ссылку на весь исходный базовый массив — даже если вам нужны только несколько элементов. Это предотвращает освобождение всей памяти, занимаемой исходным массивом.

```go
func readHugeFile() []byte {
    // Предположим, файл — 1 ГБ
    data := make([]byte, 1_000_000_000)
    // ... читаем данные
    return data
}

func processLine() []byte {
    huge := readHugeFile()           // 1 ГБ в памяти
    line := huge[1000:1050]          // Нужны только 50 байт!
    return line                      // ← но line ссылается на весь 1 ГБ массив!
}
```

Что происходит:
* `line` — это слайс длиной 50, но его `cap` = ~999 999 000.
* Базовый массив не может быть собран GC, потому что `line` на него ссылается.
* Даже если вы вернёте `line` из функции и будете использовать только эти 50 байт — вся 1 ГБ памяти останется в куче.


Как исправить? Сделайте настоящую копию нужной части:
```go
func processLine() []byte {
    huge := readHugeFile()
    line := huge[1000:1050]

    // Копируем только нужные данные
    safeLine := make([]byte, len(line))
    copy(safeLine, line)
    return safeLine // Теперь базовый массив huge может быть собран GC
}
```

Или (Go 1.22+):
```go
safeLine := slices.Clone(line)
```

Теперь `safeLine` ссылается на новый, маленький массив — и `huge` освобождается.

### 2. Срезы и указатели (Slices with Pointers)

Суть проблемы: Если срез содержит указатели (включая ссылочные типы: `*T`, `map`, `chan`, `func`, `interface{}`), то даже один "живой" элемент в срезе может удерживать в памяти весь большой объект, на который он ссылается. Это особенно опасно, когда вы удаляете элементы из среза, но не обнуляете их.

Пример: удаление элемента без обнуления:
```go
type BigStruct struct {
    Data [1000000]int // очень большой объект
}

var items []*BigStruct

// Добавили много элементов
for i := 0; i < 1000; i++ {
    items = append(items, &BigStruct{...})
}

// Удаляем первый элемент "неправильно"
items = items[1:] // ← срез теперь начинается со второго элемента
```

Проблема:
* `items[0]` (старый первый элемент) больше не виден в срезе,
* Но GC всё ещё видит указатель на `BigStruct`, потому что базовый массив `items` всё ещё содержит этот указатель!
* Пока базовый массив жив (а он жив, потому что `items` на него ссылается), весь `BigStruct` остаётся в памяти.

Это утечка через указатель: вы "потеряли" доступ к объекту, но он не удаляется.

Как исправить? Обнуляйте удаляемые элементы, чтобы GC мог их собрать:
```go
// Правильное удаление по индексу i
func removeAt(items []*BigStruct, i int) []*BigStruct {
    // Обнуляем указатель
    items[i] = nil
    // Сдвигаем срез
    return append(items[:i], items[i+1:]...)
}
```

Или, если вы делаете `items = items[1:]`, и никогда не будете использовать старую часть массива, можно также обнулить "хвост":
```go
// После items = items[1:], обнулить старый элемент
itemsOrig := items
items = items[1:]
if len(itemsOrig) > 0 {
    itemsOrig[0] = nil // помочь GC
}
```

Это особенно важно для пулов, кэшей, очередей — где элементы часто добавляются и удаляются.

### рекомендации:

1. Избегайте хранения указателей в срезах, если не нужно

Если возможно, храните значения, а не указатели:
```go
[]BigStruct // вместо []*BigStruct
```
Тогда при удалении элемента память освобождается автоматически

2. Используйте `sync.Pool` или переиспользуемые буферы осторожно

Если вы кладёте в пул срез с указателями — обнуляйте его перед возвратом:
```go
for i := range buf {
    buf[i] = nil
}
pool.Put(buf)
```

3. Профилируйте память

Используйте `pprof`:
```go
import _ "net/http/pprof"
```

Запустите:
```bash
go tool pprof http://localhost:6060/debug/pprof/heap
```

И смотрите, какие объекты удерживают память.

`Если вы больше не нуждаетесь в данных — убедитесь, что на них нет ссылок. Для срезов это значит: либо копировать нужное, либо обнулять ненужное.`

## ОШИБКА #27: НЕЭФФЕКТИВНО ИНИЦИАЛИЗИРОВАТЬ КАРТЫ

Чтобы понять, почему важна настройка их инициализации, сначала вспомним основы реализации
карт в Go.

### 1. Концепции

В Go карта основана на структуре данных хеш-таблицы. Хеш-таблица представляет собой массив сегментов, каждый из которых является указателем на массив пар «ключ — значение».

Представление хеш-таблицы: map[string]int:
```
Массив [0,1,2,3]

В значении: Массив[0] (8 элементов в ключе) = значение: "two"/2
В значении: Массив[1] (8 элементов в ключе) = значение: отсутствуют
В значении: Массив[2] (8 элементов в ключе) = значение: отсутствуют
В значении: Массив[3] (8 элементов в ключе) = значение: отсутствуют
```

За хеш-таблицей стоит массив из четырех элементов. Если присмотреться к индексу массива, мы заметим, что один сегмент состоит из одной единственной пары «ключ — значение» (элемент): `"two"/2`. Каждый сегмент имеет фиксированный размер из восьми элементов.

Каждая операция (чтение, обновление, вставка, удаление) выполняется путем ассоциирования ключа с индексом массива. Этот шаг зависит от хеш-функции. Эта функция стабильна, потому что мы хотим, чтобы она всякий раз возвращала один и тот же сегмент, если задан один и тот же ключ. В предыдущем примере `hash("two")` возвращает 0. Следовательно, элемент хранится в сегменте, на который ссылается индекс массива 0.

Если мы вставляем другой элемент и хеширование ключа возвращает тот же индекс, Go добавляет еще один элемент в тот же сегмент.

```
Массив [0,1,2,3]

В значении: Массив[0] (8 элементов в ключе) = значение: "two"/2, "six"/6
В значении: Массив[1] (8 элементов в ключе) = значение: отсутствуют
В значении: Массив[2] (8 элементов в ключе) = значение: отсутствуют
В значении: Массив[3] (8 элементов в ключе) = значение: отсутствуют
```

`hash("six")` возвращает значение 0, поэтому элемент записывается в тот же сегмент.

В случае вставки в уже заполненный сегмент (переполнение сегмента) Go создает еще один сегмент из восьми элементов и связывает с ним предыдущий сегмент. 

```
Массив [0,1,2,3]

В значении:       Массив[0] (8 элементов в ключе) = значение: "two"/2, "six"/6 ...
Следующий сегмент Массив[0] (8 элементов в ключе) = значение: "forty-two"/42

В значении: Массив[1] (8 элементов в ключе) = значение: отсутствуют
В значении: Массив[2] (8 элементов в ключе) = значение: отсутствуют
В значении: Массив[3] (8 элементов в ключе) = значение: отсутствуют
```

Что касается операций чтения, обновления и удаления, то Go должен вычислить соответствующий индекс массива. Затем Go последовательно перебирает все ключи, пока не найдет заданный.

### Инициализация

Чтобы понять проблемы, связанные с возможной неэффективной инициализацией карты, создадим тип `map[string]int`, содержащий три элемента:
```go
m := map[string]int{
    "1": 1,
    "2": 2,
    "3": 3,
}
```

За этой картой стоит резервный массив, состоящий из одной записи, а следовательно, из одного сегмента. Что произойдет, если добавить 1 миллион элементов? В этом случае этой одной записи будет недостаточно, потому что поиск ключа в худшем случае будет означать перебор тысяч сегментов. Поэтому карта должна иметь возможность автоматически увеличиваться, чтобы соответствовать количеству элементов.

Когда карта увеличивается в размере, она удваивает количество своих сегментов. условия для такого увеличения карты:
* Среднее количество элементов в сегментах (называемое коэффициентом загрузки) превышает определенную константу, которая равна 6.5 (но ее значение может измениться в будущих версиях, поскольку это внутренний параметр Go)
* Слишком много сегментов оказываются переполненными (содержат более восьми элементов)

Когда размер карты растет, все ключи снова пересылаются во все сегменты. Вот почему при худшем сценарии вставка ключа может быть операцией `O(n)`, где `n` — это общее количество элементов в карте.
Можно использовать встроенную функцию `make`, чтобы при создании карты указать ее начальный размер. Например, если мы хотим инициализировать карту, которая должна содержать 1 миллион элементов, то сделать это можно так:
```go
m := make(map[string]int, 1_000_000)
```

В случае с картами можно задавать встроенной функции `make` в качестве аргумента только начальный размер, а не емкость, как это было в случае со срезами. Указав размер, мы делаем некий намек на количество элементов, которые, как ожидается, будут содержаться в карте. Внутренними средствами карта создается с количеством сегментов, соответствующим хранению одного миллиона элементов. Это экономит процессорное время, поскольку карте не нужно на лету создавать какие-либо сегменты и перебалансировать их.
Кроме того, указание размера `n` не означает создания карты с максимальным количеством элементов, равным `n`. При необходимости мы можем добавить больше чем `n` элементов. Это указание означает запрос к среде выполнения Go на выделение места в памяти для карты с как минимум `n` элементами, что будет полезно, если мы заранее знаем размер.

Это позволяет избежать потенциального увеличения размера карты, что потребует значительных вычислительных ресурсов, поскольку влечет повторное выделение достаточного пространства в памяти и перебалансировку всех ее элементов.

## ОШИБКА #28: КАРТЫ И УТЕЧКИ ПАМЯТИ

При работе с картами в Go нужно понимать некоторые важные характеристики того, как карты увеличиваются и уменьшаются. Углубление в эту тему поможет предотвратить проблемы, вызывающие утечки памяти.

Для начала, чтобы рассмотреть конкретный пример этой проблемы, создадим сценарий, где будем работать со следующей картой:
```go
m := make(map[int][128]byte)
```

Каждый элемент m представляет собой массив из 128 байтов. Сделаем следующее:
* Создадим в памяти пустую карту
* Добавим в нее 1 миллион элементов
* Сотрем все эти элементы и вызовем выполнение GC

После каждого шага выведем размер кучи (в этот раз используя мегабайты):
```go
n := 1_000_000
m := make(map[int][128]byte)
printAlloc()

for i := 0; i < n; i++ { // Добавление 1 миллиона элементов
    m[i] = randBytes()
}
printAlloc()

for i := 0; i < n; i++ { // Удаление 1 миллиона элементов
    delete(m, i)
}
runtime.GC() // Ручной запуск сборки мусора (GC)
printAlloc()
runtime.KeepAlive(m) // Сохранение ссылки на m, чтобы GC не «чистил» карту
```

Создаем пустую карту, добавляем в нее 1 миллион элементов, затем удаляем 1 миллион элементов, а затем запускаем сборщик мусора. Обязательно сохраняем ссылку на карту с помощью `runtime.KeepAlive`, чтобы сборщик мусора не очищал карту. Запустим код:
```bash
0 MB После резервирования в памяти места под m
461 MB После добавления 1 миллиона элементов
293 MB После удаления 1 миллиона элементов
```

Что мы видим? Вначале размер кучи минимален. Затем, после добавления в карту 1 миллиона элементов, он значительно увеличивается. Мы ожидали, что после удаления всех элементов размер кучи сильно уменьшится, однако карты в Go работают иначе. Несмотря на то что сборщик мусора удалил все элементы, размер кучи по-прежнему значителен и составляет 293 Мбайт. Память освободилась, но не в той мере, как мы могли бы ожидать. Почему?

В предыдущем разделе мы говорили, что карта состоит из восьмиэлементных сегментов. На самом деле карта в Go — это указатель на структуру `runtime.hmap`. Эта структура содержит несколько полей, в том числе поле `B`, задающее количество сегментов в карте:
```go
type hmap struct {
    B uint8 // log_2 of # of buckets
        // (can hold up to loadFactor * 2^B items)
    // ...
}
```

После добавления 1 миллиона элементов значение B равно 18, что означает 2^18 = 262 144 сегмента. Каково будет значение `B`, когда мы удалим 1 миллион элементов? Все так же 18. Следовательно, карта по-прежнему содержит такое же количество сегментов.

*Причина в том, что количество сегментов в карте не может сокращаться. Поэтому удаление элементов из карты не влияет на количество существующих сегментов, оно просто обнуляет слоты в сегментах. Карта может только расти и иметь больше сегментов, но она никогда не уменьшается.*

Сделаем шаг назад и обсудим ситуацию, когда то, что карта не может уменьшаться, рискует стать проблемой. Представьте себе создание кэша с помощью `map[int][128]byte`. Эта карта содержит для каждого ID клиента (`int`) последовательность из 128 байтов. Теперь предположим, что мы хотим сохранить последние 1000 клиентов. Размер карты останется постоянным, поэтому не стоит беспокоиться, что карта не может сжаться.

Допустим, что мы хотим сохранять данные за один час. Но компания решила к Черной пятнице провести большую промоакцию: тогда за один час к нашей системе могут подключиться миллионы клиентов. Через несколько дней после этой Черной пятницы в карте будет столько же сегментов, сколько их было в пиковое время. Это объясняет, почему мы можем столкнуться с высокой загрузкой памяти, которая при таком сценарии существенно не уменьшается.

Какие могут быть решения этой проблемы, если мы не хотим вручную перезапускать сервис для очистки того объема памяти, который потребляется картой?

* Одним из решений может быть регулярное повторное создание копии текущей карты. Например, каждый час мы можем создавать новую карту, копировать все элементы и освобождать предыдущую. Главный недостаток такого варианта в том, что после копирования и до следующей сборки мусора за небольшой промежуток времени может требоваться в два раза больший объем текущей памяти.

* Другим решением было бы изменить тип карты для хранения указателя массива: `map[int]*[128]byte`. Это не отменяет того факта, что у нас будет значительное количество сегментов. Однако каждый сегмент будет резервировать память только в соответствии с размером указателя, а не 128 байтов (то есть 8 байтов в 64-разрядных и 4 байта в 32-разрядных системах).

|Шаг|`map[int][128]byte`|`map[int]*[128]byte`|
|--|--|--|
|Создание пустой карты|0 Мбайт|0 Мбайт|
|Добавление 1 миллиона элементов|461 Мбайт|182 Мбайт|
|Удаление всех элементов и исполнение GC|293 Мбайт|38 Мбайт|

Как мы видим, после удаления всех элементов, с типом `map[int]*[128]byte` требуется значительно меньший объем памяти. Кроме того, объем требуемой памяти менее значителен в пиковое время из-за оптимизаций, производимых для уменьшения потребления памяти.

Поскольку карта Go может только увеличиваться в размере, то и потребление памяти только увеличивается. Каких-либо автоматизированных процедур для его уменьшения нет.

## ОШИБКА #29: НЕКОРРЕКТНОЕ СРАВНЕНИЕ ЗНАЧЕНИЙ

Сравнение значений — обычная операция в программировании. Мы часто применяем сравнения: пишем функцию для сравнения двух объектов, сравниваем значения с какой-то ожидаемой величиной и т. д. Интуитивное желание — использовать оператор == везде. Но это не всегда верно.

Начнем с примера. Мы создаем базовую структуру клиента и используем == для сравнения двух ее экземпляров. Что выведет этот код?
```go
type customer struct {
    id string
}
func main() {
    cust1 := customer{id: "x"}
    cust2 := customer{id: "x"}
    fmt.Println(cust1 == cust2)
}
```

Сравнение этих двух структур `customer` в Go допустимая операция, и оно выведет значение `true`. А что, если мы немного изменим структуру `customer` и добавим поле среза?
```go
type customer struct {
    id string
    operations []float64
}
func main() {
    cust1 := customer{id: "x", operations: []float64{1.}}
    cust2 := customer{id: "x", operations: []float64{1.}}
    fmt.Println(cust1 == cust2)
}
```

Можно ожидать, что этот код выдаст `true`. Но он даже не компилируется: `invalid operation: cust1 == cust2 (struct containing []float64 cannot be compared)`

Проблема связана с тем, как работают операторы == и !=. Со срезами или картами они не работают вообще. И поскольку структура `customer` содержит срез, она не компилируется.

Важно понимать, как использовать == и != для того, чтобы проводить сравнение корректно. Мы можем использовать эти операторы для сравнения сопоставимых операндов:
* *булевых значений*: равны ли два логических значения
* *чисел* (`int`, `float` и типы комплексных чисел): равны ли два числовых значения
* *строк*: равны ли две строки
* *каналов*: были ли два канала созданы одним и тем же вызовом функции `make` либо равны ли оба канала `nil`
* *интерфейсов*: имеют ли два интерфейса одинаковые динамические типы и одинаковые динамические значения либо равны ли оба интерфейса `nil`
* *указателей*: указывают ли два указателя на одно и то же значение в памяти
либо равны ли оба указателя `nil`
* *структур и массивов*: состоят ли они из похожих типов

В последнем примере код не скомпилировался, так как структура была составлена на основе типа, не подлежащего сравнению (среза).
Нужно знать и о возможных проблемах использования == и != с типами `any`. Например, разрешено сравнение двух целых чисел, присвоенных типам `any`:
```go
var a any = 3
var b any = 3
fmt.Println(a == b)
```

В результате этот код выведет `true`.

Но что, если мы инициализируем два типа `customer` (в последней версии, содержащей поле среза) и присваиваем значения типам `any`? Вот пример:
```go
var cust1 any = customer{id: "x", operations: []float64{1.}}
var cust2 any = customer{id: "x", operations: []float64{1.}}
fmt.Println(cust1 == cust2)
```

Этот код компилируется. Но поскольку оба типа нельзя сравнивать, так как структура `customer` содержит поле среза, выполнение кода приводит к ошибке:
```bash
panic: runtime error: comparing uncomparable type main.customer
```

Имея в виду такое поведение, как можно сравнить два среза, две карты или две структуры, содержащие не подлежащие сравнению типы? Если мы придерживаемся стандартной библиотеки, один из вариантов — использовать отражение во время выполнения с пакетом `reflect`.

*Отражение* — это форма метапрограммирования, которая относится к способности приложения анализировать и изменять свою структуру и поведение. Например, в Go можно использовать `Reflect.DeepEqual`. Эта функция сообщает, являются ли два элемента глубоко равными (deeply equal), рекурсивно обходя два значения. Элементы, которые могут быть ее аргументами, являются базовыми типами, а также массивами, структурами, срезами, картами, указателями, интерфейсами и функциями.

Запустим код из первого примера еще раз, добавив `Reflect.DeepEqual`:
```go
cust1 := customer{id: "x", operations: []float64{1.}}
cust2 := customer{id: "x", operations: []float64{1.}}
fmt.Println(reflect.DeepEqual(cust1, cust2))
```

Несмотря на то что структура `customer` содержит не подлежащие сравнению типы (срез), она работает, как и ожидалось, выдавая значение `true`.

При использовании `Reflect.DeepEqual` важно помнить о двух вещах.
* Во-первых, эта функция делает различие между пустой и нулевой коллекцией, как обсуждалось в рассмотрении ошибки #22 (путать пустые и нулевые срезы).
* Другая загвоздка довольно стандартна для большинства языков. Поскольку эта
функция использует отражение, которое интроспективно исследует значения во время выполнения, чтобы узнать, как они формируются, у нее есть проблемы с производительностью. Выполнение нескольких локальных бенчмарков со структурами разного размера показывает, что в среднем `Reflect.DeepEqual` примерно в 100 раз медленнее, чем ==. 

Если производительность — решающий фактор, другим вариантом может быть реализация собственного метода сравнения. Вот пример, который сравнивает две структуры `customer` и возвращает результат логического типа:
```go
func (a customer) equal(b customer) bool {
    if a.id != b.id { // Проводится сравнение полей id
        return false
    }
    if len(a.operations) != len(b.operations) { // Проверяется длина обоих срезов
        return false
    }
    for i := 0; i < len(a.operations); i++ { // Проводится сравнение каждого элемента обоих срезов
        if a.operations[i] != b.operations[i] {
            return false
        }
    }
    return true
}
```

Здесь мы создаем собственный метод сравнения со своими способами проверки различных полей структуры `customer`. Запуск локального бенчмарка на срезе, состоящем из 100 элементов, показывает, что этот метод equal примерно в 96 раз быстрее, чем `Reflect.DeepEqual`.

Нужно помнить, что применение оператора == довольно ограниченно. Например, он не работает со срезами и картами. В большинстве случаев задача сравнения решается использованием `Reflect.DeepEqual`, но основным недостатком становится снижение производительности.
Важно помнить, что в стандартной библиотеке уже есть некоторые методы сравнения. Например, можно использовать оптимизированную функцию `bytes.Compare` для сравнения двух срезов байтов.

## ИТОГ:

* При чтении существующего кода имейте в виду, что целочисленные литералы, начинающиеся с `0`, являются восьмеричными числами. Для удобочитаемости делайте восьмеричные целые числа явными, добавляя к ним префикс `0o`
* Поскольку целочисленные переполнения и антипереполнения в Go обрабатываются автоматически, можно реализовать собственные функции для их обнаружения
* Выполнение сравнений чисел с плавающей точкой по принципу попадания их разницы в пределы заданной дельты может обеспечивать переносимость кода
* При выполнении операций сложения или вычитания для повышения точности группируйте операции с числами, переменными, значениями одинаковых порядков величины. Сначала делайте умножение и деление, а потом сложение и вычитание
* Понимание разницы между длиной и емкостью среза очень важно в разработке на Go. Длина среза — это количество доступных в нем элементов, а емкость — количество элементов в резервном массиве
* При создании среза инициализируйте его с заданной длиной или емкостью, если его длина заранее известна. Это уменьшает количество операций по резервированию места в памяти и повышает производительность. Та же логика применима и к картам: при инициализации задайте их размер
* Использование копирования или полного выражения среза — это способ предотвратить возникновение конфликтов при использовании функции `append`, если две разные функции используют срезы с одним и тем же резервным массивом. Но только создание копии среза предотвращает утечку памяти, если вы хотите уменьшить срез большого размера
* Если вы хотите скопировать один срез в другой с помощью встроенной функции `copy`, помните, что количество копируемых элементов соответствует минимуму из длин двух этих срезов
* Работая со срезом указателей или со структурами с полями указателей, можно избежать утечек памяти, сделав исключенные операцией нарезки элементы равными `nil`
* Чтобы избежать часто возникающей путаницы при использовании пакетов `encoding/json` или `reflect`, нужно понимать разницу между нулевыми и пустыми срезами. Они оба являются срезами нулевых длины и емкости, но только нулевой срез не требует для себя выделения места в памяти
* Чтобы убедиться, что срез вообще не содержит элементов, проверьте его длину. Эта проверка работает независимо от того, нулевой срез или пустой. То же самое касается и карт
* Для разработки однозначных API не следует проводить различие между нулевыми и пустыми срезами
* Карта в памяти всегда может увеличиваться в размере, но никогда не уменьшается. И если это приводит к проблемам с памятью, попробуйте разные варианты действий: например, принудительно пересоздавать карты с помощью внутренних средств Go или использовать указатели
* Для сравнения типов в Go используйте операторы == и !=, если два типа можно сравнивать в принципе: логические значения, числа, строки, указатели, каналы и структуры, полностью состоящие из сопоставимых друг с другом типов. В противном случае можно использовать `Reflect.DeepEqual` и заплатить цену за отражение либо использовать пользовательские реализации и библиотеки

# Управляющие структуры

## ОШИБКА #30: ИГНОРИРОВАТЬ ТО, ЧТО ЭЛЕМЕНТЫ В ЦИКЛЕ RANGE КОПИРУЮТСЯ

`range` — это удобный способ итераций по различным структурам данных. Не нужно иметь дело с индексами и проверять состояние завершенности цикла. Но Go-разработчики могут забыть или не знать, как `range` присваивает значения, что приводит к распространенным ошибкам.

### Концепция

Цикл range позволяет проводить итерации по различным структурам данных:
* строкам
* массивам
* указателям на массивы
* срезам
* картам
* принимающим каналам

По сравнению с классическим циклом `for` цикл с `range` — это удобный способ перебора всех элементов одной из этих структур данных благодаря лаконичному синтаксису, так же он позволяет избежать ошибки на единицу (off-by-one error)

Пример с итерацией по срезу строк:
```go
s := []string{"a", "b", "c"}
for i, v := range s {
    fmt.Printf("index=%d, value=%s\n", i, v)
}
```

Как правило, `range` создает два значения для каждой структуры данных, кроме принимающего канала, для которого создает только один элемент (значение).

В некоторых случаях нужно только значение элемента, а не его индекс. Так как неиспользование локальной переменной приводит к ошибке компиляции, можно использовать пустой идентификатор для замены индексной переменной:
```go
s := []string{"a", "b", "c"}
for _, v := range s {
    fmt.Printf("value=%s\n", v)
}
```

Если же значение нас не интересует, второй элемент можно опустить:
```go
for i := range s {}
```

### Копия значения

Чтобы эффективно использовать `range`, важно понимать, как во время каждой итерации обрабатывается значение. Рассмотрим пример. Создадим структуру `account`, содержащую единственное поле `balance`:
```go
type account struct {
    balance float32
}
```

Затем создадим срез структуры `account` и переберем каждый элемент, используя цикл `range`. Во время каждой итерации мы увеличиваем `balance` для каждой структуры `account`:
```go
accounts := []account{
    {balance: 100.},
    {balance: 200.},
    {balance: 300.},
}
for _, a := range accounts {
    a.balance += 1000
}
```
Но правильный ответ — `[{100} {200} {300}]`. В этом примере `range` не влияет на содержимое среза.

В Go все, что мы присваиваем, является копией:
* Если мы присваиваем результат выполнения функции, возвращающей *структуру*, Go создает копию этой структуры.
* Если мы присваиваем результат выполнения функции, возвращающей *указатель*, Go создает копию адреса памяти (в 64-битной архитектуре адрес имеет длину 64 бита).

Когда `range` совершает итерацию по структуре данных, выполняется копирование каждого элемента в переменную-значение (второй элемент).

Вернемся к нашему примеру: перебор каждого элемента `account` приводит к тому, что копия структуры присваивается переменной значения `a`. Следовательно, увеличение `balance` с помощью `a.balance += 1000` изменяет только переменную значения (`a`), а не элемент в срезе. Что будет, если нужно обновить элементы среза? Есть два варианта получить доступ к элементу с помощью индекса среза.

* этого можно добиться либо с помощью классического цикла `for`:
```go
for i := 0; i < len(accounts); i++ {
    accounts[i].balance += 1000
}
```

* либо с помощью цикла `range`:
```go
for i := range accounts {
    accounts[i].balance += 1000
}
```

Оба этих варианта приводят к одинаковому эффекту: к обновлению элементов в срезе `accounts`.

Помните, что элемент значения в цикле `range` является копией. Поэтому если значение представляет собой структуру, которую нужно изменить, мы будем обновлять только копию, а не сам элемент (при условии, что модифицируемое значение или поле не является указателем).

Другой вариант: продолжить использовать цикл `range` и получить доступ к значению, но изменить тип среза на срез указателей `account`:
```go
accounts := []*account{ // Обновление типа среза до []*account
    {balance: 100.},
    {balance: 200.},
    {balance: 300.},
}
for _, a := range accounts {
    a.balance += 1000 // Прямое обновление элементов среза
}
```

Как мы уже говорили, переменная `a` является копией указателя `account`, хранящегося в срезе. Но поскольку оба указателя ссылаются на одну и ту же структуру, оператор `a.balance += 1000` обновляет элемент среза.
У этого варианта есть два недостатка:
*  требуется обновить тип среза, что не всегда возможно
*  если важна производительность, то итерация по срезу указателей может быть менее эффективной для центрального процессора из-за отсутствия предсказуемости (этот момент в ошибке #91)

## ОШИБКА #31: ИГНОРИРОВАТЬ ТО, КАК В ЦИКЛАХ RANGE ВЫЧИСЛЯЮТСЯ АРГУМЕНТЫ

Синтаксис цикла `range` требует наличия выражения. Например, в цикле `for i, v := range exp`, `exp` — это выражение. Как мы видели, это может быть строка, массив, указатель на массив, срез, карта или канал.

Рассмотрим пример, где к срезу добавляется элемент, по которому мы выполняем итерацию. Как вы считаете, завершится ли этот цикл?
```go
s := []int{0, 1, 2}
for range s {
    s = append(s, 10)
}
```

Чтобы понять суть, следует помнить, что при использовании цикла `range` **указываемое выражение вычисляется только один раз** — перед началом цикла .В этом контексте слово «вычисляется» означает, что предоставленное выражение копируется во временную переменную, а затем цикл `range` выполняет итерации над этой переменной.
В этом примере:
```
s -> 0, 1, 2
копия range -> 0, 1, 2
```
*`s` копируется во временную переменную, используемую в цикле `range`.* Цикл `range` использует эту временную переменную. Исходный срез `s` также обновляется во время каждой итерации. Следовательно, после трех итераций состояние будет таким
```
s -> 0, 1, 2, 10, 10, 10
```
*Временная переменная остается срезом длиной 3, поэтому итерации прекращаются.*

Каждый шаг приводит к добавлению нового элемента. Но за три шага мы прошлись по всем его элементам. Длина временного среза, используемого в `range`, остается равна 3, поэтому цикл завершается после трех итераций.

Такое поведение отличается от классического цикла `for`:
```go
s := []int{0, 1, 2}
for i := 0; i < len(s); i++ {
    s = append(s, 10)
}
```
В этом примере цикл никогда не закончится. Значение выражения `len(s)` **вычисляется во время каждой итерации**, и раз мы продолжаем добавлять элементы, то никогда не достигнем состояния завершения цикла.

### Каналы

Рассмотрим пример, где цикл `range` осуществляет итерации по каналу.
```go
ch1 := make(chan int, 3) // Создается первый канал, содержащий элементы 0, 1, 2
go func() {
    ch1 <- 0
    ch1 <- 1
    ch1 <- 2
    close(ch1)
}()

ch2 := make(chan int, 3) // Создается второй канал, содержащий элементы 10, 11, 12
go func() {
    ch2 <- 10
    ch2 <- 11
    ch2 <- 12
    close(ch2)
}()

ch := ch1 // ch присваивается значение первого канала

for v := range ch { // Создается клиент канала путем итераций по ch
    fmt.Println(v)
    ch = ch2 // ch присваивается значение второго канала
}
```

Выражение, задаваемое для `range`, представляет собой канал `ch`, указывающий на `ch1`.  Следовательно, `range` вычисляет `ch`, выполняет его копирование во временную переменную и итерирует по элементам из этого канала. Несмотря на то что `ch = ch2`, цикл `range` продолжается по `ch1`, а не `ch2`:
```
0
1
2
```

Но оператор `ch = ch2` все-таки оказывает некоторое влияние. Поскольку мы присвоили второй переменной значение `ch`, то если после этого кода вызовем `close(ch)`, закроется второй канал, а не первый.

### Массив

Поскольку выражение, по которому проводятся итерации в цикле `range`, вычисляется до начала цикла, то, что присваивается временной переменной цикла, является копией массива.

```go
a := [3]int{0, 1, 2} // Создается массив из трех элементов
for i, v := range a { // Проводятся итерации по массиву
    a[2] = 10 // Обновляется последний индекс
    if i == 2 { // На печать выводится содержимое последнего индекса
        fmt.Println(v)
    }
}
```
Этот код меняет значение последнего индекса на 10. Но в результате выполнения кода будет выведено не 10, а 2. Как мы уже говорили, оператор `range` создает копию массива. По мере выполнения цикла обновляется не копия, а исходный массив `a`.

Если нужно вывести фактическое значение последнего элемента, то сделать это можно двумя способами:

1. Получая доступ к элементу по его индексу:
```go
a := [3]int{0, 1, 2}
for i := range a {
    a[2] = 10
    if i == 2 {
        fmt.Println(a[2]) // Обращение к a[2], а не к переменной, по которой осуществляется цикл range
    }
}
```

Поскольку мы обращаемся к исходному массиву, этот код выводит 2 вместо 10.

2. Используя указатель массива:
```go
a := [3]int{0, 1, 2}
for i, v := range &a { // Цикл range осуществляется по &a, а не по a
    a[2] = 10
    if i == 2 {
        fmt.Println(v)
    }
}
```

Мы присваиваем копию указателя массива временной переменной, используемой оператором `range`. Но поскольку оба указателя ссылаются на один и тот же массив, обращение к `v` также возвращает 10.

Оба варианта допустимы и приводят к правильному результату. Но во втором варианте не производится копирование всего массива, о чем следует помнить, если массив имеет значительный размер.

## ОШИБКА #32: ИГНОРИРОВАТЬ ВЛИЯНИЕ, КОТОРОЕ ОКАЗЫВАЕТ ИСПОЛЬЗОВАНИЕ ЭЛЕМЕНТОВ УКАЗАТЕЛЯ В ЦИКЛАХ RANGE

Прежде всего проясним причину использования среза или карты элементов указателей. Есть три основных сценария:
1. Хранение данных с применением семантики указателей подразумевает совместное использование элемента. Например, следующий метод содержит логику для вставки элемента в кэш:
```go
type Store struct {
    m map[string]*Foo
}
func (s Store) Put(id string, foo *Foo) {
    s.m[id] = foo
    // ...
}
```
Здесь применение семантики указателя подразумевает, что элемент `Foo` общий как для вызывающего объекта `Put`, так и для структуры `Store`.

2. Бывают случаи, когда мы уже производим какие-то действия с указателями. Поэтому вместо значений может быть удобно сохранять непосредственно указатели.

3. Если мы держим в памяти структуры больших размеров и они часто изменяются, то можно использовать указатели, чтобы избежать операции копирования и вставки при каждом таком изменении:
```go
func updateMapValue(mapValue map[string]LargeStruct, id string) {
    value := mapValue[id] // Копирование
    value.foo = "bar"
    mapValue[id] = value // Вставка
}
func updateMapPointer(mapPointer map[string]*LargeStruct, id string) {
    mapPointer[id].foo = "bar" // Прямое изменение элемента карты
}
```

Поскольку аргумент функции `updateMapPointer` — это карта указателей, изменение поля `foo` можно выполнить за один шаг.

Обсудим распространенную ошибку с элементами-указателями, возникающую при работе с `range`. Рассмотрим две структуры:
* `Customer`, представляющую собой потребитель.
* `Store`, которая содержит карту указателей `Customer`.
```go
type Customer struct {
    ID string
    Balance float64
}
type Store struct {
    m map[string]*Customer
}
```
Следующий код итерирует по срезу элементов `Customer` и сохраняет их в карте `m`:
```go
func (s *Store) storeCustomers(customers []Customer) {
    for _, customer := range customers {
        s.m[customer.ID] = &customer // Сохранение указателя customer в карте
    }
}
```

Мы итерируем по входному срезу с помощью оператора `range` и сохраняем указатели `Customer` в карте. Но приводит ли такой метод к тому, что ожидается?

Вызовем его с помощью фрагмента из трех разных структур `Customer`:
```go
s.storeCustomers([]Customer{
    {ID: "1", Balance: 10},
    {ID: "2", Balance: -10},
    {ID: "3", Balance: 0},
})
```

Вот результат этого кода, если вывести содержимое карты:
```bash
key=1, value=&main.Customer{ID:"3", Balance:0}
key=2, value=&main.Customer{ID:"3", Balance:0}
key=3, value=&main.Customer{ID:"3", Balance:0}
```

Вместо сохранения трех разных структур `Customer` все элементы, хранящиеся в карте, ссылаются на одну и ту же структуру Customer — третью. Что пошлоне так?

Итерация по срезу клиентов с использованием цикла `range` создает независимо от количества элементов одну-единственную переменную `customer` с фиксированным адресом. Проверим это, выводя адрес указателя во время каждой итерации:
```go
func (s *Store) storeCustomers(customers []Customer) {
    for _, customer := range customers {
        fmt.Printf("%p\n", &customer) // Вывод адреса customer
        s.m[customer.ID] = &customer
    }
}

0xc000096020
0xc000096020
0xc000096020
```
Почему это важно? Рассмотрим каждую итерацию:
* При первой итерации `customer` ссылается на первый элемент — Customer 1. Мы сохраняем указатель в структуре `customer`.
* При второй итерации `customer` теперь ссылается на другой элемент — Customer 2. Также сохраняем указатель в структуре `customer`.
* Наконец, при последней итерации `customer` ссылается на последний элемент — Customer 3. И опять тот же указатель сохраняется в карте.

В конце каждой итерации мы трижды сохраняли один и тот же указатель в карте.

Есть два способа решить эту проблему.

1. Cоздание локальной переменной:
```go
func (s *Store) storeCustomers(customers []Customer) {
    for _, customer := range customers {
        current := customer
        s.m[current.ID] = &current // Запись указателя в карту
    }
}
```

В этом примере мы не храним указатель, ссылающийся на `customer`, а сохраняем указатель, ссылающийся на `current` — переменную, ссылающуюся на уникальный `Customer` во время каждой итерации. 

2. Сохранять указатель, ссылающийся на каждый элемент, используя индекс среза:
```go
func (s *Store) storeCustomers(customers []Customer) {
    for i := range customers {
        customer := &customers[i] // Присвоение customer значения указателя на элемент i
        s.m[customer.ID] = customer // Сохранение указателя customer
    }
}
```

В этом решении `customer` теперь указатель. Поскольку он инициализируется во время каждой итерации, то имеет уникальный адрес. Поэтому мы храним в картах разные указатели.

## ОШИБКА #33: ДЕЛАТЬ НЕВЕРНЫЕ ДОПУЩЕНИЯ ВО ВРЕМЯ ИТЕРАЦИЙ КАРТЫ

При итерациях карты возможны две ошибки, основанные на неверных допущениях:

### 1. Упорядочивание

Важно понять несколько фундаментальных свойств структуры данных `map`:
* Она не хранит данные, отсортированные по ключу (карта не основана на двоичном дереве).
* Она не сохраняет порядок, в котором были добавлены данные. Например, если мы вставляем пару *A* перед парой *B*, то не должны делать никаких предположений, основанных на таком порядке вставки.

`При итерациях карты мы вообще не должны делать никаких допущений относительно упорядочивания.`

Рассмотрим карту состоящую из четырех сегментов (элементы представляют ключ). Каждый индекс резервного массива ссылается на какой-то сегмент.

```
Шаги
Вставка a
Вставка y
Вставка z
Вставка c
Вставка d
Вставка e

Индексы массива:
[0] = [a, c, _, _, _, _, _, _]
[1] = [_, _, _, _, _, _, _, _]
[2] = [z, d, e, _, _, _, _, _]
[3] = [y, _, _, _, _, _, _, _]
```

С помощью цикла `range` переберем элементы этой карты и выведем все ключи:
```go
for k := range m {
    fmt.Print(k)
}
```

Мы уже говорили, что сортировка данных по ключу не делается. Следовательно, мы не можем ожидать, что в результате выполнения этого кода будет выведено `acdeyz` или `ayzcde` или `aczdey`. В Go порядок итераций по карте *не определяется и не указывается*. Нет никакой гарантии, что порядок будет одинаковым от одной итерации к другой.

Справедливость всех этих утверждений подтверждается разными запусками кода:
```bash
zdyaec
czyade
```
Вывод отличается от одной итерации к другой.

Go-разработчикам никогда не следует делать какие-либо предположения относительно порядка при итерациях карт. Если нужно какое-либо упорядочивание, рекомендую использовать другие структуры данных, например двоичную кучу (библиотека GoDS на https://github.com/emirpasic/gods)

### 2. Вставка карты во время итераций

В Go разрешено обновление карты (вставка или удаление элемента) во время итераций — это не приводит к ошибкам компиляции или выполнения. Но есть нюанс, который следует учитывать при добавлении элемента в карту во время итерации, чтобы избежать недетерминированных результатов.

В примере ниже проводятся итерации по `map[int]bool`. Если значение пары равно `true`, мы добавляем еще один элемент. Как вы думаете, что выведет этот код?
```go
m := map[int]bool{
    0: true,
    1: false,
    2: true,
}
for k, v := range m {
    if v {
        m[10+k] = true
    }
}
fmt.Println(m)
```
Результат непредсказуем. Посмотрите на несколько примеров вывода:
```bash
map[0:true 1:false 2:true 10:true 12:true 20:true 22:true 30:true]
map[0:true 1:false 2:true 10:true 12:true 20:true 22:true 30:true 32:true]
map[0:true 1:false 2:true 10:true 12:true 20:true]
```

Вот что говорится в спецификации Go по поводу создания нового элемента карты во время итераций:

**Если запись карты создается во время итерации, она может быть произведена во время итерации или пропущена. Выбор может варьироваться для каждой созданной записи и от одной итерации к другой.**

Когда элемент добавляется к карте во время итерации, он может быть либо создан, либо нет при последующей итерации. Оно может варьироваться от одной итерации к другой, и поэтому мы трижды получали разные результаты.

Если нужно обновить карту во время итерации по ней и убедиться, что добавленные записи не часть этой итерации, то одним из решений будет работа с копией карты:
```go
m := map[int]bool{
    0: true,
    1: false,
    2: true,
}
m2 := copyMap(m) // Создается копия первоначальной карты

for k, v := range m {
    m2[k] = v
    if v {
        m2[10+k] = true // Обновляется m2 вместо m
    }
}
fmt.Println(m2)
```

В этом примере мы отделяем читаемую карту от обновляемой. Мы продолжаем итерировать по `m`, но все обновления делаются на `m2`. Эта новая версия кода ведет к предсказуемому и повторяемому результату:
```bash
map[0:true 1:false 2:true 10:true 12:true]
```

При работе с картой не полагайтесь на следующее:
* на то, что данные упорядочиваются по ключам;
* на то, что порядок вставки сохранится;
* на детерминированность порядка итераций;
* на то, что элемент будет создан во время той же итерации, во время которой он был добавлен.

## ОШИБКА #34: ИГНОРИРОВАТЬ ОСОБЕННОСТИ РАБОТЫ ОПЕРАТОРА BREAK

Когда циклы используются в сочетании со `switch` или `select`, разработчики часто совершают ошибку, прерывая не тот оператор.

Рассмотрим пример. Мы используем `switch` внутри цикла `for`. Когда индекс цикла получает значение 2, требуется прервать цикл:
```go
for i := 0; i < 5; i++ {
    fmt.Printf("%d ", i)

    switch i {
    default:
        case 2: // Если i равен 2, то вызывается оператор break
    break
    }
}
```
На первый взгляд код может казаться правильным, но он не приводит к выполнению ожидаемых действий. Оператор `break` не завершает цикл `for`, он завершает действие оператора `switch`. Следовательно, вместо итерации от 0 до 2 этот код выполняет итерацию от 0 до 4: `0 1 2 3 4`.

**Важное правило, о котором следует помнить, заключается в том, что оператор `break` завершает выполнение самого последнего оператора `for`, `switch` или `select`**

Как написать код, который будет прерывать цикл, а не действие оператора `switch`? Самый идиоматический способ — использовать метку:
```go
loop: // Определяется метка loop
for i := 0; i < 5; i++ {
    fmt.Printf("%d ", i)

    switch i {
        default:
    case 2:
        break loop // Прерывается цикл, привязанный к метке loop, а не к switch
    }
}
```
Здесь мы связываем `loop` с циклом `for`. Поскольку мы указываем эту метку в операторе `break`, то он прерывает цикл, а не действие оператора `switch`. Новый код выведет `0 1 2`, как и требовалось.

Прерывание не того оператора также может произойти и в случае с `select`, находящимся внутри цикла.
```go
for {
    select {
    case <-ch:
        // Какие-то действия
    case <-ctx.Done():
        break // Цикл прерывается, если контекст отменяется
    }
}
```

Здесь самым внутренним оператором из списка `for`, `switch`, `select` является `select`, а не `for`. Поэтому цикл продолжается. Чтобы прервать сам цикл, используем метку:
```go
loop: // Определяется метка loop
for {
    select {
    case <-ch:
        // Какие-то действия
    case <-ctx.Done():
        break loop // Прерывается выполнение привязанного к loop цикла, а не select
    }
}
```

*Можно использовать `continue` с меткой, чтобы перейтик следующей итерации отмеченного цикла.*

При использовании `switch` или `select` внутри цикла нужно быть очень внимательными. При использовании `break` тщательно проверяйте, на какой оператор он повлияет. Использование меток — это идиоматическое решение для принудительного прекращения определенного оператора.

## ОШИБКА #35: ИСПОЛЬЗОВАТЬ DEFER ВНУТРИ ЦИКЛОВ

Оператор `defer` откладывает выполнение вызова до возвращения соседней функции. Например, если ресурс в итоге должен быть закрыт, можно использовать `defer`, чтобы избежать повторения вызовов для закрытия перед каждым возвратом. Распространенная ошибка — незнание последствий использования `defer` внутри цикла.

Например, нужно реализовать функцию, которая будет открывать какую-то группу файлов, причем пути к ним получены из канала.
```go
func readFiles(ch <-chan string) error {
    for path := range ch { // Итерации по каналу
        file, err := os.Open(path) // Открывается файл
        if err != nil {
            return err
        }

        defer file.Close() // Откладывается вызов file.Close()
        // Какие-то действия с файлом
    }
    return nil
}
```

В такой реализации есть проблема. `Defer` планирует вызов функции, когда возвращается окружающая функция. В данном случае вызов `defer` выполняется не во время каждой итерации цикла, а при возвращении `readFiles`. Если `readFiles` не вернет значение, дескрипторы файлов останутся открытыми навсегда, что приведет к утечкам.

Как решить эту проблему? Создать вокруг `defer` другую окружающую функцию, которая будет вызываться во время каждой итерации. Например, можно реализовать функцию `readFile`, содержащую логику для каждого нового полученного пути к файлу:
```go
func readFiles(ch <-chan string) error {
    for path := range ch {
        if err := readFile(path); err != nil {
            return err
        }
    }

    return nil
}

func readFile(path string) error {
    file, err := os.Open(path)
    if err != nil {
        return err
    }

    defer file.Close() // Сохраняет вызов defer
    // Какие-то действия с файлом

    return nil
}
```

Здесь `defer` вызывается после возврата `readFile`, то есть в конце каждой итерации. Поэтому мы не держим дескрипторы файлов открытыми до возвращения родительской функции `readFiles`.
Другой подход в том, чтобы сделать функцию `readFile` закрывающей:
```go
func readFiles(ch <-chan string) error {
    for path := range ch {
        err := func() error {
            // ...
            defer file.Close()
            // ...
        }() // Выполнение уже определенной операции закрытия

        if err != nil {
            return err
        }
    }

    return nil
}
```

По сути, это остается тем же самым решением: добавление еще одной окружающей функции для выполнения `defer` во время каждой итерации. Но если важна производительность, то недостатком этого метода будет оверхед на требуемое время на вызовы функции. Если это ваш случай, то следует избавиться от `defer` и обрабатывать вызов `defer` вручную перед выполнением цикла.

При использовании `defer` помните, что она планирует вызов функции, когда возвращается окружающая функция. Вызов `defer` внутри цикла будет складывать все вызовы в стек: они не будут выполняться во время каждой итерации, что может привести к утечке памяти, например, если цикл так и не завершится.

## ИТОГ:

* Значение элемента, по которому проводится цикл `range`, является копией. Поэтому чтобы изменить структуру, обращайтесь к ней, например, через ее индекс или используйте классический цикл `for` (если только элемент или поле, которые вы хотите изменить, не являются указателем).
* Понимание того, что выражение, переданное оператору `range`, вычисляется только один раз перед началом цикла, поможет избежать неэффективного присваивания в итерации по каналу или срезу.
* Используя локальную переменную или обращаясь к элементу по индексу, можно предотвратить ошибки при копировании указателей внутри цикла.
* Чтобы обеспечить предсказуемость результатов при использовании карт, помните, что эта структура данных:
    - не упорядочивает данные по ключам;
    - не сохраняет порядок их вставки;
    - не имеет детерминированного порядка итерации;
    - не гарантирует, что элемент, добавленный во время итерации, будет создан во время этой итерации.
* Использование `break` или `continue` с меткой приводит к прерыванию какого-то конкретного оператора. Это может быть полезно при работе с операторами `switch` или `select` внутри циклов.
* Извлечение логики цикла внутри функции приводит к выполнению оператора `defer` в конце каждой итерации.

# Строки

В Go строка — это неизменяемая структура данных, содержащая:
* указатель на неизменяемую последовательность байтов;
* общее количество байтов в этой последовательности.

## ОШИБКА #36: НЕ ПОНИМАТЬ КОНЦЕПЦИИ РУН

Концепция рун в Go - ключ к пониманию того, как обрабатываются строки, что позволяет избежать распространенных ошибок.

Важно понимать разницу между кодировкой символов (`charset`) и кодированием (`encoding`):
* Кодировка символов, `charset`, — это просто набор символов. Например, кодировка Unicode содержит 221 символ.
* Кодирование — это перевод списка символов в двоичный код. Например, UTF-8 — это стандарт кодирования, определяющий способ того, как возможно закодировать все символы Unicode в переменном количестве байтов (от 1 до 4 байт).

Например, символ `汉` определяется кодовой точкой `U+6C49`. Используя UTF-8, `汉` кодируется тремя байтами: `0xE6`, `0xB1` и `0x89`. Почему это важно? Потому что в Go руна — это кодовая точка Unicode.

UTF-8 кодирует символы в количестве байтов от 1 до 4 байт, следовательно, до 32 бит. Вот почему в Go руна — это псевдоним типа int32:
```go
type rune = int32
```

Еще одна вещь, важная для UTF-8: некоторые считают, что строки Go всегда имеют кодировку UTF-8, но это не так. Рассмотрим пример:
```go
s := "hello"
```

В Go исходный код представлен в UTF-8, то есть все строковые литералы кодируются в последовательность байтов с использованием UTF-8. Но строка представляет собой последовательность произвольных байтов, и она не обязательно основана на UTF-8. Когда мы работаем с переменной, которая не была инициализирована из строкового литерала (например, при чтении из файловой системы), мы не можем считать по умолчанию, что она использует кодировку UTF-8.

**`golang.org/x` — репозиторий, предоставляющий расширения стандартной библиотеки, — содержит пакеты для работы с UTF-16 и UTF-32.**

Эти простые символы кодируются с использованием одного байта каждый. Вот почему вызов функции запроса длины `s` возвращает 5:
```go
s := "hello"
fmt.Println(len(s)) // 5
```

Но символ не всегда кодируется одним байтом. Возвращаясь к символу `汉`, мы упомянули, что в UTF-8 он кодируется тремя байтами. Это подтверждается примером:
```go
s := "汉"
fmt.Println(len(s)) // 3
```
Вместо 1 в этом примере выводится 3. Применяемая к строке встроенная функция `len` возвращает не количество символов, а число байтов.

И наоборот, мы можем создать строку, отталкиваясь от списка байтов. Мы уже упоминали, что символ `汉` кодируется тремя байтами: `0xE6`, `0xB1` и `0x89`:
```go
s := string([]byte{0xE6, 0xB1, 0x89})
fmt.Printf("%s\n", s)
```

### Выводы:
* Кодировка символов — это набор символов. Кодирование же описывает, как кодировка преобразовывается в двоичный код.
* В Go строка ссылается на неизменяемый срез произвольных байтов.
* Исходный код Go использует UTF-8. Все строковые литералы — строки UTF-8. Но поскольку строка может содержать какие угодно произвольные байты, если получена откуда-то еще (а не из исходного кода), то нет гарантии, что она будет основана на кодировке UTF-8.
* Руна соответствует понятию кодовой точки Unicode, означающей элемент, представленным одним значением.
* При использовании UTF-8 кодовая точка Unicode может быть закодирована с помощью одного, двух, трех или четырех байтов.
* Применение функции `len` к строке возвращает количество байтов, а не количество рун.

## ОШИБКА #37: НЕТОЧНАЯ ИТЕРАЦИЯ СТРОК

Рассмотрим пример, где хотим вывести разные руны в строке и их соответствующие позиции:
```go
s := "hêllo" // Литерал строки содержит специальную руну — ê.
for i := range s {
    fmt.Printf("position %d: %c\n", i, s[i])
}
fmt.Printf("len=%d\n", len(s))
```
Мы используем оператор `range` для итерации по `s`, а затем выводим каждую руну, используя ее индекс в строке. Вот результат:
```bash
position 0: h
position 1: Ã
position 3: l
position 4: l
position 5: o
len=6
```

Этот код делает не то, что мы хотим. Выделим три момента:
* Вторая руна в выводе на печать — `Ã`, а не `ê`.
* Мы перепрыгнули с позиции 1 сразу на позицию 3… Но что находится на позиции 2?
* `len` возвращает число 6, тогда как `s` содержит только 5 рун.

Начнем с последнего момента. Мы уже упоминали, что `len` возвращает количество байтов в строке, а не количество рун. Поскольку мы присвоили `s` значение строкового литерала, то `s` будет строкой UTF-8. При этом специальный символ `ê` не кодируется одним байтом — для этого требуется два байта. Следовательно, вызов `len(s)` возвращает 6.

А что, если мы хотим получить количество рун в строке, а не количество байтов?
В предыдущем примере мы присвоили `s` значение строкового литерала, поэтому можно использовать пакет `unicode/utf8`:
```go
fmt.Println(utf8.RuneCountInString(s)) // 5
```

При выводе на печать `s[i]` выводится не i-я руна, а байт с индексом i в представлении UTF-8. Следовательно, мы вывели `hÃllo` вместо `hêllo`.
```
    s      h      ê     l    l    o
[]byte(s)  68   c3 aa   6c   6c   6f
    i      0    1   2   3    4    5
```


Как исправить код, чтобы он выводил все разнообразные руны? Есть два варианта.

1. Мы должны использовать значение элемента оператора `range`:
```go
s := "hêllo"
for i, r := range s {
    fmt.Printf("position %d: %c\n", i, r)
}
```
Чтобы не выводить руну с помощью `s[i]`, мы используем переменную `r`. Использование цикла `range` для строки возвращает две переменные: начальный индекс руны и саму руну:
```bash
position 0: h
position 1: ê
position 3: l
position 4: l
position 5: o
```

2. Другой подход заключается в преобразовании строки в срез рун и итерации по нему:
```go
s := "hêllo"
runes := []rune(s)
for i, r := range runes {
    fmt.Printf("position %d: %c\n", i, r)
}
```

```bash
position 0: h
position 1: ê
position 2: l
position 3: l
position 4: o
```

Здесь мы преобразуем `s` в срез рун, используя `[]rune(s)`. Затем мы проводим итерацию по этому срезу и используем значение элемента оператора `range` для вывода всех рун. Единственная разница связана с позицией: вместо вывода начального индекса последовательности байтов руны код выводит непосредственно индекс руны. Это решение приводит к оверхеду на время выполнения по сравнению с предыдущим. Преобразование строки в срез рун требует выделения места в памяти для дополнительного среза и преобразования байтов в руны: временная сложность O(n), где n — количество байтов в строке.

Если требуется выполнить итерацию по рунам строки, можно использовать цикл `range` напрямую по этой строке. Но следует помнить, что индекс соответствует не индексу руны, а начальному индексу последовательности байтов руны.

## ОШИБКА #38: НЕПРАВИЛЬНО ИСПОЛЬЗОВАТЬ ФУНКЦИИ ОБРЕЗКИ

Одна из распространенных ошибок при использовании пакета `strings` — некоторая неразбериха, связанная с использованием `TrimRight` и `TrimSuffix`. Обе функции служат одной цели, и их довольно легко спутать.

В следующем примере мы используем `TrimRight`. Что выведет этот код?
```go
fmt.Println(strings.TrimRight("123oxo", "xo"))
```

Ответ: *123*. Но этого ли вы ожидали?

`TrimRight` удаляет все завершающие руны, содержащиеся в заданном множестве. В нашем примере мы передали множество `xo`, которое содержит две руны: `x` и `o`.

```
123oxo - o является частью множества, удалить
123ox  - x является частью множества, удалить
123o   - o является частью множества, удалить
123    - 3 НЕ является частью множества, стоп
```

`TrimRight` перебирает каждую руну в обратном порядке. Если руна является частью предоставленного множества, то функция удаляет ее, если нет, то останавливает итерации и возвращает оставшуюся строку. Вот почему наш пример возвращает 123.

С другой стороны, `TrimSuffix` возвращает строку без указанного завершающего суффикса:
```go
fmt.Println(strings.TrimSuffix("123oxo", "xo"))
```

Поскольку `123oxo` заканчивается на `xo`, этот код выводит `123o`.

Принцип будет тем же для левой части строки с `TrimLeft` и `TrimPrefix`:
```go
fmt.Println(strings.TrimLeft("oxo123", "ox")) // 123
fmt.Println(strings.TrimPrefix("oxo123", "ox")) /// o123
```

`Trim` применяет к строке как `TrimLeft`, так и `TrimRight`. Поэтому он удаляет все ведущие и последующие руны, содержащиеся в множестве:
```go
fmt.Println(strings.Trim("oxo123oxo", "ox")) // 123
```

`TrimRight`/`TrimLeft` - удаляет замыкающие/ведущие руны в наборе.
`TrimSuffix`/`TrimPrefix` удаляет указанный суффикс/префикс.

## ОШИБКА #39: НЕДОСТАТОЧНАЯ СТЕПЕНЬ ОПТИМИЗАЦИИ ПРИ КОНКАТЕНАЦИИ СТРОК

Напишем код с функцией `concat`, которая объединяет все строковые элементы среза с помощью оператора `+=`:
```go
func concat(values []string) string {
    s := ""
    for _, value := range values {
        s += value
    }

    return s
}
```
Во время каждой итерации оператор `+=` объединяет `s` со строкой `value`. На первый взгляд эта функция может показаться правильной. Но в этой реализации мы забываем одну из основных характеристик строки: ее неизменность. Следовательно, с каждой итерацией `s` не обновляется, вместо этого в памяти создается новая строка, что сильно влияет на время выполнения этой функции.

К счастью, у этой проблемы есть решение — пакет `strings` и структура `Builder`:
```go
func concat(values []string) string {
    sb := strings.Builder{} // Создается strings.Builder
    for _, value := range values {
        _, _ = sb.WriteString(value) // Добавляется строка
    }

    return sb.String() // Возвращается результирующая строка
}
```

Здесь мы сначала создали структуру `strings.Builder`, задав ей нулевое значение. Во время каждой итерации мы создавали результирующую строку, вызывая метод `WriteString`, который добавляет содержимое `value` во внутренний буфер, сводя к минимуму копирование памяти.

Обратите внимание, что `WriteString` в качестве второго вывода возвращает ошибку, но мы намеренно ее игнорируем. Действительно, этот метод никогда не вернет ненулевую ошибку. Так для чего же он возвращает ошибку как часть своей сигнатуры? `strings.Builder` реализует интерфейс `io.StringWriter`, который содержит единственный метод: `Write-String(s string) (n int, err error)`. Следовательно, чтобы соответствовать этому интерфейсу, `WriteString` должен возвращать ошибку.

Используя `strings.Builder`, мы также можем добавить:
* срез байта с помощью `Write`;
* одиночный байт с помощью `WriteByte`;
* одиночную руну с помощью `WriteRune`.

`strings.Builder` содержит внутри себя байтовый срез. Каждый вызов `WriteString` приводит к вызову `append`, применяемому к этому срезу. Это приводит к двум последствиям.
* эту структуру не следует использовать в режиме конкурентного выполнения, так как вызовы append приведут к состоянию гонки.
* будет иметь место то, что мы уже видели при разборе ошибки #21 (неэффективная инициализация среза): если будущая длина среза уже известна, нужно заранее выделить под него место в памяти. Для этой цели в `strings.Builder` есть метод `Grow(n int)`, он помогает гарантировать наличие места для еще `n` байт.

```go
func concat(values []string) string {
    total := 0
    for i := 0; i < len(values); i++ { // Проводятся итерации по каждой строке для вычисления общего числа байтов
        total += len(values[i])
    }

    sb := strings.Builder{}
    sb.Grow(total) // Вызывается Grow с аргументом, равным этому общему числу

    for _, value := range values {
        _, _ = sb.WriteString(value)
    }

    return sb.String()
}
```

Перед началом итераций мы вычисляем общее количество байтов, которое будет содержать окончательная строка, и присваиваем это значение переменной `total`. Обратите внимание, что нас интересует не количество рун, а количество байтов, поэтому мы используем функцию `len`.

Запустим бенчмарк для сравнения трех версий:
* v1 с использованием `+=`
* v2 с использованием `strings.Builder{}` без предварительного резервирования места в памяти
* v3 с использованием `strings.Builder{}` с предварительным резервированием

Входной срез содержит 1000 строк, и каждая строка содержит 1000 байт:
```bash
BenchmarkConcatV1-4 16 72291485 ns/op
BenchmarkConcatV2-4 1188 878962 ns/op
BenchmarkConcatV3-4 5922 190340 ns/op
```

Как мы видим, последний способ самый эффективный: на 99 % быстрее, чем v1, и на 78 % быстрее, чем v2. Мы можем спросить себя, как двукратное итерирование по входному срезу может ускорить код? Ответ кроется в ошибке # 21 (неэффективная инициализация среза): если для среза с заданной длиной или емкостью не выделено место заранее, то этот срез будет продолжать расти каждый раз, когда окажется заполненным, что приведет к дополнительным выделениям памяти и копиям. Следовательно, двукратное итерирование в этом случае — наиболее эффективный вариант.

`strings.Builder` — рекомендуемое решение для конкатенации списка строк. Обычно это решение следует использовать в циклах. Если просто нужно объединить несколько строк (например, имя и фамилию), использование `strings.Builder` не рекомендуется, так как это сделает код менее читаемым, чем использование оператора `+=` или `fmt.Sprintf`.
С точки зрения производительности решение с использованием `strings.Builder` будет быстрее с того момента, когда нужно будет объединять более пяти строк. Несмотря на то что точное число зависит от многих факторов (например, от размера объединенных строк и от конкретного процессора), это может быть эмпирическим правилом, которое поможет понять, когда предпочесть одно решение другому. Также не стоит забывать, что если количество байтов будущей строки заранее известно, то следует использовать метод `Grow` для предварительного выделения места под внутренний байтовый срез.

## ОШИБКА #40: БЕСПОЛЕЗНЫЕ ПРЕОБРАЗОВАНИЯ СТРОК

Выбирая между работой со строками или с `[]byte`, большинство программистов выберут строки из соображений удобства. Но большая часть операций ввода/вывода на самом деле выполняется с помощью `[]byte`. Например, `io.Reader`, `io.Writer` и `io.ReadAll` работают с `[]byte`, а не со строками. Следовательно, работа со строками требует дополнительных преобразований, хотя пакет `bytes` содержит многие из тех же операций, что и пакет `strings`.

Рассмотрим пример того, **что не следует делать**. Мы реализуем функцию `getBytes`, которая принимает данные `io.Reader` в качестве входных, читает из них и вызывает функцию `sanitize`. Очищение будет выполнено путем обрезки всех начальных и конечных пробелов. Вот скелет функции `getBytes`:
```go
func getBytes(reader io.Reader) ([]byte, error) {
    b, err := io.ReadAll(reader) b это []byte
    if err != nil {
        return nil, err
    }
    // Вызов очистки
}
```

Как реализовать функцию `sanitize`? Одним из вариантов может быть создание функции `sanitize(string) string` с использованием пакета `strings`:
```go
func sanitize(s string) string {
    return strings.TrimSpace(s)
}
```

Теперь вернемся к `getBytes`: когда мы проводим какие-то действия с `[]byte`, сначала нужно преобразовать его в строку, прежде чем вызывать `sanitize`. Затем нужно преобразовать результаты обратно в `[]byte`, потому что `getBytes` возвращает байтовый срез:
```go
return []byte(sanitize(string(b))), nil
```

В чем проблема этой реализации? Двойная плата: за преобразование `[]byte` в строку, а затем за преобразование строки в `[]byte`. С точки зрения использования памяти каждое из этих преобразований требует дополнительного выделения места в ней. Даже если за строкой стоит какой-то `[]byte`, для преобразования `[]byte` в строку требуется создание копии байтового среза. Это означает новое выделение места в памяти и копирование всех байтов.

*Используйте следующий код, чтобы проверить тот факт, что создание строки из `[]byte` приводит к копированию:*
```go
b := []byte{'a', 'b', 'c'}
s := string(b)
b[1] = 'x'
fmt.Println(s)
```
*Выполнение этого кода выводит `abc`, а не `axc`. Ведь в Go строка неизменяема.*


Как реализовать функцию `sanitize`? Вместо того чтобы принимать и возвращать строку, нужно произвести действия над байтовым срезом:
```go
func sanitize(b []byte) []byte {
    return bytes.TrimSpace(b)
}
```
В пакете `bytes` также есть функция `TrimSpace` для обрезки всех начальных и конечных пробелов. Тогда вызов функции `sanitize` не потребует дополнительных преобразований:
```go
return sanitize(b), nil
```

Как мы уже упоминали, большая часть операций ввода/вывода выполняется с помощью `[]byte`, а не строк. Когда мы задаемся вопросом, с чем работать — со строками или с `[]byte`, вспомним, что работа с `[]byte` не обязательно менее удобна. Все экспортируемые функции пакета `strings` также имеют альтернативы в пакете `bytes`: `Split`, `Count`, `Contains`, `Index` и т. д.

## ОШИБКА #41: ПОДСТРОКИ И УТЕЧКИ ПАМЯТИ

Суть ошибки:
В Go подстрока, полученная через срез (`s[start:end]`), не копирует данные, а ссылаются на исходный массив байтов строки. Это означает, что даже если вы сохраняете очень маленькую подстроку из огромной строки, вся исходная строка остаётся в памяти, потому что подстрока на неё ссылается.

Это может привести к утечке памяти (memory leak) — особенно в долгоживущих приложениях или сервисах, обрабатывающих большие объёмы текста (например, логи, HTTP-заголовки, JSON/XML-документы и т.п.).
```go
func extractToken(hugeLogLine string) string {
    // Предположим, hugeLogLine — это строка размером 1 МБ
    // А токен — последние 10 символов
    start := len(hugeLogLine) - 10
    return hugeLogLine[start:]
}
```

На первый взгляд всё нормально: функция возвращает короткую строку. Но на самом деле возвращённая подстрока всё ещё ссылается на внутренний массив байтов оригинальной строки `hugeLogLine`. Поэтому весь 1 МБ останется в памяти, пока живёт эта подстрока.

Если вы сохраните результат в какую-то структуру, кэш или передадите дальше — огромная строка не будет освобождена сборщиком мусора.

В Go строка — это структура из двух полей:
* указатель на массив байтов (data)
* длина (len)

Когда вы делаете `s[i:j]`, Go не копирует данные, а создаёт новую строку, указывающую на тот же data, но с другим смещением и длиной.

`Это оптимизация для производительности, но она имеет побочный эффект — потенциальные утечки памяти.`

Пример утечки:
```go
func main() {
    huge := strings.Repeat("x", 100_000_000) // ~100 МБ
    small := huge[99_999_990:]               // 10 байт... но ссылается на 100 МБ

    // Удалим huge, но small всё ещё держит его в памяти
    huge = ""

    // Проверка: small всё ещё работает
    fmt.Println(len(small)) // 10

    // Но 100 МБ не освободятся, пока `small` живёт
    runtime.GC()
    // Память не уменьшится значительно
}
```
Если заменить `small := huge[...]` на `small := strings.Clone(huge[...])`, то после `GC()` память освободится.

* Чтобы отвязать подстроку от исходной строки, нужно явно скопировать данные. Самый простой способ — использовать `strings.Clone()` (доступно с Go 1.18):
```go
func extractToken(hugeLogLine string) string {
    start := len(hugeLogLine) - 10
    substr := hugeLogLine[start:]
    return strings.Clone(substr) // Создаёт независимую копию
}
```

* В версии Go до 1.18, можно сделать так:
```go
substr := hugeLogLine[start:]
return string([]byte(substr)) // Принудительное копирование
```
Обратите внимание: `string([]byte(s))` действительно копирует данные, потому что преобразование `[]byte → string` в Go всегда создаёт новую строку.

## ИТОГ:
* Для правильной работы со строками в Go важно понимать, что руна соответствует концепции кодовой точки Unicode и может состоять из нескольких байтов.
* Итерация строки с помощью `range` выполняет итерацию по рунам с индексом, соответствующим начальному индексу последовательности байтов руны. Чтобы получить доступ к определенному индексу рун (например, к третьей руне), преобразуйте строку в `[]rune`.
* `strings.TrimRight`/`strings.TrimLeft` удаляет все последующие/ведущие руны, содержащиеся в заданном множестве, тогда как `strings.TrimSuffix`/`strings.TrimPrefix` возвращает строку без указанного суффикса/префикса.
* Конкатенация списка строк должна выполняться с помощью `strings.Builder`, чтобы предотвратить резервирование места в памяти для новой строки во время каждой итерации.
* Помните, что пакет `bytes` позволяет совершать те же операции, что и пакет `strings`, — это поможет избежать лишних преобразований байт/строка.
* Использование копий вместо подстрок может предотвратить утечку памяти, поскольку строка, возвращаемая операцией над подстрокой, будет поддерживаться тем же самым массивом байтов.

# Функции и методы

## ОШИБКА #42: НЕ ЗНАТЬ, КАКОЙ ТИП ПОЛУЧАТЕЛЯ ИСПОЛЬЗОВАТЬ

Во многих случаях использование значения или указателя в качестве получателя должно диктоваться не соображениями производительности, а чем-то другим, что мы и обсудим. Но сначала вспомним, как работают получатели.

В Go можно привязать к методу получатель либо значения, либо указателя. При использовании получателя значения Go создает копию значения и передает ее методу. Любые изменения объекта остаются локальными для метода. Исходный объект остается неизмененным.

В этом примере изменяется получатель значения:
```go
type customer struct {
    balance float64
}

func (c customer) add(v float64) { // Получатель значения
    c.balance += v
}

func main() {
    c := customer{balance: 100.}
    c.add(50.)
    fmt.Printf("balance: %.2f\n", c.balance) // customer balance остается неизмененным
    // 100
}
```

В случае с получателем указателя Go передает методу адрес объекта. По своей сути то, что передается методу, также является копией, но копируется только указатель, а не сам объект (передачи по ссылке в Go нет).
```go
type customer struct {
    balance float64
}

func (c *customer) add(operation float64) { //Получатель указателя
    c.balance += operation
}

func main() {
    c := customer{balance: 100.0}
    c.add(50.0)
    fmt.Printf("balance: %.2f\n", c.balance) //customer balance обновляется
    // 150
}
```

Выбор между получателями значений и указателей не всегда прост.
Получатель **должен** быть указателем:
* Если метод должен изменить получатель. Это правило также действует, если получатель является срезом, а метод должен добавлять элементы:
```go
type slice []int

func (s *slice) add(element int) {
    *s = append(*s, element)
}
```
* Если в получателе метода есть поле, которое нельзя скопировать: например, тип, входящий в пакет синхронизации (подробнее об этом в разделе об ошибке #74 (копировать тип sync).

Получатель **следует** сделать указателем:
* Если получатель — крупный объект. Использование указателя может сделать вызов более эффективным, так как предотвращает создание большой по размеру копии этого объекта. Если вы сомневаетесь в том, крупный ли это объект, хорошей подсказкой станет бенчмаркинг. Практически невозможно указать конкретный размер, поскольку он зависит от многих факторов.

Получатель **должен** быть значением:
* Если нужно обеспечить неизменность получателя.
* Если получателем является карта, функция или канал. Иначе возникнет ошибка при компиляции.

Получатель **следует** сделать значением:
* Если получатель представляет собой срез, который не нужно изменять.
* Если получатель представляет собой небольшой массив или структуру, которая является типом значения без изменяемых полей, например `time.Time`.
* Если получатель является базовым типом — `int`, `float64` или `string`.

Один случай нужно пояснить. Допустим, мы разрабатываем другую структуру `customer`. Ее изменяемые поля не являются частью структуры напрямую, а находятся внутри другой структуры:
```go
type customer struct {
    data *data  // balance не является частью структуры customer напрямую, но содержится в структуре, на которую ссылается поле указателя 
}
type data struct {
    balance float64
}

func (c customer) add(operation float64) { // Используется получатель значения
    c.data.balance += operation
}

func main() {
    c := customer{data: &data{
        balance: 100,
    }}
    c.add(50.)
    fmt.Printf("balance: %.2f\n", c.data.balance) // 150
}
```

Несмотря на то что получатель является значением, вызов `add` в конце концов изменяет фактический `balance`: 150.

*Смешивание типов получателей:*
Можно ли смешивать типы получателей, например, в структуре, содержащей несколько методов, где некоторые содержат получатели указателя, а другие — получатели значения? Общее мнение таково, что это следует запретить. Но в стандартной библиотеке есть контрпримеры, например `time.Time`. Разработчики хотели обеспечить неизменяемость структуры `time.Time`. Следовательно, большинство методов, таких как `After`, `IsZero` и `UTC`, имеют получатели значения. Но для совместимости с существующими интерфейсами — `encoding.TextUnmarshaler` — структура `time.Time` должна реализовать метод `UnmarshalBinary([]byte) error`, который изменяет получатель, задаваемый байтовым срезом. Этот метод имеет получатель указателя. В целом следует избегать смешивания типов получателей, но это не запрещено в 100 % случаев.

Невозможно дать исчерпывающие рекомендации по поводу использования получателей, так как всегда будут крайние случаи.

## ОШИБКА #43: НЕ ИСПОЛЬЗОВАТЬ ИМЕНОВАННЫЕ ПАРАМЕТРЫ РЕЗУЛЬТАТА

Именованные параметры результата — это редко используемая в Go опция. В этом разделе рассмотрим случаи, когда целесообразно использовать именованные параметры результата, чтобы сделать API более удобным.

Пример, в котором используется именованный параметр результата b:
```go
func f(a int) (b int) { // Именует параметр int результата b
    b = a
    return // Возвращается текущее значение b
}
```
В этом примере мы присваиваем имя `b` параметру результата. Когда мы вызываем `return` без аргументов, он возвращает текущее значение `b`.

Когда рекомендуется использовать именованные параметры результата? Рассмотрим следующий интерфейс, который содержит метод для получения координат с заданного адреса:
```go
type locator interface {
    getCoordinates(address string) (float32, float32, error)
}
```
Но сможете ли вы догадаться, прочитав этот код, что представляют собой два результата `float32`? Возможно, это широта и долгота, но что из них что? Зависит от конкретных соглашений: широта не всегда первый элемент. И чтобы понять суть, придется выполнить код. Используем именованные параметры результата для удобочитаемости кода:
```go
type locator interface {
    getCoordinates(address string) (lat, lng float32, err error)
}
```
Здесь уже понятны значения сигнатуры метода: сначала широта (latitude), потом долгота (longitude).

Рассмотрим еще одну сигнатуру функции, позволяющую хранить тип `Customer` в базе данных:
```go
func StoreCustomer(customer Customer) (err error) {
    // ...
}
```
Здесь присваивание параметру ошибки имени `err` никак дополнительно не проясняет ситуацию и не помогает читателям. В этом случае нужно **отказаться** от использования именованных параметров результата.

*Решение о том, использовать или нет именованные параметры результата, зависит от контекста. Если нет уверенности в том, что их использование делает код более читабельным, именованные параметры результата использовать не нужно.*

Также обратите внимание, что наличие уже инициализированных параметров результата может быть весьма удобным в некоторых контекстах, даже если они не обязательно улучшают читабельность. Следующий пример, предложенный в Effective Go (https://go.dev/doc/effective_go), вдохновлен функцией `io.ReadFull`:
```go
func ReadFull(r io.Reader, buf []byte) (n int, err error) {
    for len(buf) > 0 && err == nil {
        var nr int
        nr, err = r.Read(buf)
        n += nr
        buf = buf[nr:]
    }
    return
}
```
В этом примере именованные параметры результата не улучшают читабельность. Но поскольку и `n`, и `err` инициализируются нулевыми значениями, то такая реализация функции короче. С другой стороны, с первого взгляда эта функция может немного сбивать с толку. И это вопрос поиска баланса.

Замечание о пустых `return` (`return` без аргументов): они считаются допустимыми в коротких функциях. В противном случае они могут навредить удобочитаемости, потому что читатель должен помнить выходные данные на протяжении всей функции.

В некоторых случаях именованные параметры результата могут повысить читаемость, например, если два параметра имеют одинаковый тип, но следует использовать их только тогда, когда от этого есть очевидная выгода.

## ОШИБКА #44: ПОБОЧНЫЕ ЭФФЕКТЫ ОТ ИМЕНОВАННЫХ ПАРАМЕТРОВ РЕЗУЛЬТАТА

Именованные параметры результата могут оказаться полезны в некоторых ситуациях, но поскольку инициализация этих результирующих параметров происходит с присваиванием им нулевого значения, то их применение иногда может привести к малозаметным багам.

Усовершенствуем наш предыдущий пример метода, который возвращает широту и долготу по заданному адресу. Как вы думаете, что не так с этим кодом?
```go
func (l loc) getCoordinates(ctx context.Context, address string) (lat, lng float32, err error) {
    isValid := l.validateAddress(address) // Валидация адреса
    if !isValid {
        return 0, 0, errors.New("invalid address")
    }

    if ctx.Err() != nil { // Проверка, был ли отменен контекст и не истек ли крайний срок
        return 0, 0, err
    }
    // Получение и возврат координат
}
```

На первый взгляд ошибка может быть неочевидной. Ошибка, возвращаемая в области видимости `if ctx.Err() != nil`, — это `err`. Но мы не присвоили переменной `err` никакого значения. Ей по-прежнему присвоено нулевое значение типа ошибки: `nil`. Следовательно, этот код всегда будет возвращать ошибку `nil`. Этот код компилируется, потому что `err` была инициализирована нулевым значением благодаря именованным параметрам результата. Без присвоения имени мы получили бы ошибку компиляции:
```bash
Unresolved reference 'err'
```
Один из возможных выходов — сделать переменную err равной `ctx.Err()`:
```go
if err := ctx.Err(); err != nil {
    return 0, 0, err
}
```

Мы продолжаем возвращать `err`, но сначала присваиваем ей результат `ctx.Err()`. Обратите внимание, что `err` в этом примере затеняет переменную результата.

**Именованные параметры результата могут в некоторых случаях улучшить читаемость кода. Но помните, что каждый такой параметр инициализируется своим нулевым значением**

Другой вариант — использовать пустой оператор `return`:
```go
if err = ctx.Err(); err != nil {
    return
}
```
Но при этом нарушается правило, утверждающее, что не нужно смешивать в одном фрагменте кода пустые операторы `return` с такими же операторами, но с аргументами. В этом примере, вероятно, следует придерживаться первого варианта.

## ОШИБКА #45: ВОЗВРАТ ПОЛУЧАТЕЛЯ NIL

Эта ошибка, вероятно, одна из самых распространенных в Go, потому что ее можно считать контринтуитивной, по крайней мере до того, как ее совершили.

Мы будем работать над структурой `Customer` и реализуем метод `Validate` для проверки ее работоспособности (sanity check). Вместо того чтобы возвращать первую ошибку, мы хотим возвращать список ошибок. Для этого создадим собственный тип для передачи за раз нескольких ошибок:

```go
type MultiError struct {
    errs []string
}

func (m *MultiError) Add(err error) { // Добавление ошибки
    m.errs = append(m.errs, err.Error())
}
func (m *MultiError) Error() string { // Реализация интерфейса возврата ошибок
    return strings.Join(m.errs, ";")
}
```

`MultiError` удовлетворяет интерфейсу ошибок, поскольку реализует строку `Error()`. Он раскрывает метод `Add` для добавления ошибки. С помощью этой структуры мы можем реализовать метод `Customer.Validate`, чтобы проверить возраст и имя клиента. Если проверка на работоспособность пройдена успешно, мы хотим вернуть ошибку `nil`:
```go
func (c Customer) Validate() error {
    var m *MultiError // Создается пустой *MultiError

    if c.Age < 0 {
        m = &MultiError{}
        m.Add(errors.New("age is negative")) // Добавляется ошибка, если значение возраста отрицательно
    }

    if c.Name == "" {
        if m == nil {
            m = &MultiError{}
        }
        m.Add(errors.New("name is nil")) // Добавляется ошибка, если значение имени равно nil
    }

    return m
}
```

Проверим эту реализацию, запустив код с валидной структурой `Customer`:
```go
customer := Customer{Age: 33, Name: "John"}
if err := customer.Validate(); err != nil {
    log.Fatalf("customer is invalid: %v", err)
}
```
В результате получим:
```bash
2021/05/08 13:47:28 customer is invalid: <nil>
```
Результат может удивить. Структура `Customer` валидна, но и условие `err != nil` истинно, и запись на ошибки привела к выводу `<nil>`.

Мы должны знать, что в Go получатель указателя может равняться `nil`. Поэкспериментируем, создав фиктивный тип и вызвав метод с нулевым получателем указателя:
```go
type Foo struct{}

func (foo *Foo) Bar() string {
    return "bar"
}

func main() {
    var foo *Foo
    fmt.Println(foo.Bar()) // foo равна nil
}
```
`foo` инициализируется нулевым значением указателя `nil`. Но этот код компилируется и выводит `bar`, если мы его запустим. Нулевой указатель является допустимым получателем.
Почему так? В Go метод — это синтаксический сахар для функции, первым параметром которой является получатель. Следовательно, метод `Bar`, который мы рассматривали, похож на эту функцию:
```go
func Bar(foo *Foo) string {
    return "bar"
}
```
Мы знаем, что передача нулевого указателя на функцию допустима. Поэтому и использование нулевого указателя в качестве получателя допустимо.
Вернемся к исходному примеру:
```go
func (c Customer) Validate() error {
    var m *MultiError

    if c.Age < 0 {
        // ...
    }

    if c.Name == "" {
        // ...
    }

    return m
}
```
`m` инициализируется нулевым значением указателя `nil`. Затем, если все проверки проходят успешно, аргумент оператора `return` является не самим `nil`, а нулевым указателем. Поскольку нулевой указатель является допустимым получателем, преобразование результата в интерфейс не даст нулевого значения. То есть вызывающий объект `Validate` всегда будет получать ненулевую ошибку.

Чтобы прояснить этот момент, вспомним, что в Go интерфейс — это обертка диспетчеризации (dispatch wrapper). Здесь то, что содержится в этой обертке, равно нулю (указатель `MultiError`), а сама обертка — нет (интерфейс `error`).

Независимо от того, чем является `Customer`, вызывающая эту функцию сторона всегда будет получать ненулевую ошибку. *Понимание такого поведения крайне важно, потому что эта ошибка широко распространена.*

Что нужно, чтобы сделать код этого примера корректным? Самое простое решение — возвращать `m`, только если она не равна нулю:
```go
func (c Customer) Validate() error {
    var m *MultiError

    if c.Age < 0 {
        // ...
    }

    if c.Name == "" {
        // ...
    }

    if m != nil {
        return m // m возвращается, только если была хотя бы одна ошибка
    }

    return nil // В противном случае возвращается nil
}
```
В самом конце метода мы проверяем, не равна ли `m` нулю. Если да, то возвращаем `m`. В противном случае мы возвращаем `nil` в явном виде. Следовательно, если структура `Customer` валидная, мы возвращаем нулевой интерфейс, а не нулевой получатель, преобразованный в ненулевой интерфейс.

*Мы увидели, что в Go допускается использование нулевого получателя, а интерфейс, преобразованный из нулевого указателя, не является нулевым интерфейсом. По этой причине, когда нужно вернуть интерфейс, нужно возвращать не нулевой указатель, а непосредственно нулевое значение. Как правило, наличие нулевого указателя нежелательно и означает вероятное наличие ошибки.*

## ОШИБКА #46: ИСПОЛЬЗОВАТЬ ИМЯ ФАЙЛА В КАЧЕСТВЕ ВХОДНЫХ ДАННЫХ ФУНКЦИИ

Предположим, нужно реализовать функцию для подсчета количества пустых строк в файле. Одним из способов реализации этой функции было бы принятие имени файла и использование `bufio.NewScanner` для сканирования и проверки каждой его строки:
```go
func countEmptyLinesInFile(filename string) (int, error) {
    file, err := os.Open(filename) // Открытие filename
    if err != nil {
        return 0, err
    }
    // Обработка закрытия файла

    scanner := bufio.NewScanner(file) // Создание функции scanner из переменной *os.File, которая разбивает входной файл на строки
    for scanner.Scan() { // Итерации по каждой строке
        // ...
    }
}
```

У этой функции ожидаемое поведение. Пока задаваемое имя файла валидно, мы будем читать данные из него и возвращать количество пустых строк. Но в чем проблема?
Допустим, нужно реализовать юнит-тесты, чтобы покрыть следующие случаи:
* номинальный случай;
* пустой файл;
* файл, содержащий только пустые строки.

Каждый юнит-тест потребует создания в нашем Go-проекте какого-то файла. Чем сложнее функция, тем больше случаев нужно протестировать и тем больше файлов мы создадим. В некоторых случаях может потребоваться создать десятки файлов, и процесс станет неуправляемым.

Кроме того, эту функцию нельзя переиспользовать. Например, если бы пришлось реализовать ту же логику, но подсчитать количество пустых строк при HTTP-запросе, пришлось бы продублировать основную логику:
```go
func countEmptyLinesInHTTPRequest(request http.Request) (int, error) {
    scanner := bufio.NewScanner(request.Body)
    // Копируется та же самая логика
}
```
Один из способов преодолеть эти ограничения — сделать так, чтобы функция принимала `*bufio.Scanner` (вывод, возвращаемый `bufio.NewScanner`).

Напишем новую версию функции `countEmptyLines`, которая вместо этого получает абстракцию `io.Reader`:
```go
func countEmptyLines(reader io.Reader) (int, error) { // Получение io.Reader в качестве входных данных
    scanner := bufio.NewScanner(reader) // Создание *bufio.Scanner из io.Reader, а не из *os.File
    for scanner.Scan() {
        // ...
    }
}
```

Поскольку `bufio.NewScanner` принимает `io.Reader`, мы можем напрямую передать переменную `reader`.

В чем преимущества такого подхода? Прежде всего, эта функция абстрагируется от источника данных.
* Он является файлом
* Он является HTTP-запросом
* Он является Входом сокета

Для функции это не важно. Поскольку `*os.File` и поле `Body` в `http.Request` реализуют `io.Reader`, мы можем переиспользовать одну и ту же функцию независимо от типа ввода.

Еще одно преимущество связано с тестированием. Мы упоминали, что создание
файла для каждого теста может стать громоздкой процедурой. Теперь, когда
countEmptyLines принимает io.Reader, мы можем реализовать юнит-тесты,
создав io.Reader из строки:
```go
func TestCountEmptyLines(t *testing.T) {
    emptyLines, err := countEmptyLines(strings.NewReader( // Передача io.Reader из строки
        `foo
        bar
        baz`
    ))
    // Логика теста
}
```

Не нужно создавать для каждого теста свой файл. Каждый тест-кейс может быть автономным, что улучшает читабельность и удобство сопровождения.

Использование имени файла в качестве входных данных функции для чтения из файла в большинстве случаев следует рассматривать как код с душком (за исключением определенных функций, например `os.Open`).
* это усложняет юнит-тесты, поскольку может потребоваться создать несколько файлов.
* это также снижает возможность многократного использования функции.

## ОШИБКА #47: ИГНОРИРОВАТЬ ТО, КАК ВЫЧИСЛЯЮТСЯ АРГУМЕНТЫ И ПОЛУЧАТЕЛИ ОПЕРАТОРА DEFER

Go-разработчики не всегда понимают, как вычисляются аргументы. Углубимся в эту проблему в двух подразделах:

### Вычисление аргументов

Чтобы понять, как вычисляются аргументы `defer`, рассмотрим пример. В нем некая функция должна вызывать две функции — `foo` и `bar`. Кроме того, она также должна отслеживать статус выполнения:
* `StatusSuccess`, если и `foo` и `bar` не возвращают никаких ошибок.
* `StatusErrorFoo`, если возвращает ошибку `foo`.
* `StatusErrorBar`, если возвращает ошибку `bar`.

первая реализация:
```go
const (
    StatusSuccess = "success"
    StatusErrorFoo = "error_foo"
    StatusErrorBar = "error_bar"
)

func f() error {
    var status string
    defer notify(status) // Откладывает вызов notify
    defer incrementCounter(status) // Откладывает вызов incrementCounter

    if err := foo(); err != nil {
        status = StatusErrorFoo // Устанавливает значение status в error foo
        return err
    }

    if err := bar(); err != nil {
        status = StatusErrorBar // Устанавливает значение status в error bar
        return err
    }

    status = StatusSuccess // Устанавливает значение status в success
    return nil
}
```
Но если попробовать запустить выполнение этой функции, мы увидим, что независимо от пути выполнения `notify` и `incrementCounter` всегда вызываются с одним и тем же статусом: пустая строка. Почему?

Важно понять одну вещь о вычислении аргументов функции `defer`: они вычисляются сразу, а не после возврата окружающей функции. В нашем примере мы вызываем `notify(status)` и `incrementCounter(status)` как отложенные функции. Следовательно, Go отложит выполнение этих вызовов до того момента, как `f` вернется с текущим значением `status` на этапе, на котором мы использовали `defer`, передав таким образом пустую строку. Как решить эту проблему, если мы хотим продолжать использовать `defer`? Есть два способа.

1. Передать строковый указатель функциям `defer`:
```go
func f() error {
    var status string
    defer notify(&status) // Указатель на строку передается функции notify как аргумент
    defer incrementCounter(&status) // Указатель на строку передается функции incrementCounter как аргумент

    // Далее код функции остается неизменным
    if err := foo(); err != nil {
        status = StatusErrorFoo
        return err
    }

    if err := bar(); err != nil {
        status = StatusErrorBar
        return err
    }

    status = StatusSuccess
    return nil
}
```

При использовании `defer` аргументы вычисляются сразу — в данном примере они являются адресом `status`. Да, сама переменная `status` изменяется на протяжении выполнения функции, но ее адрес остается неизменным вне зависимости от того, что происходит. Следовательно, если `notify` или `incrementCounter` использует значение, на которое ссылается указатель строки, они будут работать так, как и ожидалось. Но это решение требует изменения сигнатуры двух функций, что не всегда возможно.

2. Вызов замыкания как оператора `defer`. Напоминаем, что замыкание (closure) — это анонимная функция, которая ссылается на переменные вне своего тела. Аргументы, переданные в функцию `defer`, вычисляются сразу. Но мы должны знать, что переменные, на которые ссылается замыкание `defer`, вычисляются во время выполнения замыкания (следовательно, когда возвращается окружающая функция).

Вот пример, показывающий работу замыкания `defer`. Оно ссылается на две переменные, одна из которых аргумент функции, а вторая — переменная вне ее тела:
```go
func main() {
    i := 0
    j := 0
    defer func(i int) { // Вызов в качестве функции defer замыкания, которому в качестве входных данных передается целое число
        fmt.Println(i, j) // i — это входная переменная функции, а j — внешняя переменная
    }(i) // Передача i замыканию (вычисляется сразу)
    i++
    j++
}
```
Здесь замыкание использует переменные `i` и `j`. `i` передается как аргумент функции, поэтому вычисляется немедленно. И наоборот, `j` ссылается на переменную вне тела замыкания, поэтому вычисляется при выполнении замыкания. Если запустить этот пример, будет выведено `0 1`.

Можно использовать замыкание для реализации новой версии нашей функции:
```go
func f() error {
    var status string
    defer func() { // Вызов замыкания как отложенной функции
        notify(status) // Вызов notify внутри замыкания и ссылка на status
        incrementCounter(status) // Вызов incrementCounter внутри замыкания и ссылка на status
    }()

    // Далее код функции остается неизменным
}
```
Это решение также работает и не требует изменения сигнатуры `notify` и `incrementCounter`.

### Получатели значений или указателей

При разборе ошибки #42 (не знать, какой тип получателя использовать) мы говорили, что получатель может быть либо значением, либо указателем. Та же логика, связанная с оценкой аргумента, применяется, когда мы используем `defer` в методе: получатель вычисляется сразу. Разберем последствия применения обоих типов получателей:

1. Пример, в котором вызывается метод в применении к получателю значения с использованием `defer`, но впоследствии получатель меняется:
```go
type Struct struct {
    id string
}

func (s Struct) print() {
    fmt.Println(s.id)
}

func main() {
    s := Struct{id: "foo"}
    defer s.print() // s вычисляется немедленно
    s.id = "bar" // обновление s.id (невидимое)
    // Выведет foo
}
```
Мы откладываем выполнение вызова метода `print`. Как и в случае с аргументами, вызов `defer` немедленно вычисляет получателя. Следовательно, `defer` задерживает выполнение метода со структурой, которая содержит поле `id`, равное `foo`.

2. Если указатель является получателем, потенциальные изменения получателя после вызова `defer` будут видны:
```go
type Struct struct {
    id string
}

func (s *Struct) print() {
    fmt.Println(s.id)
}

func main() {
    s := &Struct{id: "foo"}
    defer s.print() // s — указатель, поэтому он вычисляется немедленно, но может ссылаться на другую переменную при выполнении метода defer
    s.id = "bar" // Обновление s.id (видимое)
    // Выведет bar
}
```
Получатель s также вычисляется немедленно. Однако вызов метода приводит к копированию получателя указателя. Следовательно, изменения, внесенные в структуру, на которую ссылается указатель, видимые.

Когда мы вызываем `defer` в применении к функции или методу, их аргументы вычисляются немедленно. Если мы потом захотим изменить задаваемые перед `defer` аргументы, мы можем использовать указатели или замыкания. Для метода сразу вычисляется и получатель. Следовательно, поведение зависит от того, является получатель значением или указателем.

## ИТОГ:
* Решение об использовании получателя значения или указателя должно приниматься на основе его типа, необходимости изменения, наличия поля, которое не может быть скопировано, и размера объекта. Если сомневаетесь, используйте получатель указателя.
* Применение именованных параметров результата может быть эффективным способом улучшить читаемость функции/метода, особенно если несколько параметров результата имеют один и тот же тип. В некоторых случаях этот подход также может быть удобен, так как именованные параметры результата инициализируются нулевым значением. Но будьте очень внимательны в связи с возможными побочными эффектами.
* В случае возврата интерфейса будьте очень внимательны, если потребуется возвращать его нулевое значение: надо вернуть не нулевой указатель, а явное значение `nil`. В противном случае могут возникнуть непредвиденные последствия, поскольку вызывающая сторона получит значение не `nil`.
* Определение функций, которые получают типы `io.Reader` вместо имен файлов, повышает шансы на возможность переиспользования этих функций и упрощает тестирование.
* Передача указателя функции `defer` и перенос вызова внутрь замыкания — два возможных решения, позволяющих обойти ситуацию, при которой аргументы и получатели вычисляются сразу.